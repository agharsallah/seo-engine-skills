[
  {
    "id": "PAGE_TITLE_EXISTS",
    "title": "Page title tag present and non-empty",
    "category": "Key best practices",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Title is a prominent location for keywords as recommended in the documentation.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head > title",
        "attribute": null,
        "notes": "Extract the text content of the <title> element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Parse html into a DOM.\n# 2. Locate the <title> element using selector \"head > title\".\n# 3. If the element is not found, set observed = null.\n# 4. Else, set observed = trimmed text content of the element.\n# 5. If observed is not null and length(observed) > 0, result = pass else fail.\n"
    },
    "pass_condition": "A <title> element exists and its text is non\u2011empty.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing or empty <title> tag."],
    "references": [
      {
        "doc_title": "Google Search Essentials",
        "url": "https://developers.google.com/search/essentials",
        "section_title": "Key best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["title", "seo", "content"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a non\u2011empty title tag.",
        "snippet": "<html><head><title>Best Coffee Beans</title></head><body>...</body></html>"
      },
      "failing": {
        "description": "Page lacks a title tag or has an empty title.",
        "snippet": "<html><head></head><body>...</body></html>"
      }
    },
    "test_cases": [
      {
        "name": "title_present",
        "input_stub": {
          "html": "<html><head><title>Sample Page</title></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "title_missing",
        "input_stub": {
          "html": "<html><head></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MAIN_HEADING_EXISTS",
    "title": "Main heading (<h1>) present and non-empty",
    "category": "Key best practices",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Main headings are highlighted as prominent locations for keywords.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "h1",
        "attribute": null,
        "notes": "Collect text content of each <h1> element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Parse html into a DOM.\n# 2. Select all <h1> elements.\n# 3. If no <h1> elements found, result = fail.\n# 4. For each <h1>, trim its text content.\n# 5. If any trimmed text is non\u2011empty, result = pass; otherwise fail.\n"
    },
    "pass_condition": "At least one <h1> element exists with non\u2011empty text.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["No non\u2011empty <h1> heading found on the page."],
    "references": [
      {
        "doc_title": "Google Search Essentials",
        "url": "https://developers.google.com/search/essentials",
        "section_title": "Key best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["heading", "h1", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a meaningful <h1>.",
        "snippet": "<h1>Delicious Apple Pie Recipe</h1>"
      },
      "failing": {
        "description": "Page lacks <h1> or has an empty one.",
        "snippet": "<h1>   </h1>"
      }
    },
    "test_cases": [
      {
        "name": "h1_present",
        "input_stub": {
          "html": "<html><body><h1>Welcome</h1></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "h1_missing",
        "input_stub": {
          "html": "<html><body><p>No heading here</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMAGE_ALT_TEXT",
    "title": "All images have non-empty alt attributes",
    "category": "Key best practices",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Alt text is recommended for images to describe content for users and search engines.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "alt",
        "notes": "Collect the alt attribute value for each <img>."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Parse html into a DOM.\n# 2. Select all <img> elements.\n# 3. For each <img>, retrieve its 'alt' attribute.\n# 4. If any <img> lacks an 'alt' attribute or its trimmed value is empty, result = fail.\n# 5. If all images have non\u2011empty alt text, result = pass.\n"
    },
    "pass_condition": "Every <img> element includes a non\u2011empty alt attribute.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Image with src '${src}' is missing alt text."],
    "references": [
      {
        "doc_title": "Google Search Essentials",
        "url": "https://developers.google.com/search/essentials",
        "section_title": "Key best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["images", "alt-text", "accessibility"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All images include descriptive alt attributes.",
        "snippet": "<img src='cat.jpg' alt='A tabby cat sleeping'>"
      },
      "failing": {
        "description": "An image lacks an alt attribute.",
        "snippet": "<img src='logo.png'>"
      }
    },
    "test_cases": [
      {
        "name": "all_images_have_alt",
        "input_stub": {
          "html": "<html><body><img src='a.jpg' alt='A'><img src='b.png' alt='B'></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_alt",
        "input_stub": {
          "html": "<html><body><img src='a.jpg'><img src='b.png' alt=''></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CRAWLABLE_LINKS",
    "title": "All anchor links are crawlable (have valid href)",
    "category": "Key best practices",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Crawlable links enable Google to discover other pages on the site.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a",
        "attribute": "href",
        "notes": "Collect href attribute for each <a> element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Parse html into a DOM.\n# 2. Select all <a> elements.\n# 3. For each <a>, retrieve its 'href' attribute.\n# 4. If href is missing, empty, or starts with \"javascript:\", result = fail.\n# 5. If all anchors have valid href values, result = pass.\n"
    },
    "pass_condition": "Every <a> element has a non\u2011empty href that does not start with \"javascript:\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Anchor link with text '${text}' has an invalid or missing href."
    ],
    "references": [
      {
        "doc_title": "Google Search Essentials",
        "url": "https://developers.google.com/search/essentials",
        "section_title": "Key best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["links", "crawlability", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All links have proper href attributes.",
        "snippet": "<a href='/about'>About Us</a>"
      },
      "failing": {
        "description": "Link uses JavaScript or lacks href.",
        "snippet": "<a href='javascript:void(0)'>Click</a>"
      }
    },
    "test_cases": [
      {
        "name": "valid_links",
        "input_stub": {
          "html": "<html><body><a href='page1.html'>Page 1</a><a href='https://example.com'>External</a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "invalid_links",
        "input_stub": {
          "html": "<html><body><a href='javascript:void(0)'>Bad</a><a>No href</a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "GOOGLEBOT_NOT_BLOCKED",
    "title": "Googlebot is not blocked by robots.txt",
    "category": "Googlebot isn't blocked",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Google must be able to crawl the page; robots.txt disallow rules that match the URL prevent indexing.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Full contents of the site's robots.txt file"
      },
      {
        "name": "url",
        "required": true,
        "description": "Fully qualified URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "User-agent:\\s*(Googlebot|\\*)[\\s\\S]*?Disallow:\\s*(.*)",
        "attribute": null,
        "notes": "Capture Disallow paths for Googlebot or wildcard agents"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: robots_txt, url\n# 1. Parse robots_txt line by line.\n# 2. Identify sections where User-agent is \"Googlebot\" or \"*\".\n# 3. For each Disallow rule in those sections, resolve the path.\n# 4. If the URL path starts with any Disallow path, set blocked = true.\n# 5. If blocked is true, result = fail else result = pass.\n"
    },
    "pass_condition": "No Disallow rule for Googlebot (or *) matches the page URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Robots.txt disallows Googlebot from accessing ${url}"],
    "references": [
      {
        "doc_title": "Google Search technical requirements",
        "url": "https://developers.google.com/search/docs/advanced/crawling/overview",
        "section_title": "Googlebot isn't blocked (it can find and access the page)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "accessibility"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt does not contain a Disallow rule that matches the page.",
        "snippet": "User-agent: *\nDisallow: /private/\n"
      },
      "failing": {
        "description": "robots.txt contains a Disallow rule that matches the page path.",
        "snippet": "User-agent: Googlebot\nDisallow: /restricted-page.html\n"
      }
    },
    "test_cases": [
      {
        "name": "Allowed by robots.txt",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /private/",
          "url": "https://example.com/public/page.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Blocked by robots.txt",
        "input_stub": {
          "robots_txt": "User-agent: Googlebot\nDisallow: /public/page.html",
          "url": "https://example.com/public/page.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGE_HTTP_200_STATUS",
    "title": "Page returns HTTP 200 status",
    "category": "The page works (it's not an error page)",
    "requirement": "UNSPECIFIED",
    "severity": "critical",
    "scope": "page",
    "rationale": "Google indexes only pages that respond with a successful 200 HTTP status code.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers including the status code"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "Numeric HTTP status code returned by the server"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: http_headers\n# 1. Extract status_code from http_headers.\n# 2. If status_code == 200, result = pass else result = fail.\n"
    },
    "pass_condition": "HTTP status code equals 200.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 200,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Page returned HTTP status ${observed} instead of 200"],
    "references": [
      {
        "doc_title": "Google Search technical requirements",
        "url": "https://developers.google.com/search/docs/advanced/crawling/overview",
        "section_title": "The page works (it's not an error page)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["http", "status"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Server responded with 200 OK.",
        "snippet": "HTTP/1.1 200 OK\nContent-Type: text/html\n"
      },
      "failing": {
        "description": "Server responded with a 404 Not Found.",
        "snippet": "HTTP/1.1 404 Not Found\nContent-Type: text/html\n"
      }
    },
    "test_cases": [
      {
        "name": "Successful response",
        "input_stub": {
          "http_headers": {
            "status_code": 200
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Error response",
        "input_stub": {
          "http_headers": {
            "status_code": 404
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGE_INDEXABLE_CONTENT",
    "title": "Page has indexable textual content",
    "category": "The page has indexable content",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google indexes pages that contain textual content in supported file types and that do not violate spam policies.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "(?s)<body.*?>(.*?)</body>",
        "attribute": null,
        "notes": "Capture body content for analysis"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract text inside <body> tags, removing script and style sections.\n# 2. Strip HTML tags to obtain plain text.\n# 3. If resulting text contains at least one alphanumeric character, result = pass.\n# 4. Otherwise, result = fail.\n"
    },
    "pass_condition": "Body contains at least one alphanumeric character after stripping markup.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Page lacks indexable textual content"],
    "references": [
      {
        "doc_title": "Google Search technical requirements",
        "url": "https://developers.google.com/search/docs/advanced/crawling/overview",
        "section_title": "The page has indexable content",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["content", "indexability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains visible text.",
        "snippet": "<html><body><p>Hello world!</p></body></html>\n"
      },
      "failing": {
        "description": "Page contains only script with no visible text.",
        "snippet": "<html><body><script>var a = 1;</script></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Textual content present",
        "input_stub": {
          "html": "<html><body><h1>Welcome</h1></body></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "No textual content",
        "input_stub": {
          "html": "<html><body><script>console.log('test');</script></body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CLOAKING_DETECTION",
    "title": "Detect cloaking by comparing content served to Googlebot vs regular users",
    "category": "Cloaking",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Cloaking presents different content to search engines and users to manipulate rankings and mislead users.",
    "input_fields": [
      {
        "name": "html_googlebot",
        "required": true,
        "description": "HTML source returned when the page is fetched with a Googlebot user\u2011agent."
      },
      {
        "name": "html_user",
        "required": true,
        "description": "HTML source returned when the page is fetched with a typical browser user\u2011agent."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "body",
        "attribute": null,
        "notes": "Extract visible text from the <body> element for both fetches."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html_googlebot, html_user\n# 1. Strip HTML tags and normalize whitespace from both inputs.\n# 2. Compute a similarity score (e.g., Jaccard index) between the two text sets.\n# 3. If similarity < 0.9 then flag as cloaking.\n"
    },
    "pass_condition": "The content served to Googlebot and to regular users is substantially identical (similarity \u2265 90%).",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 0.9,
      "unit": null,
      "notes": "Similarity score ranging from 0 to 1."
    },
    "fail_messages": [
      "Cloaking detected: similarity score ${observed} is below the required threshold of ${expected}."
    ],
    "references": [
      {
        "doc_title": "Spam policies for Google web search",
        "url": "https://developers.google.com/search/docs/advanced/guidelines/spam-policies",
        "section_title": "Cloaking",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["spam", "cloaking"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Identical content served to both agents.",
        "snippet": "html_googlebot == html_user \u2192 similarity 0.98 \u2192 pass\n"
      },
      "failing": {
        "description": "Different content served to Googlebot.",
        "snippet": "html_googlebot contains travel page, html_user contains drug page \u2192 similarity 0.45 \u2192 fail\n"
      }
    },
    "test_cases": [
      {
        "name": "Identical content",
        "input_stub": {
          "html_googlebot": "<html><body>Welcome to our travel guide.</body></html>",
          "html_user": "<html><body>Welcome to our travel guide.</body></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Different content",
        "input_stub": {
          "html_googlebot": "<html><body>Travel destinations list.</body></html>",
          "html_user": "<html><body>Buy cheap medication now.</body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HIDDEN_TEXT_DETECTION",
    "title": "Detect hidden text or links intended solely for search engines",
    "category": "Hidden text and link abuse",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Hidden text or links are used to manipulate rankings without providing value to users.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "*[style*='display:none'], *[style*='visibility:hidden'], *[style*='opacity:0'], *[style*='font-size:0'], *[style*='height:0'], *[style*='width:0'], *[style*='position:absolute'][style*='left:-9999px']",
        "attribute": null,
        "notes": "Elements styled to be invisible."
      },
      {
        "type": "selector",
        "selector": "a",
        "attribute": "rel",
        "notes": "Check if hidden links lack rel='nofollow' or 'sponsored' when required."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse HTML DOM.\n# 2. Find elements matching any of the hidden style selectors.\n# 3. If any such element contains text or an <a> tag, flag as hidden text/link abuse.\n"
    },
    "pass_condition": "No elements with hidden styles contain visible text or links.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Hidden text or link detected in element with selector '${selector}'."
    ],
    "references": [
      {
        "doc_title": "Spam policies for Google web search",
        "url": "https://developers.google.com/search/docs/advanced/guidelines/spam-policies",
        "section_title": "Hidden text and link abuse",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["spam", "hidden_text"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No hidden elements present.",
        "snippet": "No elements match hidden selectors \u2192 pass\n"
      },
      "failing": {
        "description": "Text hidden via CSS.",
        "snippet": "<div style=\"display:none\">Buy cheap meds</div> \u2192 fail\n"
      }
    },
    "test_cases": [
      {
        "name": "No hidden text",
        "input_stub": {
          "html": "<p>Welcome to our blog.</p>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Hidden text present",
        "input_stub": {
          "html": "<div style=\"display:none\">Secret keyword stuffing</div>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "KEYWORD_STUFFING_DETECTION",
    "title": "Detect excessive repetition of keywords indicative of keyword stuffing",
    "category": "Keyword stuffing",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Overusing keywords reduces content quality and is considered spam.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "body",
        "attribute": null,
        "notes": "Extract all visible text for analysis."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract visible text from <body>.\n# 2. Tokenize text into words, normalize case.\n# 3. Count occurrences of each distinct word.\n# 4. Compute density = count(word) / total_word_count.\n# 5. If any word density > 0.05 (5%) and the word is a target keyword, flag as keyword stuffing.\n"
    },
    "pass_condition": "No single keyword exceeds a density of 5% of total words.",
    "threshold": {
      "type": "number",
      "operator": "<=",
      "value": 0.05,
      "unit": null,
      "notes": "Maximum allowed keyword density."
    },
    "fail_messages": [
      "Keyword '${keyword}' density ${observed} exceeds allowed maximum of ${expected}."
    ],
    "references": [
      {
        "doc_title": "Spam policies for Google web search",
        "url": "https://developers.google.com/search/docs/advanced/guidelines/spam-policies",
        "section_title": "Keyword stuffing",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["spam", "keyword_stuffing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Keyword appears 3 times in 200-word article (1.5% density).",
        "snippet": "density 0.015 \u2264 0.05 \u2192 pass\n"
      },
      "failing": {
        "description": "Keyword appears 30 times in 200-word article (15% density).",
        "snippet": "density 0.15 > 0.05 \u2192 fail\n"
      }
    },
    "test_cases": [
      {
        "name": "Low density",
        "input_stub": {
          "html": "<body>Buy shoes online. Great shoes for everyone.</body>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "High density",
        "input_stub": {
          "html": "<body>Cheap meds cheap meds cheap meds cheap meds cheap meds cheap meds cheap meds cheap meds cheap meds cheap meds.</body>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SNEAKY_REDIRECT_DETECTION",
    "title": "Detect redirects that serve different content to users versus crawlers",
    "category": "Sneaky redirects",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Sneaky redirects deceive users or search engines by showing different destinations.",
    "input_fields": [
      {
        "name": "final_url_googlebot",
        "required": true,
        "description": "Final URL after following redirects when fetched with Googlebot user\u2011agent."
      },
      {
        "name": "final_url_user",
        "required": true,
        "description": "Final URL after following redirects when fetched with a regular browser user\u2011agent."
      },
      {
        "name": "http_status_googlebot",
        "required": true,
        "description": "HTTP status code of the final response for Googlebot."
      },
      {
        "name": "http_status_user",
        "required": true,
        "description": "HTTP status code of the final response for regular user."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "final_response",
        "attribute": null,
        "notes": "Capture status codes for both fetches."
      },
      {
        "type": "attribute",
        "selector": "final_url",
        "attribute": null,
        "notes": "Capture final landing URLs."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: final_url_googlebot, final_url_user, http_status_googlebot, http_status_user\n# 1. If http_status_googlebot != http_status_user, flag as sneaky.\n# 2. If final_url_googlebot != final_url_user, flag as sneaky.\n"
    },
    "pass_condition": "Both HTTP status codes and final URLs are identical for Googlebot and regular users.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Sneaky redirect detected: Googlebot ends at '${final_url_googlebot}' (status ${http_status_googlebot}) while user ends at '${final_url_user}' (status ${http_status_user})."
    ],
    "references": [
      {
        "doc_title": "Spam policies for Google web search",
        "url": "https://developers.google.com/search/docs/advanced/guidelines/spam-policies",
        "section_title": "Sneaky redirects",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["spam", "redirects"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both agents reach the same URL with 200 status.",
        "snippet": "final_url_googlebot == final_url_user == \"https://example.com/page\" \u2192 pass\n"
      },
      "failing": {
        "description": "Googlebot is redirected to a spam domain.",
        "snippet": "final_url_googlebot == \"https://spam.com\" \u2260 final_url_user == \"https://example.com/page\" \u2192 fail\n"
      }
    },
    "test_cases": [
      {
        "name": "Consistent redirect",
        "input_stub": {
          "final_url_googlebot": "https://example.com/home",
          "final_url_user": "https://example.com/home",
          "http_status_googlebot": 200,
          "http_status_user": 200
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Inconsistent redirect",
        "input_stub": {
          "final_url_googlebot": "https://spam.example.com",
          "final_url_user": "https://example.com/home",
          "http_status_googlebot": 302,
          "http_status_user": 200
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MALWARE_HOSTING_DETECTION",
    "title": "Detect presence of known malware signatures in downloadable files",
    "category": "Malware and malicious practices",
    "requirement": "UNSPECIFIED",
    "severity": "critical",
    "scope": "site",
    "rationale": "Hosting malware harms users and violates Google policies.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "URL of the resource to be inspected."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the resource."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "response",
        "attribute": null,
        "notes": "Ensure the request succeeded (200)."
      },
      {
        "type": "attribute",
        "selector": "content-type",
        "attribute": null,
        "notes": "Identify file type for scanning."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: url, http_headers\n# 1. Perform a GET request to the URL.\n# 2. If response status != 200, skip (not applicable).\n# 3. Compute SHA256 hash of the response body.\n# 4. Compare hash against a known-malware hash list.\n# 5. If hash matches, flag as malware hosting.\n"
    },
    "pass_condition": "The resource's hash does not match any known malware signatures.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Malware detected: resource at '${url}' matches known malicious hash ${observed}."
    ],
    "references": [
      {
        "doc_title": "Spam policies for Google web search",
        "url": "https://developers.google.com/search/docs/advanced/guidelines/spam-policies",
        "section_title": "Malware and malicious practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["malware", "security"],
    "insufficient_evidence": false,
    "notes": "Requires an up\u2011to\u2011date malware hash database.",
    "examples": {
      "passing": {
        "description": "File hash not in malware list.",
        "snippet": "hash = \"abc123...\" not in list \u2192 pass\n"
      },
      "failing": {
        "description": "File hash matches known malware.",
        "snippet": "hash = \"def456...\" found in list \u2192 fail\n"
      }
    },
    "test_cases": [
      {
        "name": "Clean file",
        "input_stub": {
          "url": "https://example.com/file.pdf",
          "http_headers": {
            "content-type": "application/pdf"
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Malicious file",
        "input_stub": {
          "url": "https://example.com/malware.exe",
          "http_headers": {
            "content-type": "application/octet-stream"
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TITLE_DESCRIPTIVE",
    "title": "Page title is descriptive, specific, and accurate",
    "category": "Content Optimization",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "The documentation advises ensuring title elements are descriptive, specific, and accurate to improve SEO.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "title",
        "attribute": null,
        "notes": "Extract title text"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html and locate the <title> element.\n# 2. Extract its text content and trim whitespace.\n# 3. Split the text into words (separated by whitespace).\n# 4. Count the number of words.\n# 5. Store count as observed_word_count.\n"
    },
    "pass_condition": "Title text contains at least two words.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 2,
      "unit": "words",
      "notes": null
    },
    "fail_messages": [
      "Title is missing or too short (${observed_word_count} words)."
    ],
    "references": [
      {
        "doc_title": "Improving SEO for specific queries",
        "url": "https://developers.google.com/search/docs/appearance/seo-starter-guide.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["title", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Title with multiple descriptive words",
        "snippet": "<title>How to Build a Wooden Shed - Gardening Tips</title>"
      },
      "failing": {
        "description": "Title that is too short",
        "snippet": "<title>Home</title>"
      }
    },
    "test_cases": [
      {
        "name": "Title passes",
        "input_stub": {
          "html": "<html><head><title>How to Build a Wooden Shed - Gardening Tips</title></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Title fails",
        "input_stub": {
          "html": "<html><head><title>Home</title></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "META_DESCRIPTION_PRESENT",
    "title": "Meta description tag is present and descriptive",
    "category": "Content Optimization",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Documentation suggests ensuring description meta tags are descriptive, specific, and accurate.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='description']",
        "attribute": "content",
        "notes": "Extract meta description content"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html and locate <meta name=\"description\"> element.\n# 2. If not found, set observed_present = false.\n# 3. If found, extract its content attribute, trim whitespace.\n# 4. Compute length of content in characters as observed_length.\n"
    },
    "pass_condition": "Meta description is present and its length is at least 50 characters.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 50,
      "unit": "characters",
      "notes": null
    },
    "fail_messages": [
      "Meta description missing or too short (${observed_length} characters)."
    ],
    "references": [
      {
        "doc_title": "Improving SEO for specific queries",
        "url": "https://developers.google.com/search/docs/appearance/seo-starter-guide.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["meta", "description", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Sufficient meta description",
        "snippet": "<meta name=\"description\" content=\"Learn how to build a wooden shed with step\u2011by\u2011step instructions and tips for beginners.\">"
      },
      "failing": {
        "description": "Missing or short meta description",
        "snippet": "<meta name=\"description\" content=\"Shed guide.\">"
      }
    },
    "test_cases": [
      {
        "name": "Meta description passes",
        "input_stub": {
          "html": "<html><head><meta name=\"description\" content=\"Learn how to build a wooden shed with step\u2011by\u2011step instructions and tips for beginners.\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Meta description fails",
        "input_stub": {
          "html": "<html><head><meta name=\"description\" content=\"Shed guide.\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMAGE_ALT_ATTRIBUTES",
    "title": "All images have descriptive alt attributes",
    "category": "Content Optimization",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Documentation advises alt attributes be descriptive, specific, and accurate.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "alt",
        "notes": "Collect alt attribute for each img element"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html and find all <img> elements.\n# 2. For each img, check if alt attribute exists and is non\u2011empty after trimming.\n# 3. If any img fails, record its index (starting at 1) as failing_index.\n"
    },
    "pass_condition": "Every <img> element has a non\u2011empty alt attribute.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Image at position ${failing_index} is missing a descriptive alt attribute."
    ],
    "references": [
      {
        "doc_title": "Improving SEO for specific queries",
        "url": "https://developers.google.com/search/docs/appearance/seo-starter-guide.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["images", "alt", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Images with alt text",
        "snippet": "<img src=\"shed.jpg\" alt=\"Wooden garden shed exterior\">"
      },
      "failing": {
        "description": "Image without alt text",
        "snippet": "<img src=\"shed.jpg\">"
      }
    },
    "test_cases": [
      {
        "name": "Images with alt pass",
        "input_stub": {
          "html": "<html><body><img src=\"a.jpg\" alt=\"A description\"><img src=\"b.jpg\" alt=\"B description\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Image missing alt fails",
        "input_stub": {
          "html": "<html><body><img src=\"a.jpg\"><img src=\"b.jpg\" alt=\"B description\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HEADING_HIERARCHY",
    "title": "Page uses heading elements to create hierarchical structure",
    "category": "Content Optimization",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Documentation recommends using heading elements to emphasize important text and create a hierarchical structure.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "h1",
        "attribute": null,
        "notes": "Check for presence of at least one H1 heading"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html and count the number of <h1> elements.\n# 2. Store count as h1_count.\n"
    },
    "pass_condition": "At least one <h1> element is present.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": "count",
      "notes": null
    },
    "fail_messages": ["No <h1> heading found on the page."],
    "references": [
      {
        "doc_title": "Improving SEO for specific queries",
        "url": "https://developers.google.com/search/docs/appearance/seo-starter-guide.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["headings", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with an H1 heading",
        "snippet": "<h1>How to Build a Wooden Shed</h1>"
      },
      "failing": {
        "description": "Page without an H1 heading",
        "snippet": "<h2>Introduction</h2>"
      }
    },
    "test_cases": [
      {
        "name": "H1 present passes",
        "input_stub": {
          "html": "<html><body><h1>Guide Title</h1><p>Content</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "H1 missing fails",
        "input_stub": {
          "html": "<html><body><h2>Subheading</h2><p>Content</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "GA_FILTER_SOURCE_MEDIUM",
    "title": "Verify Google Analytics data is filtered to source=google and medium=organic",
    "category": "Dashboard Setup",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "The documentation states that the Google Analytics data in the dashboard is already filtered to include only sessions where Session source = google and Session medium = organic.",
    "input_fields": [
      {
        "name": "dashboard_config",
        "required": true,
        "description": "JSON or text representation of the Looker Studio dashboard configuration"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "Session source\\s*=\\s*google",
        "attribute": null,
        "notes": "Detects filter condition for session source"
      },
      {
        "type": "regex",
        "selector": "Session medium\\s*=\\s*organic",
        "attribute": null,
        "notes": "Detects filter condition for session medium"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: dashboard_config (string)\n# Steps:\n1. Search dashboard_config for regex \"Session source\\s*=\\s*google\".\n2. Search dashboard_config for regex \"Session medium\\s*=\\s*organic\".\n3. If both patterns are found, result = pass; else result = fail.\n"
    },
    "pass_condition": "Both source=google and medium=organic filter conditions are present in the dashboard configuration.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing filter for Session source=google or Session medium=organic in dashboard configuration."
    ],
    "references": [
      {
        "doc_title": "Using Search Console and Google Analytics data for SEO",
        "url": "https://developers.google.com/search/docs/monitoring/using-search-console-analytics",
        "section_title": "Filters and data controls",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["dashboard", "filter", "google_analytics"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Dashboard config contains both required filter expressions.",
        "snippet": "{\n  \"filters\": [\n    {\"field\": \"Session source\", \"operator\": \"=\", \"value\": \"google\"},\n    {\"field\": \"Session medium\", \"operator\": \"=\", \"value\": \"organic\"}\n  ]\n}\n"
      },
      "failing": {
        "description": "Dashboard config missing one or both filter expressions.",
        "snippet": "{\n  \"filters\": [\n    {\"field\": \"Session source\", \"operator\": \"=\", \"value\": \"google\"}\n  ]\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Both filters present",
        "input_stub": {
          "dashboard_config": "{\"filters\":[{\"field\":\"Session source\",\"operator\":\"=\",\"value\":\"google\"},{\"field\":\"Session medium\",\"operator\":\"=\",\"value\":\"organic\"}]}\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing medium filter",
        "input_stub": {
          "dashboard_config": "{\"filters\":[{\"field\":\"Session source\",\"operator\":\"=\",\"value\":\"google\"}]}\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DASHBOARD_METRICS_PRESENT",
    "title": "Verify dashboard includes required five metrics",
    "category": "Dashboard Setup",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "The documentation lists five specific metrics (Sessions, Engagement rate, Returning users, Clicks, CTR) that the dashboard should display.",
    "input_fields": [
      {
        "name": "dashboard_config",
        "required": true,
        "description": "Textual representation of the Looker Studio dashboard configuration"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "Sessions",
        "attribute": null,
        "notes": "Metric name"
      },
      {
        "type": "regex",
        "selector": "Engagement rate",
        "attribute": null,
        "notes": "Metric name"
      },
      {
        "type": "regex",
        "selector": "Returning users",
        "attribute": null,
        "notes": "Metric name"
      },
      {
        "type": "regex",
        "selector": "Clicks",
        "attribute": null,
        "notes": "Metric name"
      },
      {
        "type": "regex",
        "selector": "CTR",
        "attribute": null,
        "notes": "Metric name"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: dashboard_config (string)\n# Steps:\n1. Define required_metrics = [\"Sessions\",\"Engagement rate\",\"Returning users\",\"Clicks\",\"CTR\"]\n2. For each metric in required_metrics:\n   a. Search dashboard_config for metric using case\u2011insensitive regex.\n   b. If not found, add metric to missing list.\n3. If missing list is empty, result = pass; else result = fail.\n"
    },
    "pass_condition": "All five required metrics are present in the dashboard configuration.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing required metric(s): ${missing}"],
    "references": [
      {
        "doc_title": "Using Search Console and Google Analytics data for SEO",
        "url": "https://developers.google.com/search/docs/monitoring/using-search-console-analytics",
        "section_title": "Metrics",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["dashboard", "metrics"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Dashboard config lists all five metrics.",
        "snippet": "{\"metrics\":[\"Sessions\",\"Engagement rate\",\"Returning users\",\"Clicks\",\"CTR\"]}\n"
      },
      "failing": {
        "description": "Dashboard config missing one or more metrics.",
        "snippet": "{\"metrics\":[\"Sessions\",\"Clicks\",\"CTR\"]}\n"
      }
    },
    "test_cases": [
      {
        "name": "All metrics present",
        "input_stub": {
          "dashboard_config": "{\"metrics\":[\"Sessions\",\"Engagement rate\",\"Returning users\",\"Clicks\",\"CTR\"]}\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing metrics",
        "input_stub": {
          "dashboard_config": "{\"metrics\":[\"Sessions\",\"Clicks\",\"CTR\"]}\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DASHBOARD_DATA_SOURCES_CONNECTED",
    "title": "Verify dashboard connects to both Search Console and Google Analytics data sources",
    "category": "Dashboard Setup",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "The setup instructions require connecting the dashboard to Search Console (URL Impression table) and Google Analytics.",
    "input_fields": [
      {
        "name": "dashboard_config",
        "required": true,
        "description": "Configuration details of the Looker Studio dashboard indicating connected data sources"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "Search Console",
        "attribute": null,
        "notes": "Indicates connection to Search Console"
      },
      {
        "type": "regex",
        "selector": "Google Analytics",
        "attribute": null,
        "notes": "Indicates connection to Google Analytics"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: dashboard_config (string)\n# Steps:\n1. Search dashboard_config for \"Search Console\" (case\u2011insensitive).\n2. Search dashboard_config for \"Google Analytics\" (case\u2011insensitive).\n3. If both found, result = pass; else result = fail.\n"
    },
    "pass_condition": "Both Search Console and Google Analytics data sources are referenced in the dashboard configuration.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Dashboard is missing connection to ${missing_source}."],
    "references": [
      {
        "doc_title": "Using Search Console and Google Analytics data for SEO",
        "url": "https://developers.google.com/search/docs/monitoring/using-search-console-analytics",
        "section_title": "Set up the dashboard",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["dashboard", "data_source"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Dashboard config includes both data source identifiers.",
        "snippet": "{\"dataSources\":[\"Search Console\",\"Google Analytics\"]}\n"
      },
      "failing": {
        "description": "Dashboard config includes only one data source.",
        "snippet": "{\"dataSources\":[\"Search Console\"]}\n"
      }
    },
    "test_cases": [
      {
        "name": "Both sources connected",
        "input_stub": {
          "dashboard_config": "{\"dataSources\":[\"Search Console\",\"Google Analytics\"]}\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing Google Analytics source",
        "input_stub": {
          "dashboard_config": "{\"dataSources\":[\"Search Console\"]}\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HEAD_SECTION_VALID_HTML",
    "title": "Head Section Must Be Valid HTML",
    "category": "Other points to note",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The documentation states the head section must be valid HTML to ensure machine readability by Google.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head",
        "attribute": null,
        "notes": "Select the <head> element to verify its presence."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html (string)\n# Steps:\n1. Parse the html string with an HTML parser that reports well\u2011formedness.\n2. If the parser reports any syntax errors, set parse_error = true else parse_error = false.\n3. Use a CSS selector \"head\" to locate the <head> element.\n4. If exactly one <head> element is found and parse_error is false, result = pass else result = fail.\n"
    },
    "pass_condition": "The page contains exactly one <head> element and the HTML parses without syntax errors.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing or invalid <head> section (found ${observed_head_count} <head> elements, parse errors: ${parse_error})."
    ],
    "references": [
      {
        "doc_title": "Meta Tags and Attributes that Google Supports",
        "url": "https://developers.google.com/search/docs/advanced/crawling/overview-meta-tags",
        "section_title": "Other points to note",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["html", "validation", "meta"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with a correctly formed <head> section.",
        "snippet": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Example</title>\n</head>\n<body></body>\n</html>\n"
      },
      "failing": {
        "description": "Page missing the <head> element or containing malformed HTML.",
        "snippet": "<!DOCTYPE html>\n<html>\n<title>Missing head</title>\n<body></body>\n</html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid head section",
        "input_stub": {
          "html": "<!DOCTYPE html><html><head><meta charset=\"utf-8\"><title>Test</title></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing head element",
        "input_stub": {
          "html": "<!DOCTYPE html><html><title>No head</title><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_PAGE_MUST_FOLLOW_SPEC",
    "title": "AMP page must follow AMP HTML specification",
    "category": "AMP Validation",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Ensures the page complies with the AMP HTML specification so it can be included in Google Search features.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Raw HTML of the AMP page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "amp_validation_errors",
        "attribute": null,
        "notes": "Number of validation errors reported by the official AMP validator."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Run the official AMP validator on the provided html.\n# 2. Capture the number of errors as amp_validation_errors.\n# 3. If amp_validation_errors == 0, the check passes; otherwise it fails.\n"
    },
    "pass_condition": "No validation errors reported by the AMP validator.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 0,
      "unit": null,
      "notes": "Zero errors indicates full compliance."
    },
    "fail_messages": [
      "AMP validation failed with ${observed} errors; expected 0 errors."
    ],
    "references": [
      {
        "doc_title": "Guidelines for AMP on Google Search",
        "url": "https://developers.google.com/search/amp/validate-amp.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["amp", "validation"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Valid AMP page with no errors.",
        "snippet": "<!doctype html><html amp><head><meta charset='utf-8'><script async src='https://cdn.ampproject.org/v0.js'></script></head><body>...</body></html>"
      },
      "failing": {
        "description": "AMP page missing required script tag, causing validation errors.",
        "snippet": "<!doctype html><html amp><head><meta charset='utf-8'></head><body>...</body></html>"
      }
    },
    "test_cases": [
      {
        "name": "valid_amp_page",
        "input_stub": {
          "html": "<!doctype html><html amp><head><meta charset='utf-8'><script async src='https://cdn.ampproject.org/v0.js'></script></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "invalid_amp_page_missing_script",
        "input_stub": {
          "html": "<!doctype html><html amp><head><meta charset='utf-8'></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BANNER_DATA_NOSNIPPET_PRESENT",
    "title": "Ensure banner or popup uses data-nosnippet attribute",
    "category": "Limit your site's functionality (recommended)",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Prevents banner or popup content from being shown in search result snippets.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to be evaluated."
      }
    ],
    "preconditions": [
      "Page contains a banner or popup element (e.g., element with class containing 'banner' or 'popup')."
    ],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "*[data-nosnippet]",
        "attribute": null,
        "notes": "Select any element that has the data-nosnippet attribute."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Search for any element that has a 'data-nosnippet' attribute.\n# 3. If at least one such element is found, result = pass.\n# 4. Otherwise, result = fail.\n"
    },
    "pass_condition": "At least one element with a data-nosnippet attribute is present on the page.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": null,
      "notes": "Count of elements with data-nosnippet must be >= 1."
    },
    "fail_messages": [
      "No element with data-nosnippet attribute found on the page."
    ],
    "references": [
      {
        "doc_title": "Temporarily pause or disable a website",
        "url": "https://developers.google.com/search/docs/monitor-site/temporarily-pause-or-disable-website",
        "section_title": "Display a banner or popup",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["banner", "data-nosnippet", "snippet-prevention"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Banner element includes data-nosnippet attribute.",
        "snippet": "<div class=\"banner\" data-nosnippet>We are temporarily closed.</div>"
      },
      "failing": {
        "description": "Banner element lacks data-nosnippet attribute.",
        "snippet": "<div class=\"banner\">We are temporarily closed.</div>"
      }
    },
    "test_cases": [
      {
        "name": "Banner with data-nosnippet",
        "input_stub": {
          "html": "<div class=\"banner\" data-nosnippet>Closed</div>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Banner without data-nosnippet",
        "input_stub": {
          "html": "<div class=\"banner\">Closed</div>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ROBOTS_TXT_NOT_503",
    "title": "robots.txt must not return HTTP 503 status",
    "category": "Best practices for disabling a site",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "site",
    "rationale": "A 503 response for robots.txt blocks all crawling, preventing indexing.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the robots.txt file (if fetched successfully)."
      },
      {
        "name": "http_status",
        "required": true,
        "description": "HTTP status code returned when fetching robots.txt."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "robots_txt",
        "attribute": null,
        "notes": "HTTP status code of the robots.txt request."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_status (status code for robots.txt)\n# 1. If http_status == 503 then result = fail.\n# 2. Otherwise result = pass.\n"
    },
    "pass_condition": "robots.txt HTTP status code is not 503.",
    "threshold": {
      "type": "number",
      "operator": "!=",
      "value": 503,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "robots.txt returned a 503 Service Unavailable status, which blocks crawling."
    ],
    "references": [
      {
        "doc_title": "Temporarily pause or disable a website",
        "url": "https://developers.google.com/search/docs/monitor-site/temporarily-pause-or-disable-website",
        "section_title": "Best practices for disabling a site",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots.txt", "crawling", "http-status"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt fetched successfully with 200 status.",
        "snippet": "User-agent: *\nAllow: /"
      },
      "failing": {
        "description": "robots.txt request returns 503.",
        "snippet": null
      }
    },
    "test_cases": [
      {
        "name": "robots.txt 200 OK",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nAllow: /",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "robots.txt 503 Service Unavailable",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RETRY_AFTER_HEADER_PRESENT_ON_503",
    "title": "503 error pages must include a Retry-After header",
    "category": "Best practices for disabling a site",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Provides crawlers with guidance on when to retry, reducing unnecessary load.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the requested URL."
      },
      {
        "name": "http_status",
        "required": true,
        "description": "HTTP status code of the response."
      }
    ],
    "preconditions": ["http_status == 503"],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "Retry-After",
        "attribute": null,
        "notes": "Value of the Retry-After response header."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_status, http_headers\n# 1. If http_status != 503, result = not_applicable.\n# 2. If http_status == 503:\n#    a. Check if 'Retry-After' header exists and is non-empty.\n#    b. If present, result = pass; else result = fail.\n"
    },
    "pass_condition": "When a response has status 503, a non-empty Retry-After header is present.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": "Presence of Retry-After header."
    },
    "fail_messages": ["503 response missing Retry-After header."],
    "references": [
      {
        "doc_title": "Temporarily pause or disable a website",
        "url": "https://developers.google.com/search/docs/monitor-site/temporarily-pause-or-disable-website",
        "section_title": "Best practices for disabling a site",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["http-503", "retry-after", "crawl-rate"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "503 response includes Retry-After header.",
        "snippet": "HTTP/1.1 503 Service Unavailable\nRetry-After: Wed, 21 Oct 2026 07:28:00 GMT"
      },
      "failing": {
        "description": "503 response without Retry-After header.",
        "snippet": "HTTP/1.1 503 Service Unavailable"
      }
    },
    "test_cases": [
      {
        "name": "503 with Retry-After",
        "input_stub": {
          "html": null,
          "http_headers": {
            "Retry-After": "Wed, 21 Oct 2026 07:28:00 GMT"
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null,
          "http_status": 503
        },
        "expected_outcome": "pass"
      },
      {
        "name": "503 without Retry-After",
        "input_stub": {
          "html": null,
          "http_headers": {},
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null,
          "http_status": 503
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NO_URL_FRAGMENTS",
    "title": "Avoid URL fragments that change content",
    "category": "Requirements for a crawlable URL structure",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Google Search may not crawl URLs where fragments are used to change content, leading to inefficient crawling.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to extract href attributes."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "a[href]",
        "attribute": "href",
        "notes": "Collect each link's href value."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and collect all href attributes from <a> tags.\n# 2. For each href, if it contains a '#' character:\n#    a. Extract the fragment part after '#'.\n#    b. If fragment is non\u2011empty, record as violation.\n# 3. If any violations recorded, result = fail else pass.\n"
    },
    "pass_condition": "No href attribute contains a non\u2011empty fragment identifier.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Link with fragment found: ${observed}"],
    "references": [
      {
        "doc_title": "URL structure best practices for Google Search",
        "url": "https://developers.google.com/search/docs/advanced/crawling/url-structure",
        "section_title": "Requirements for a crawlable URL structure",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["url", "crawlability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with links that have no fragments.",
        "snippet": "<a href=\"https://example.com/page\">Link</a>"
      },
      "failing": {
        "description": "Page with a link that uses a fragment to change content.",
        "snippet": "<a href=\"https://example.com/page#section1\">Link</a>"
      }
    },
    "test_cases": [
      {
        "name": "No fragments",
        "input_stub": {
          "html": "<html><body><a href=\"https://example.com/page\"></a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fragment present",
        "input_stub": {
          "html": "<html><body><a href=\"https://example.com/page#intro\"></a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HYPHENS_IN_PATH",
    "title": "Use hyphens to separate words in URL path",
    "category": "Best practices",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Hyphens improve readability for users and search engines, aiding crawlability and ranking.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to extract href attributes."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "a[href]",
        "attribute": "href",
        "notes": "Collect each link's href value."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and collect all href attributes from <a> tags.\n# 2. For each href:\n#    a. Extract the path component (portion after domain, before '?' or '#').\n#    b. If the path contains an underscore '_' character, record as violation.\n# 3. If any violations recorded, result = fail else pass.\n"
    },
    "pass_condition": "URL paths do not contain underscore characters.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["URL path contains underscore: ${observed}"],
    "references": [
      {
        "doc_title": "URL structure best practices for Google Search",
        "url": "https://developers.google.com/search/docs/advanced/crawling/url-structure",
        "section_title": "Best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["url", "readability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL uses hyphens between words.",
        "snippet": "<a href=\"https://example.com/summer-clothing/filter?color-profile=dark-grey\">Link</a>"
      },
      "failing": {
        "description": "URL uses underscores between words.",
        "snippet": "<a href=\"https://example.com/summer_clothing/filter?color_profile=dark_grey\">Link</a>"
      }
    },
    "test_cases": [
      {
        "name": "Hyphens only",
        "input_stub": {
          "html": "<html><body><a href=\"https://example.com/summer-clothing\"></a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Underscore present",
        "input_stub": {
          "html": "<html><body><a href=\"https://example.com/summer_clothing\"></a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PERCENT_ENCODING_NECESSARY",
    "title": "Percent\u2011encode non\u2011ASCII characters in URLs",
    "category": "Best practices",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Percent\u2011encoding ensures URLs are valid, crawlable, and correctly interpreted by search engines.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to extract href attributes."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "a[href]",
        "attribute": "href",
        "notes": "Collect each link's href value."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and collect all href attributes from <a> tags.\n# 2. For each href:\n#    a. Decode percent\u2011encoded sequences.\n#    b. If any character in the decoded URL has a code point > 127 (non\u2011ASCII) and is not percent\u2011encoded, record as violation.\n# 3. If any violations recorded, result = fail else pass.\n"
    },
    "pass_condition": "All URLs contain only ASCII characters or properly percent\u2011encoded sequences.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "URL contains unencoded non\u2011ASCII characters: ${observed}"
    ],
    "references": [
      {
        "doc_title": "URL structure best practices for Google Search",
        "url": "https://developers.google.com/search/docs/advanced/crawling/url-structure",
        "section_title": "Best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["url", "encoding"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL with percent\u2011encoded Unicode characters.",
        "snippet": "<a href=\"https://example.com/%E6%9D%82%E8%B4%A7/%E8%96%84%E8%8D%B7\">Link</a>"
      },
      "failing": {
        "description": "URL contains raw Unicode characters.",
        "snippet": "<a href=\"https://example.com/\u6742\u8d27/\u852c\u83dc\">Link</a>"
      }
    },
    "test_cases": [
      {
        "name": "Properly encoded",
        "input_stub": {
          "html": "<html><body><a href=\"https://example.com/%E6%9D%82%E8%B4%A7\"></a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Raw Unicode",
        "input_stub": {
          "html": "<html><body><a href=\"https://example.com/\u6742\u8d27\"></a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_REL_CANONICAL_PRESENT",
    "title": "Presence of rel=\"canonical\" link element",
    "category": "Canonicalization",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "rel=\"canonical\" link annotations are listed as a factor that influences how Google determines the canonical URL.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='canonical']",
        "attribute": "href",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse the HTML document.\n# 2. Search for a <link> element with rel attribute equal to \"canonical\".\n# 3. If such an element exists, capture its href attribute as observed_canonical.\n# 4. If no element is found, observed_canonical = null.\n"
    },
    "pass_condition": "The page contains a <link rel=\"canonical\"> element with a non\u2011empty href attribute.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing rel=\"canonical\" link element on the page."],
    "references": [
      {
        "doc_title": "What is URL Canonicalization",
        "url": "https://developers.google.com/search/docs/advanced/crawling/consolidate-duplicate-urls",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "link"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a proper canonical link.",
        "snippet": "<head><link rel=\"canonical\" href=\"https://example.com/page\"></head>"
      },
      "failing": {
        "description": "Page lacks a canonical link.",
        "snippet": "<head></head>"
      }
    },
    "test_cases": [
      {
        "name": "Page with canonical link",
        "input_stub": {
          "html": "<html><head><link rel=\"canonical\" href=\"https://example.com/page\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Page without canonical link",
        "input_stub": {
          "html": "<html><head></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_URL_IN_SITEMAP",
    "title": "URL presence in sitemap.xml",
    "category": "Canonicalization",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "site",
    "rationale": "Presence of the URL in a sitemap is mentioned as a factor influencing canonical selection.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the site's sitemap."
      },
      {
        "name": "url",
        "required": true,
        "description": "The absolute URL of the page being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url/loc[text() = '${url}']",
        "attribute": null,
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: sitemap_xml, url\n# 1. Parse sitemap_xml as XML.\n# 2. Search for any <loc> element whose text equals the given url.\n# 3. If found, set found = true; else found = false.\n"
    },
    "pass_condition": "The URL is listed in the sitemap.xml file.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["URL ${url} not found in sitemap.xml."],
    "references": [
      {
        "doc_title": "What is URL Canonicalization",
        "url": "https://developers.google.com/search/docs/advanced/crawling/consolidate-duplicate-urls",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["sitemap", "canonical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL appears in the sitemap.",
        "snippet": "<urlset><url><loc>https://example.com/page</loc></url></urlset>"
      },
      "failing": {
        "description": "URL missing from sitemap.",
        "snippet": "<urlset></urlset>"
      }
    },
    "test_cases": [
      {
        "name": "URL present in sitemap",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": "<urlset><url><loc>https://example.com/page</loc></url></urlset>",
          "url": "https://example.com/page"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "URL absent from sitemap",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": "<urlset></urlset>",
          "url": "https://example.com/page"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_HTTP_HTTPS_CONSISTENCY",
    "title": "Consistent use of HTTPS scheme",
    "category": "Canonicalization",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "The documentation lists the page\u2019s protocol (HTTP vs HTTPS) as a factor that influences canonicalization.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "The absolute URL of the page being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "^(https?)://",
        "attribute": null,
        "notes": "Captures the scheme part of the URL."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: url\n# 1. Extract the scheme (http or https) from the URL using a regex.\n# 2. If scheme == \"https\", set consistent = true; else consistent = false.\n"
    },
    "pass_condition": "The page is served over HTTPS.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Page URL ${url} is not served over HTTPS."],
    "references": [
      {
        "doc_title": "What is URL Canonicalization",
        "url": "https://developers.google.com/search/docs/advanced/crawling/consolidate-duplicate-urls",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["protocol", "canonical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL uses HTTPS.",
        "snippet": "https://example.com/page"
      },
      "failing": {
        "description": "URL uses HTTP.",
        "snippet": "http://example.com/page"
      }
    },
    "test_cases": [
      {
        "name": "HTTPS URL",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/page"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "HTTP URL",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "http://example.com/page"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DATA_NOSNIPPET_VALID_HTML",
    "title": "Ensure HTML containing data-nosnippet attribute is well\u2011formed",
    "category": "Using the `data-nosnippet` HTML attribute",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The documentation states that the HTML section must be valid HTML for data\u2011nosnippet to be machine\u2011readable.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML content of the page"
      }
    ],
    "preconditions": [
      "HTML contains an element with the attribute data-nosnippet"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "[data-nosnippet]",
        "attribute": null,
        "notes": "Collect all elements that declare data-nosnippet"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the html using an HTML validator.\n# 2. If the parser reports any well\u2011formedness errors, set observed = error details.\n# 3. If errors exist, result = fail; else result = pass.\n"
    },
    "pass_condition": "HTML parses without any well\u2011formedness errors.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["HTML parsing error detected: ${observed}"],
    "references": [
      {
        "doc_title": "Robots meta tag, data\u2011nosnippet, and X\u2011Robots\u2011Tag specifications",
        "url": "https://developers.google.com/search/docs/advanced/robots/robots_meta_tag",
        "section_title": "Using the `data-nosnippet` HTML attribute",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["data-nosnippet", "html-validation"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Valid HTML with a correctly closed data\u2011nosnippet element.",
        "snippet": "<html>\n  <head><title>Example</title></head>\n  <body>\n    <p>Snippet text <span data-nosnippet>hidden part</span>.</p>\n  </body>\n</html>\n"
      },
      "failing": {
        "description": "HTML where a data\u2011nosnippet element is inside an unclosed tag, causing parsing errors.",
        "snippet": "<html>\n  <head><title>Bad Example</title></head>\n  <body>\n    <div data-nosnippet>\n      <p>Unclosed div will cause the rest of the page to be treated as part of the element.\n</html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid data-nosnippet usage",
        "input_stub": {
          "html": "<html><head></head><body><span data-nosnippet>hide</span></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Invalid HTML with data-nosnippet",
        "input_stub": {
          "html": "<html><head></head><body><div data-nosnippet><p>Missing closing div",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ROBOTS_TXT_ALLOW_INDEXING_RULES",
    "title": "URLs containing robots meta or X\u2011Robots\u2011Tag must not be disallowed by robots.txt",
    "category": "Combining robots.txt rules with indexing and serving rules",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "site",
    "rationale": "Documentation requires that if indexing or serving rules must be followed, the URLs containing those rules cannot be disallowed from crawling via robots.txt.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file"
      },
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the page being evaluated"
      },
      {
        "name": "html",
        "required": false,
        "description": "HTML content of the page (to detect meta robots tags)"
      },
      {
        "name": "http_headers",
        "required": false,
        "description": "HTTP response headers (to detect X\u2011Robots\u2011Tag)"
      }
    ],
    "preconditions": [
      "Page contains a robots meta tag (e.g., <meta name=\"robots\" ...>) OR an X\u2011Robots\u2011Tag header"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name~='robots|googlebot|googlebot-news']",
        "attribute": "content",
        "notes": "Collect content of any robots meta tags"
      },
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": "Collect X\u2011Robots\u2011Tag header values"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: robots_txt, url, html, http_headers\n# 1. Determine if html contains a <meta name=\"robots\"...> or similar tag.\n# 2. Determine if http_headers contain an X-Robots-Tag header.\n# 3. If neither is present, result = not_applicable.\n# 4. Parse robots_txt to extract all Disallow paths (ignore comments, blank lines).\n# 5. Extract the path component of url.\n# 6. If any Disallow path matches the url path (exact prefix match), then result = fail.\n# 7. Otherwise, result = pass.\n"
    },
    "pass_condition": "No Disallow rule in robots.txt matches the URL path when the page includes robots meta or X\u2011Robots\u2011Tag.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "URL ${url} is disallowed by robots.txt while containing indexing/serving rules."
    ],
    "references": [
      {
        "doc_title": "Robots meta tag, data\u2011nosnippet, and X\u2011Robots\u2011Tag specifications",
        "url": "https://developers.google.com/search/docs/advanced/robots/robots_meta_tag",
        "section_title": "Combining robots.txt rules with indexing and serving rules",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots.txt", "indexing-rules"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with robots meta tag and robots.txt that allows crawling.",
        "snippet": "robots.txt:\nUser-agent: *\nDisallow: /private/\n\nPage URL: https://example.com/public/page.html\n<meta name=\"robots\" content=\"noindex\">\n"
      },
      "failing": {
        "description": "Page with X\u2011Robots\u2011Tag header but robots.txt disallows the path.",
        "snippet": "robots.txt:\nUser-agent: *\nDisallow: /secret/\n\nPage URL: https://example.com/secret/report.pdf\nHTTP header: X-Robots-Tag: noindex\n"
      }
    },
    "test_cases": [
      {
        "name": "Allowed URL with robots meta",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /private/",
          "url": "https://example.com/public/page.html",
          "html": "<meta name=\"robots\" content=\"noindex\">",
          "http_headers": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Disallowed URL with X-Robots-Tag",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /secret/",
          "url": "https://example.com/secret/report.pdf",
          "html": null,
          "http_headers": {
            "X-Robots-Tag": "noindex"
          },
          "lighthouse_metrics": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NO_CLOAKING_DETECTED",
    "title": "Ensure no cloaking between Googlebot and users",
    "category": "Don't cloak your test pages",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Cloaking violates spam policies and can cause demotion or removal from Google Search results.",
    "input_fields": [
      {
        "name": "html_googlebot",
        "required": true,
        "description": "Full HTML content returned when the page is fetched with a Googlebot user\u2011agent."
      },
      {
        "name": "html_user",
        "required": true,
        "description": "Full HTML content returned when the page is fetched with a typical browser user\u2011agent."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "html",
        "attribute": null,
        "notes": "Capture the entire HTML document for each user\u2011agent to compute a content hash."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html_googlebot, html_user\n# 1. Compute hash_g = hash(html_googlebot)\n# 2. Compute hash_u = hash(html_user)\n# 3. If hash_g == hash_u then result = PASS else result = FAIL\n"
    },
    "pass_condition": "The HTML content served to Googlebot and to regular users is identical.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Cloaking detected: content hash for Googlebot (${hash_g}) differs from user view (${hash_u})."
    ],
    "references": [
      {
        "doc_title": "A/B Testing Best Practices for Search",
        "url": "https://developers.google.com/search/docs/ab-testing",
        "section_title": "Don't cloak your test pages",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["cloaking", "spam_policy"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both fetches return identical HTML.",
        "snippet": "html_googlebot = \"<html><body>Content</body></html>\"\nhtml_user = \"<html><body>Content</body></html>\"\n"
      },
      "failing": {
        "description": "Googlebot receives stripped content while users see full page.",
        "snippet": "html_googlebot = \"<html><body></body></html>\"\nhtml_user = \"<html><body>Full Content</body></html>\"\n"
      }
    },
    "test_cases": [
      {
        "name": "Identical content",
        "input_stub": {
          "html_googlebot": "<html><body>Same</body></html>",
          "html_user": "<html><body>Same</body></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Different content",
        "input_stub": {
          "html_googlebot": "<html><body></body></html>",
          "html_user": "<html><body>Visible</body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REL_CANONICAL_PRESENT",
    "title": "Use rel=\"canonical\" on test variant URLs",
    "category": "Use rel=\"canonical\" links",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "rel=canonical signals the preferred URL, preventing duplicate indexing of test variants.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"canonical\"]",
        "attribute": "href",
        "notes": "Extract the href attribute of the canonical link element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse HTML and locate <link rel=\"canonical\"> element.\n# 2. If element exists and href attribute is non\u2011empty, result = PASS.\n# 3. Otherwise, result = FAIL.\n"
    },
    "pass_condition": "A <link rel=\"canonical\"> element with a non\u2011empty href is present in the HTML.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing or empty rel=canonical link on test variant page."
    ],
    "references": [
      {
        "doc_title": "A/B Testing Best Practices for Search",
        "url": "https://developers.google.com/search/docs/ab-testing",
        "section_title": "Use rel=\"canonical\" links",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "duplicate_content"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a proper canonical link.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/original-page\">\n"
      },
      "failing": {
        "description": "No canonical link present.",
        "snippet": "<!-- missing rel=canonical -->\n"
      }
    },
    "test_cases": [
      {
        "name": "Canonical present",
        "input_stub": {
          "html": "<html><head><link rel=\"canonical\" href=\"https://example.com/home\"></head></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Canonical missing",
        "input_stub": {
          "html": "<html><head></head></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TEMPORARY_REDIRECT_302",
    "title": "Use 302 redirects for temporary test redirects",
    "category": "Use 302 redirects, not 301 redirects",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "A 302 redirect signals a temporary change, ensuring the original URL remains indexed.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers of the URL that performs the redirect."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "status_code",
        "attribute": null,
        "notes": "Capture the HTTP status code returned for the redirect request."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Retrieve status = http_headers[\"status_code\"]\n# 2. If status == 302 then result = PASS\n# 3. Else result = FAIL\n"
    },
    "pass_condition": "The HTTP status code for the redirect response is 302.",
    "threshold": {
      "type": "string",
      "operator": "==",
      "value": "302",
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Redirect uses status code ${observed} instead of required 302."
    ],
    "references": [
      {
        "doc_title": "A/B Testing Best Practices for Search",
        "url": "https://developers.google.com/search/docs/ab-testing",
        "section_title": "Use 302 redirects, not 301 redirects",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["redirect", "temporary_redirect"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Server returns a 302 temporary redirect.",
        "snippet": "HTTP/1.1 302 Found\nLocation: https://example.com/variant\n"
      },
      "failing": {
        "description": "Server returns a 301 permanent redirect.",
        "snippet": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/variant\n"
      }
    },
    "test_cases": [
      {
        "name": "302 redirect",
        "input_stub": {
          "http_headers": {
            "status_code": "302"
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "301 redirect",
        "input_stub": {
          "http_headers": {
            "status_code": "301"
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_LINK_IN_HEAD",
    "title": "rel=\"canonical\" link element must be placed in <head>",
    "category": "Use rel=\"canonical\" link annotations",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "The documentation states that the rel=\"canonical\" link element is only accepted if it appears in the <head> section of the HTML.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head > link[rel='canonical']",
        "attribute": "href",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html into DOM.\n# 2. Search for <link> elements with rel='canonical' inside the <head>.\n# 3. If at least one such element exists, set found = true else false.\n# 4. Return found.\n"
    },
    "pass_condition": "At least one rel=\"canonical\" link element is found inside the <head>.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No rel='canonical' link element found in the <head> section."
    ],
    "references": [
      {
        "doc_title": "How to specify a canonical URL with rel=\\\"canonical\\\" and other methods",
        "url": "https://developers.google.com/search/docs/advanced/canonical/rel-canonical",
        "section_title": "Use rel=\\\"canonical\\\" link annotations",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "html"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Correct placement of canonical link in head.",
        "snippet": "<html>\n<head>\n  <link rel=\"canonical\" href=\"https://example.com/page.html\">\n</head>\n<body>...</body>\n</html>\n"
      },
      "failing": {
        "description": "Canonical link placed outside head.",
        "snippet": "<html>\n<body>\n  <link rel=\"canonical\" href=\"https://example.com/page.html\">\n</body>\n</html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Canonical link in head",
        "input_stub": {
          "html": "<html><head><link rel='canonical' href='https://example.com/page.html'></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Canonical link outside head",
        "input_stub": {
          "html": "<html><body><link rel='canonical' href='https://example.com/page.html'></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_LINK_ABSOLUTE_URL",
    "title": "rel=\"canonical\" link element must use an absolute URL",
    "category": "Use rel=\"canonical\" link annotations",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Documentation recommends using absolute URLs for rel=\"canonical\" link elements to avoid problems.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head > link[rel='canonical']",
        "attribute": "href",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html into DOM.\n# 2. Locate <link rel='canonical'> inside <head>.\n# 3. If element not found, result = not_applicable.\n# 4. Extract href attribute.\n# 5. If href matches regex ^https?://, result = pass else fail.\n"
    },
    "pass_condition": "The href attribute of the rel=\"canonical\" link starts with \"http://\" or \"https://\".",
    "threshold": {
      "type": "regex",
      "operator": "matches",
      "value": "^https?://",
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Canonical link href '${observed}' is not an absolute URL."
    ],
    "references": [
      {
        "doc_title": "How to specify a canonical URL with rel=\\\"canonical\\\" and other methods",
        "url": "https://developers.google.com/search/docs/advanced/canonical/rel-canonical",
        "section_title": "Use rel=\\\"canonical\\\" link annotations",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "url"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Absolute URL in canonical link.",
        "snippet": "<head>\n  <link rel=\"canonical\" href=\"https://example.com/page.html\">\n</head>\n"
      },
      "failing": {
        "description": "Relative URL in canonical link.",
        "snippet": "<head>\n  <link rel=\"canonical\" href=\"/page.html\">\n</head>\n"
      }
    },
    "test_cases": [
      {
        "name": "Absolute URL",
        "input_stub": {
          "html": "<head><link rel='canonical' href='https://example.com/page.html'></head>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Relative URL",
        "input_stub": {
          "html": "<head><link rel='canonical' href='/page.html'></head>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_HEADER_ABSOLUTE_URL",
    "title": "rel=\"canonical\" HTTP header must use an absolute URL",
    "category": "Use rel=\"canonical\" link annotations",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Documentation states that absolute URLs must be used in the rel=\"canonical\" HTTP header.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "Dictionary of response headers."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "Link",
        "attribute": null,
        "notes": "Parse for rel=\"canonical\""
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Retrieve all 'Link' header values.\n# 2. For each value, split by commas and parse parameters.\n# 3. If a segment has rel=\"canonical\", extract the URL inside <>.\n# 4. If URL matches ^https?://, pass; else fail.\n"
    },
    "pass_condition": "The URL associated with rel=\"canonical\" in the Link header is absolute.",
    "threshold": {
      "type": "regex",
      "operator": "matches",
      "value": "^https?://",
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Canonical Link header URL '${observed}' is not absolute."
    ],
    "references": [
      {
        "doc_title": "How to specify a canonical URL with rel=\\\"canonical\\\" and other methods",
        "url": "https://developers.google.com/search/docs/advanced/canonical/rel-canonical",
        "section_title": "Use rel=\\\"canonical\\\" link annotations",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "http"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Proper absolute URL in Link header.",
        "snippet": "Link: <https://example.com/page.html>; rel=\"canonical\"\n"
      },
      "failing": {
        "description": "Relative URL in Link header.",
        "snippet": "Link: </page.html>; rel=\"canonical\"\n"
      }
    },
    "test_cases": [
      {
        "name": "Absolute URL in header",
        "input_stub": {
          "html": null,
          "http_headers": {
            "Link": "<https://example.com/page.html>; rel=\"canonical\""
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Relative URL in header",
        "input_stub": {
          "html": null,
          "http_headers": {
            "Link": "</page.html>; rel=\"canonical\""
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AVOID_ROBOTS_TXT_FOR_CANONICAL",
    "title": "Do not use robots.txt for canonicalization",
    "category": "Best practices",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "site",
    "rationale": "Documentation explicitly advises against using robots.txt for canonicalization.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the robots.txt file."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "canonical",
        "attribute": null,
        "notes": "Search for any occurrence of the word 'canonical' in robots.txt."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: robots_txt\n# 1. Search the file for the case-insensitive word \"canonical\".\n# 2. If found, result = fail; else pass.\n"
    },
    "pass_condition": "robots.txt does not contain the term \"canonical\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "robots.txt contains canonical directives which are not supported for canonicalization."
    ],
    "references": [
      {
        "doc_title": "How to specify a canonical URL with rel=\\\"canonical\\\" and other methods",
        "url": "https://developers.google.com/search/docs/advanced/canonical/rel-canonical",
        "section_title": "Best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots.txt", "canonical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt without canonical references.",
        "snippet": "User-agent: *\nDisallow:\n"
      },
      "failing": {
        "description": "robots.txt containing a canonical directive.",
        "snippet": "User-agent: *\nDisallow: /private/\n# canonical: https://example.com/page.html\n"
      }
    },
    "test_cases": [
      {
        "name": "No canonical in robots.txt",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow:",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Canonical present in robots.txt",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow:\n# canonical: https://example.com/page.html",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CONSISTENT_CANONICAL_METHOD",
    "title": "Do not specify different canonical URLs for the same page using different methods",
    "category": "Best practices",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Documentation warns that specifying different canonical URLs via different techniques for the same page can cause conflicts.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "Response headers of the page."
      },
      {
        "name": "sitemap_xml",
        "required": false,
        "description": "Sitemap XML content (if page is listed)."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head > link[rel='canonical']",
        "attribute": "href",
        "notes": "HTML canonical URL"
      },
      {
        "type": "header",
        "selector": "Link",
        "attribute": null,
        "notes": "Parse for rel=\"canonical\""
      },
      {
        "type": "xpath",
        "selector": "//url/loc",
        "attribute": null,
        "notes": "If page URL appears in sitemap, treat as canonical candidate"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html, http_headers, sitemap_xml\n# 1. Extract canonical URL from HTML <link rel='canonical'> (html_canonical).\n# 2. Extract canonical URL from Link header with rel='canonical' (header_canonical).\n# 3. If sitemap_xml provided, locate <url><loc> matching the page URL (sitemap_canonical).\n# 4. Build list of all non-null canonical URLs.\n# 5. If list length <= 1, pass.\n# 6. If more than one distinct URL exists, fail.\n"
    },
    "pass_condition": "All discovered canonical URLs (HTML, header, sitemap) are identical or only one method is used.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Conflicting canonical URLs detected: ${observed_urls}."],
    "references": [
      {
        "doc_title": "How to specify a canonical URL with rel=\\\"canonical\\\" and other methods",
        "url": "https://developers.google.com/search/docs/advanced/canonical/rel-canonical",
        "section_title": "Best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "consistency"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Same canonical URL via HTML and header.",
        "snippet": "<!-- HTML -->\n<head><link rel=\"canonical\" href=\"https://example.com/page.html\"></head>\n<!-- HTTP Header -->\nLink: <https://example.com/page.html>; rel=\"canonical\"\n"
      },
      "failing": {
        "description": "Different canonical URLs in HTML and header.",
        "snippet": "<!-- HTML -->\n<head><link rel=\"canonical\" href=\"https://example.com/page.html\"></head>\n<!-- HTTP Header -->\nLink: <https://example.com/other.html>; rel=\"canonical\"\n"
      }
    },
    "test_cases": [
      {
        "name": "Consistent canonical",
        "input_stub": {
          "html": "<head><link rel='canonical' href='https://example.com/page.html'></head>",
          "http_headers": {
            "Link": "<https://example.com/page.html>; rel=\"canonical\""
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Inconsistent canonical",
        "input_stub": {
          "html": "<head><link rel='canonical' href='https://example.com/page.html'></head>",
          "http_headers": {
            "Link": "<https://example.com/other.html>; rel=\"canonical\""
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PHP_HEADERS_BEFORE_OUTPUT",
    "title": "Ensure HTTP redirect headers are sent before any body content in PHP redirects",
    "category": "Server-side redirects",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "The documentation states \"You must set the headers before sending anything to the screen\" for PHP redirects, requiring headers to precede any output.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers returned by the URL"
      },
      {
        "name": "response_body",
        "required": true,
        "description": "Raw response body content returned by the URL"
      }
    ],
    "preconditions": [
      "Response includes a 3xx status code (e.g., 301, 302, 303, 307, 308) indicating a redirect"
    ],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "Status",
        "attribute": null,
        "notes": "Redirect status code"
      },
      {
        "type": "header",
        "selector": "Location",
        "attribute": null,
        "notes": "Redirect target URL"
      },
      {
        "type": "metric",
        "selector": "body_length",
        "attribute": null,
        "notes": "Length of response body in bytes"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: http_headers, response_body\n# 1. Extract status_code from http_headers[\"Status\"]\n# 2. If status_code not in [301,302,303,307,308], skip (not applicable)\n# 3. Compute body_length = length_in_bytes(response_body)\n# 4. If body_length == 0, PASS\n# 5. Else, FAIL\n"
    },
    "pass_condition": "Redirect responses must have an empty body (0 bytes) after sending headers.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 0,
      "unit": "bytes",
      "notes": "Body length must be zero"
    },
    "fail_messages": [
      "Redirect response contains body content (${observed} bytes), violating the requirement to set headers before output."
    ],
    "references": [
      {
        "doc_title": "Redirects and Google Search",
        "url": "https://developers.google.com/search/docs/redirects",
        "section_title": "Implement server-side redirects",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["php", "redirect", "headers", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "PHP redirect with headers set before any output.",
        "snippet": "<?php\nheader('HTTP/1.1 301 Moved Permanently');\nheader('Location: https://www.example.com/newurl');\nexit();\n?>\n"
      },
      "failing": {
        "description": "PHP redirect where output is sent before headers.",
        "snippet": "<?php\necho \"Redirecting...\";\nheader('HTTP/1.1 301 Moved Permanently');\nheader('Location: https://www.example.com/newurl');\nexit();\n?>\n"
      }
    },
    "test_cases": [
      {
        "name": "Passing PHP redirect",
        "input_stub": {
          "http_headers": {
            "Status": "301 Moved Permanently",
            "Location": "https://www.example.com/newurl"
          },
          "response_body": ""
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Failing PHP redirect with body content",
        "input_stub": {
          "http_headers": {
            "Status": "301 Moved Permanently",
            "Location": "https://www.example.com/newurl"
          },
          "response_body": "Redirecting..."
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NOINDEX_ON_LOGIN_PAGE",
    "title": "Ensure login pages include a noindex robots meta tag",
    "category": "Edit or remove unwanted text before moving to a public file format",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Login pages may expose redacted content; a noindex meta tag prevents search engines from indexing them.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page to be evaluated"
      }
    ],
    "preconditions": [
      "Presence of a password input field indicates a login page"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "form input[type='password']",
        "attribute": null,
        "notes": "Detects login form"
      },
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Meta tag that may contain 'noindex'"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into DOM.\n# 2. If DOM contains element matching selector \"form input[type='password']\":\n#    a. Search for meta element matching selector \"meta[name='robots']\".\n#    b. If meta found and its content attribute includes the token \"noindex\" (case-insensitive):\n#         result = pass\n#       else:\n#         result = fail\n# 3. If no password input found, result = not_applicable\n"
    },
    "pass_condition": "Login pages contain a robots meta tag whose content includes \"noindex\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Login page missing noindex meta tag; observed content: ${observed_meta_content}"
    ],
    "references": [
      {
        "doc_title": "Keep redacted information out of Google Search",
        "url": "https://developers.google.com/search/docs/keep-redacted-info",
        "section_title": "Edit or remove unwanted text before moving to a public file format",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["redaction", "robots_meta"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with a password field and a meta robots tag containing \"noindex\"",
        "snippet": "<html><head><meta name=\"robots\" content=\"noindex, nofollow\"></head><body><form><input type=\"password\"></form></body></html>"
      },
      "failing": {
        "description": "Page with a password field but no noindex meta tag",
        "snippet": "<html><head></head><body><form><input type=\"password\"></form></body></html>"
      }
    },
    "test_cases": [
      {
        "name": "Login page with noindex",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex\"></head><body><form><input type=\"password\"></form></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Login page without noindex",
        "input_stub": {
          "html": "<html><head></head><body><form><input type=\"password\"></form></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      },
      {
        "name": "Non-login page",
        "input_stub": {
          "html": "<html><head></head><body><p>Welcome</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "not_applicable"
      }
    ]
  },
  {
    "id": "URL_NO_EMAIL",
    "title": "URLs must not contain email addresses",
    "category": "Edit or remove unwanted text before moving to a public file format",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Email addresses in URLs can be indexed and expose personal information.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "The full URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "url",
        "attribute": null,
        "notes": "Detects patterns like user@example.com in the URL"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: url\n# 1. Define regex pattern for email addresses: [A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\n# 2. If regex matches any substring of url:\n#       result = fail\n#    else:\n#       result = pass\n"
    },
    "pass_condition": "URL does not contain any substring matching an email address pattern.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["URL contains an email address; observed: ${observed}"],
    "references": [
      {
        "doc_title": "Keep redacted information out of Google Search",
        "url": "https://developers.google.com/search/docs/keep-redacted-info",
        "section_title": "Edit or remove unwanted text before moving to a public file format",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["redaction", "url_privacy"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL without email",
        "snippet": "https://example.com/report/2024-summary"
      },
      "failing": {
        "description": "URL containing an email address",
        "snippet": "https://example.com/user/jane.doe@example.com/report"
      }
    },
    "test_cases": [
      {
        "name": "URL without email",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/report/2024-summary"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "URL with email",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/user/jane.doe@example.com/report"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMAGE_NON_VECTOR_FORMAT",
    "title": "Ensure exported images are in non-vector formats (PNG or WEBP)",
    "category": "Edit and export images before embedding them",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Vector formats may retain hidden layers or metadata that can be indexed.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source containing img elements"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "src",
        "notes": "Collect source URLs of all images on the page"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and extract all img elements' src attributes.\n# 2. For each src, extract file extension (substring after last '.').\n# 3. If any extension is not in the allowed set {\"png\",\"webp\"} (case-insensitive):\n#       result = fail\n#    else:\n#       result = pass\n"
    },
    "pass_condition": "All image src URLs end with .png or .webp (case-insensitive).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Image with disallowed format found; observed src: ${observed}"
    ],
    "references": [
      {
        "doc_title": "Keep redacted information out of Google Search",
        "url": "https://developers.google.com/search/docs/keep-redacted-info",
        "section_title": "Edit and export images before embedding them",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["redaction", "image_format"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with only PNG and WEBP images",
        "snippet": "<html><body><img src=\"photo.png\"><img src=\"icon.webp\"></body></html>"
      },
      "failing": {
        "description": "Page with a JPEG image",
        "snippet": "<html><body><img src=\"photo.jpg\"></body></html>"
      }
    },
    "test_cases": [
      {
        "name": "All PNG/WebP images",
        "input_stub": {
          "html": "<html><body><img src=\"photo.png\"><img src=\"icon.webp\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "JPEG image present",
        "input_stub": {
          "html": "<html><body><img src=\"photo.jpg\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NOINDEX_META_TAG_PRESENT",
    "title": "Presence of noindex meta tag in HTML head",
    "category": "Implementing noindex",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "A <meta name=\"robots\" content=\"noindex\"> tag placed in the <head> prevents search engines that support the noindex rule from indexing the page, as described in the documentation.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head meta[name='robots'][content~='noindex']",
        "attribute": null,
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Parse the HTML document.\n# 2. Search within the <head> element for a <meta> tag where:\n#    a. attribute name equals \"robots\"\n#    b. attribute content contains the token \"noindex\" (case-insensitive).\n# 3. If such a tag exists, set observed = true; else observed = false.\n"
    },
    "pass_condition": "The page contains a <meta name=\"robots\" content=\"...noindex...\"> tag in its <head>.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No <meta name=\"robots\" content=\"...noindex...\"> tag found in the <head> of the page."
    ],
    "references": [
      {
        "doc_title": "Block Search indexing with noindex",
        "url": "https://developers.google.com/search/docs/advanced/crawling/block-indexing-noindex",
        "section_title": "Implementing `noindex`",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["noindex", "meta", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes the required meta tag.",
        "snippet": "<html>\n  <head>\n    <meta name=\"robots\" content=\"noindex\">\n  </head>\n  <body>...</body>\n</html>\n"
      },
      "failing": {
        "description": "Page lacks the required meta tag.",
        "snippet": "<html>\n  <head>\n    <title>Example</title>\n  </head>\n  <body>...</body>\n</html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Meta tag present",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex\"></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Meta tag absent",
        "input_stub": {
          "html": "<html><head><title>Test</title></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FILETYPE_INDEXABLE_CHECK",
    "title": "File extension is indexable by Google",
    "category": "File types indexable by Google",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "resource",
    "rationale": "Google can index the content of the listed text\u2011based and media file types; resources with other extensions may not be indexed.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the resource to evaluate"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "url",
        "attribute": null,
        "notes": "Extract the file extension from the URL path (e.g., \".pdf\")"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: url\n# 1. Parse the URL and isolate the path component.\n# 2. Extract the substring after the last '.' in the path as the extension (lowercase, without leading dot).\n# 3. Define ALLOWED_EXTENSIONS as the set:\n#    [\"pdf\",\"ps\",\"csv\",\"epub\",\"kml\",\"kmz\",\"gpx\",\"hwp\",\"htm\",\"html\",\"xls\",\"xlsx\",\"ppt\",\"pptx\",\"doc\",\"docx\",\"odp\",\"ods\",\"odt\",\"rtf\",\"svg\",\"tex\",\"txt\",\"text\",\"bas\",\"c\",\"cc\",\"cpp\",\"cxx\",\"h\",\"hpp\",\"cs\",\"java\",\"pl\",\"py\",\"wml\",\"wap\",\"xml\",\"bmp\",\"gif\",\"jpeg\",\"png\",\"webp\",\"avif\",\"3gp\",\"3g2\",\"asf\",\"avi\",\"divx\",\"m2v\",\"m3u\",\"m3u8\",\"m4v\",\"mkv\",\"mov\",\"mp4\",\"mpeg\",\"ogv\",\"qvt\",\"ram\",\"rm\",\"vob\",\"webm\",\"wmv\",\"xap\"]\n# 4. If the extracted extension is in ALLOWED_EXTENSIONS, result = PASS else result = FAIL.\n"
    },
    "pass_condition": "The extracted file extension is present in the list of indexable extensions.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "File extension '${observed}' is not among Google-indexable types."
    ],
    "references": [
      {
        "doc_title": "File types indexable by Google",
        "url": "https://developers.google.com/search/docs/advanced/crawling/file-types-indexable",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["indexability", "filetype"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL ending with an indexable extension",
        "snippet": "https://example.com/report.pdf"
      },
      "failing": {
        "description": "URL ending with a non\u2011indexable extension",
        "snippet": "https://example.com/script.exe"
      }
    },
    "test_cases": [
      {
        "name": "Indexable extension",
        "input_stub": {
          "url": "https://example.com/document.docx",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Non-indexable extension",
        "input_stub": {
          "url": "https://example.com/installer.exe",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REDIRECT_USES_PERMANENT_STATUS",
    "title": "Redirect uses permanent HTTP status",
    "category": "Redirects",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Permanent redirects (301/308) preserve link equity and signal the move to Google.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the old URL"
      }
    ],
    "preconditions": ["Response status is a 3xx redirect"],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "status_code",
        "attribute": null,
        "notes": "HTTP status code of the response"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Extract status_code from http_headers.\n# 2. Check if status_code is 301 or 308.\n"
    },
    "pass_condition": "Status code is 301 or 308",
    "threshold": {
      "type": "number",
      "operator": "in",
      "value": [301, 308],
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Redirect returned ${observed} instead of 301 or 308"],
    "references": [
      {
        "doc_title": "Plan your redirect strategy",
        "url": "https://developers.google.com/search/301-redirects.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["redirect", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Old URL returns 301",
        "snippet": "GET /old -> 301 Location: /new"
      },
      "failing": {
        "description": "Old URL returns 302",
        "snippet": "GET /old -> 302 Location: /new"
      }
    },
    "test_cases": [
      {
        "name": "Permanent redirect",
        "input_stub": {
          "http_headers": {
            "status_code": 301
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Temporary redirect",
        "input_stub": {
          "http_headers": {
            "status_code": 302
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REDIRECT_CHAIN_MAX_LENGTH",
    "title": "Redirect chain length limit",
    "category": "Redirects",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "site",
    "rationale": "Long redirect chains add latency and may exceed Googlebot's limit.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Starting URL to evaluate redirect chain"
      }
    ],
    "preconditions": ["URL returns a redirect (3xx)"],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "redirect_hops",
        "attribute": null,
        "notes": "Number of redirects followed until final destination"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url\n# 1. Follow redirects from url, counting each 3xx response until a non-redirect response is received or a loop is detected.\n# 2. Record hop_count.\n"
    },
    "pass_condition": "hop_count <= 5",
    "threshold": {
      "type": "number",
      "operator": "<=",
      "value": 5,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Redirect chain has ${observed} hops, exceeding the recommended maximum of 5"
    ],
    "references": [
      {
        "doc_title": "Avoid chaining redirects",
        "url": "https://developers.google.com/search/301-redirects.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["redirect", "chain"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Three-step redirect chain",
        "snippet": "1 -> 2 -> 3 -> final (3 hops)"
      },
      "failing": {
        "description": "Seven-step redirect chain",
        "snippet": "1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> final (7 hops)"
      }
    },
    "test_cases": [
      {
        "name": "Three hops",
        "input_stub": {
          "url": "http://example.com/start3"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Seven hops",
        "input_stub": {
          "url": "http://example.com/start7"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DELETED_CONTENT_HTTP_ERROR",
    "title": "Deleted or merged content returns appropriate error",
    "category": "Error Responses",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Returning 404 or 410 signals to Google that content is gone and prevents indexing of dead pages.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the URL"
      }
    ],
    "preconditions": ["URL is intended to be removed (no mapping to new URL)"],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "status_code",
        "attribute": null,
        "notes": "HTTP status code"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Extract status_code.\n# 2. Check if status_code is 404 or 410.\n"
    },
    "pass_condition": "Status code is 404 or 410",
    "threshold": {
      "type": "number",
      "operator": "in",
      "value": [404, 410],
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Removed URL returned ${observed}, expected 404 or 410"],
    "references": [
      {
        "doc_title": "Provide errors for deleted or merged content",
        "url": "https://developers.google.com/search/site-move-with-url-changes.html#prepare-new-site",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["http", "error"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Removed page returns 404",
        "snippet": "GET /old-removed -> 404"
      },
      "failing": {
        "description": "Removed page returns 200",
        "snippet": "GET /old-removed -> 200 OK"
      }
    },
    "test_cases": [
      {
        "name": "404 response",
        "input_stub": {
          "http_headers": {
            "status_code": 404
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "200 response",
        "input_stub": {
          "http_headers": {
            "status_code": 200
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_SELF_REFERENCING",
    "title": "Self-referencing rel=canonical tag present",
    "category": "Canonical Tags",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Self-referencing canonical informs Google of the preferred URL for the content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source of the page"
      }
    ],
    "preconditions": ["Page is a new URL after migration"],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='canonical']",
        "attribute": "href",
        "notes": "Href of canonical link"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse HTML and locate <link rel=\"canonical\"> element.\n# 2. Extract its href attribute.\n# 3. Compare href to the page's own URL (provided externally via context, assume variable page_url).\n# 4. Pass if href equals page_url.\n"
    },
    "pass_condition": "Canonical href matches the page's own URL",
    "threshold": {
      "type": "string",
      "operator": "==",
      "value": "${page_url}",
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Canonical href ${observed} does not match page URL ${expected}"
    ],
    "references": [
      {
        "doc_title": "Update annotations",
        "url": "https://developers.google.com/search/consolidate-duplicate-urls.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page has <link rel='canonical' href='https://example.com/page'>",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/page\">"
      },
      "failing": {
        "description": "Canonical points to different URL",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/old-page\">"
      }
    },
    "test_cases": [
      {
        "name": "Correct canonical",
        "input_stub": {
          "html": "<html><head><link rel='canonical' href='https://example.com/page'></head></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Incorrect canonical",
        "input_stub": {
          "html": "<html><head><link rel='canonical' href='https://example.com/old'></head></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HEAD_ALLOWED_ELEMENTS_MUST",
    "title": "Only allowed elements in <head>",
    "category": "Page Metadata",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google processes only the allowed elements in the <head>; any invalid element causes the rest of the metadata to be ignored.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head > *",
        "attribute": null,
        "notes": "Collect tag names of all direct children of <head>"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and locate the <head> element.\n# 2. For each direct child element of <head> in document order:\n#    a. Get the tag name.\n#    b. If tag name not in ALLOWED = {title, meta, link, script, style, base, noscript, template}:\n#         record as invalid and fail.\n# 3. If no invalid tags found, pass.\n"
    },
    "pass_condition": "All direct child elements of <head> are in the allowed set {title, meta, link, script, style, base, noscript, template}.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Invalid element <${observed}> found in <head>; only allowed elements are title, meta, link, script, style, base, noscript, template."
    ],
    "references": [
      {
        "doc_title": "Valid Page Metadata for Google Search",
        "url": "https://developers.google.com/search/docs/appearance/metadata",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["metadata", "head", "validation"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Head contains only allowed elements.",
        "snippet": "<head>\n  <title>Example</title>\n  <meta name=\"description\" content=\"...\">\n  <link rel=\"canonical\" href=\"https://example.com/\">\n</head>\n"
      },
      "failing": {
        "description": "Head contains an invalid element.",
        "snippet": "<head>\n  <title>Example</title>\n  <iframe src=\"...\"></iframe>\n  <meta name=\"description\" content=\"...\">\n</head>\n"
      }
    },
    "test_cases": [
      {
        "name": "allowed_elements_only",
        "input_stub": {
          "html": "<html><head><title>Test</title><meta charset='utf-8'></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "contains_invalid_element",
        "input_stub": {
          "html": "<html><head><title>Test</title><iframe src=''></iframe></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HEAD_INVALID_ELEMENTS_ORDER_SHOULD",
    "title": "Place invalid <head> elements after allowed elements",
    "category": "Page Metadata",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "page",
    "rationale": "If an invalid element appears before allowed elements, Google stops reading further elements, causing later metadata to be ignored.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head > *",
        "attribute": null,
        "notes": "Collect ordered list of tag names of direct children of <head>"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and locate the <head> element.\n# 2. Create list TAGS of tag names of each direct child in order.\n# 3. Define ALLOWED = {title, meta, link, script, style, base, noscript, template}\n# 4. Find index of first tag not in ALLOWED (first_invalid_index). If none, pass.\n# 5. For each tag after first_invalid_index:\n#    a. If tag is in ALLOWED, record as violation.\n# 6. If any violation recorded, fail; else pass.\n"
    },
    "pass_condition": "No allowed element appears after the first invalid element within <head>.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Allowed element <${observed}> appears after invalid element <${invalid}> in <head>."
    ],
    "references": [
      {
        "doc_title": "Valid Page Metadata for Google Search",
        "url": "https://developers.google.com/search/docs/appearance/metadata",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["metadata", "head", "ordering"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Invalid element placed after all allowed elements.",
        "snippet": "<head>\n  <title>Example</title>\n  <meta name=\"description\" content=\"...\">\n  <iframe src=\"...\"></iframe>\n</head>\n"
      },
      "failing": {
        "description": "Allowed element appears after an invalid element.",
        "snippet": "<head>\n  <iframe src=\"...\"></iframe>\n  <meta name=\"description\" content=\"...\">\n</head>\n"
      }
    },
    "test_cases": [
      {
        "name": "invalid_after_allowed",
        "input_stub": {
          "html": "<html><head><title>Test</title><iframe src=''></iframe></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "allowed_after_invalid",
        "input_stub": {
          "html": "<html><head><iframe src=''></iframe><meta charset='utf-8'></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REL_ATTRIBUTE_ALLOWED_VALUES",
    "title": "Validate allowed rel attribute values on outbound links",
    "category": "Qualify your outbound links to Google",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Ensures that rel attributes on <a> elements use only the values documented (sponsored, ugc, nofollow) so Google can interpret link qualifications correctly.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be inspected."
      }
    ],
    "preconditions": [
      "Page contains at least one <a> element with a rel attribute."
    ],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "a[rel]",
        "attribute": "rel",
        "notes": "Collect the value of the rel attribute from each <a> tag."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n1. Parse the HTML document.\n2. For each <a> element that has a rel attribute:\n   a. Retrieve the rel attribute value.\n   b. Split the value on whitespace to get individual tokens.\n   c. For each token, check if it is in the allowed set {\"sponsored\", \"ugc\", \"nofollow\"}.\n   d. If any token is not in the allowed set, record a failure with the observed token.\n3. If no disallowed tokens were found, the check passes.\n"
    },
    "pass_condition": "All rel attribute tokens on <a> elements are within the allowed set {sponsored, ugc, nofollow}.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Disallowed rel value '${observed}' found in <a> tag."],
    "references": [
      {
        "doc_title": "Qualify Outbound Links for SEO",
        "url": "https://developers.google.com/search/docs/links/outbound-links",
        "section_title": "Qualify your outbound links to Google",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["outbound_links", "rel_attribute"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "<a> tag with allowed rel values.",
        "snippet": "<a href=\"https://example.com\" rel=\"sponsored\">Sponsored Link</a>"
      },
      "failing": {
        "description": "<a> tag with a disallowed rel value.",
        "snippet": "<a href=\"https://example.com\" rel=\"external\">External Link</a>"
      }
    },
    "test_cases": [
      {
        "name": "Allowed rel value passes",
        "input_stub": {
          "html": "<p>Check <a href=\"https://example.com\" rel=\"ugc\">User Content</a></p>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Disallowed rel value fails",
        "input_stub": {
          "html": "<p>Check <a href=\"https://example.com\" rel=\"external\">External Link</a></p>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ROBOTS_TXT_IMAGE_BLOCK",
    "title": "Block image URLs via robots.txt Disallow rule",
    "category": "robots.txt",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "site",
    "rationale": "Robots.txt Disallow rules prevent Googlebot-Image from indexing specified image URLs, removing them from search results.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "User-agent:\\s*Googlebot-Image[\\s\\S]*?Disallow:\\s*(.+)",
        "attribute": null,
        "notes": "Capture Disallow paths for Googlebot-Image"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: robots_txt (string), target_image_path (string)\n# 1. Find the block of lines starting with \"User-agent: Googlebot-Image\".\n# 2. Within that block, extract all Disallow paths.\n# 3. If any Disallow path matches target_image_path exactly or matches a pattern that would include it (e.g., wildcard *), then PASS.\n# 4. Else FAIL.\n"
    },
    "pass_condition": "robots.txt contains a Disallow rule that matches the image URL under User-agent Googlebot-Image (or Googlebot).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No matching Disallow rule found for image URL ${image_url} in robots.txt."
    ],
    "references": [
      {
        "doc_title": "Remove images using robots.txt rules",
        "url": "https://developers.google.com/search/robots/intro.html",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots.txt", "image removal"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt includes Disallow for /images/dogs.jpg under Googlebot-Image.",
        "snippet": "User-agent: Googlebot-Image\nDisallow: /images/dogs.jpg\n"
      },
      "failing": {
        "description": "robots.txt does not contain a Disallow rule for the image.",
        "snippet": "User-agent: *\nDisallow: /private/\n"
      }
    },
    "test_cases": [
      {
        "name": "Image path blocked via robots.txt",
        "input_stub": {
          "robots_txt": "User-agent: Googlebot-Image\nDisallow: /images/dogs.jpg\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Image path not blocked",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /private/\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NOINDEX_HEADER_IMAGE_BLOCK",
    "title": "Block image URLs via noindex X-Robots-Tag header",
    "category": "noindex X-Robots-Tag",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "The noindex X-Robots-Tag header tells Googlebot not to index the image, but the URL must be crawlable for the header to be read.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers of the image URL"
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": "Header value should contain 'noindex'"
      },
      {
        "type": "regex",
        "selector": "User-agent:\\s*Googlebot-Image[\\s\\S]*?Disallow:\\s*(.+)",
        "attribute": null,
        "notes": "Check if image path is disallowed"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: http_headers (dict), robots_txt (string), image_path (string)\n# 1. Verify that http_headers contains \"X-Robots-Tag\".\n# 2. Verify that the value of \"X-Robots-Tag\" includes the token \"noindex\" (case-insensitive).\n# 3. Parse robots_txt for Disallow rules under User-agent Googlebot-Image (or Googlebot).\n# 4. If any Disallow rule matches image_path, then crawling is blocked \u2192 FAIL (must allow crawling).\n# 5. If step 2 passes and step 4 passes (i.e., not blocked), then PASS.\n# 6. Otherwise, FAIL.\n"
    },
    "pass_condition": "Image response includes X-Robots-Tag header with 'noindex' and the image URL is not blocked by robots.txt.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing X-Robots-Tag header with 'noindex' for image ${image_url}.",
      "Image URL ${image_url} is blocked by robots.txt, preventing Googlebot from reading the X-Robots-Tag header."
    ],
    "references": [
      {
        "doc_title": "Remove images with the `noindex` `X-Robots-Tag` HTTP header",
        "url": "https://developers.google.com/search/robots-meta-tag.html#xrobotstag-implementation",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["noindex", "X-Robots-Tag", "image removal"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Image response includes X-Robots-Tag: noindex and robots.txt does not disallow the image.",
        "snippet": "HTTP/1.1 200 OK\nX-Robots-Tag: noindex\n"
      },
      "failing": {
        "description": "Image response missing X-Robots-Tag header.",
        "snippet": "HTTP/1.1 200 OK\n(no X-Robots-Tag)\n"
      }
    },
    "test_cases": [
      {
        "name": "Header present and crawlable",
        "input_stub": {
          "http_headers": {
            "X-Robots-Tag": "noindex"
          },
          "robots_txt": "User-agent: *\nDisallow: /private/\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Header missing",
        "input_stub": {
          "http_headers": {},
          "robots_txt": "User-agent: *\nDisallow: /private/\n"
        },
        "expected_outcome": "fail"
      },
      {
        "name": "Crawling blocked",
        "input_stub": {
          "http_headers": {
            "X-Robots-Tag": "noindex"
          },
          "robots_txt": "User-agent: Googlebot-Image\nDisallow: /images/dogs.jpg\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NOINDEX_RULE_ABSENT",
    "title": "Ensure noindex robots rule is not present on new site pages",
    "category": "Prepare the new hosting infrastructure",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Prevents accidental indexing of the test site before it goes live.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to inspect meta robots tags."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers to inspect X-Robots-Tag."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name=\"robots\"]",
        "attribute": "content",
        "notes": "Check for presence of 'noindex' token (case\u2011insensitive)."
      },
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": "Check for presence of 'noindex' token (case\u2011insensitive)."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, http_headers\n# 1. Extract content of meta[name=\"robots\"] from html.\n# 2. Extract value of X-Robots-Tag header from http_headers.\n# 3. If either value contains the token \"noindex\" (case\u2011insensitive), set fail.\n# 4. Otherwise, set pass.\n"
    },
    "pass_condition": "No 'noindex' directive found in meta robots tags or X\u2011Robots\u2011Tag header.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Found 'noindex' directive in ${location}: ${observed}"],
    "references": [
      {
        "doc_title": "Changing Your Web Hosting and SEO",
        "url": "https://developers.google.com/search/docs/hosting/migrate",
        "section_title": "Prepare the new hosting infrastructure",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "indexing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page without noindex directives.",
        "snippet": "<meta name=\"robots\" content=\"index, follow\">"
      },
      "failing": {
        "description": "Page with a noindex meta tag.",
        "snippet": "<meta name=\"robots\" content=\"noindex, nofollow\">"
      }
    },
    "test_cases": [
      {
        "name": "No noindex present",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"index, follow\"></head></html>",
          "http_headers": {
            "X-Robots-Tag": "index, follow"
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Noindex in meta",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex\"></head></html>",
          "http_headers": {
            "X-Robots-Tag": "index"
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TEMPORARY_BLOCKS_REMOVED",
    "title": "Verify temporary crawling blocks are removed before launch",
    "category": "Start the move",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "site",
    "rationale": "Ensure the site is fully crawlable by Googlebot after the move.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Contents of the site's robots.txt file."
      },
      {
        "name": "html",
        "required": true,
        "description": "HTML of representative pages to check meta robots tags."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers to check X\u2011Robots\u2011Tag."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "robots_txt",
        "attribute": null,
        "notes": "Look for lines matching '^Disallow:\\s*/' (disallow all)."
      },
      {
        "type": "selector",
        "selector": "meta[name=\"robots\"]",
        "attribute": "content",
        "notes": "Check for 'noindex' or 'nofollow' tokens."
      },
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": "Check for 'noindex' or 'nofollow' tokens."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: robots_txt, html, http_headers\n# 1. Scan robots_txt for any line that matches '^Disallow:\\s*/'.\n# 2. Extract meta[name=\"robots\"] content from html and check for 'noindex' or 'nofollow'.\n# 3. Extract X-Robots-Tag header value and check for 'noindex' or 'nofollow'.\n# 4. If any of the above detections are true, set fail; otherwise, set pass.\n"
    },
    "pass_condition": "No disallow\u2011all rule in robots.txt and no noindex/nofollow directives in meta tags or X\u2011Robots\u2011Tag header.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Temporary block detected in ${source}: ${observed}"],
    "references": [
      {
        "doc_title": "Changing Your Web Hosting and SEO",
        "url": "https://developers.google.com/search/docs/hosting/migrate",
        "section_title": "Start the move",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "crawlability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No disallow\u2011all and no noindex directives.",
        "snippet": "robots.txt:\nUser-agent: *\nAllow: /\n"
      },
      "failing": {
        "description": "robots.txt blocks all crawling.",
        "snippet": "robots.txt:\nUser-agent: *\nDisallow: /\n"
      }
    },
    "test_cases": [
      {
        "name": "No blocks present",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"index, follow\"></head></html>",
          "http_headers": {
            "X-Robots-Tag": "index, follow"
          },
          "robots_txt": "User-agent: *\nAllow: /",
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Disallow all in robots.txt",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"index, follow\"></head></html>",
          "http_headers": {
            "X-Robots-Tag": "index, follow"
          },
          "robots_txt": "User-agent: *\nDisallow: /",
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SEARCH_CONSOLE_VERIFICATION_PRESENT",
    "title": "Verify Search Console verification assets are present on the new site",
    "category": "Prepare the new hosting infrastructure",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Ownership verification must continue to work after the hosting move.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the homepage or verification page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name=\"google-site-verification\"]",
        "attribute": "content",
        "notes": "Verification token should be non\u2011empty."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Search html for <meta name=\"google-site-verification\" content=\"...\">.\n# 2. If such a tag exists and content is not empty, set pass.\n# 3. Otherwise, set fail.\n"
    },
    "pass_condition": "Presence of a non\u2011empty google-site-verification meta tag.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Search Console verification meta tag missing or empty."],
    "references": [
      {
        "doc_title": "Changing Your Web Hosting and SEO",
        "url": "https://developers.google.com/search/docs/hosting/migrate",
        "section_title": "Prepare the new hosting infrastructure",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["verification", "search_console"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Verification meta tag present.",
        "snippet": "<meta name=\"google-site-verification\" content=\"abc123\">"
      },
      "failing": {
        "description": "Verification meta tag absent.",
        "snippet": "<!-- No verification tag -->"
      }
    },
    "test_cases": [
      {
        "name": "Verification tag present",
        "input_stub": {
          "html": "<html><head><meta name=\"google-site-verification\" content=\"abc123\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Verification tag missing",
        "input_stub": {
          "html": "<html><head></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "GOOGLEBOT_ACCESSIBLE",
    "title": "Confirm Googlebot can access the new site (HTTP 200)",
    "category": "Check that Googlebot is able to access the new hosting infrastructure",
    "requirement": "UNSPECIFIED",
    "severity": "critical",
    "scope": "page",
    "rationale": "Googlebot must be able to retrieve pages to index them after the move.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers including the status code."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "HTTP response status for the requested URL."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Retrieve the HTTP status code from http_headers (e.g., headers[':status'] or similar).\n# 2. If status code equals 200, set pass; otherwise, set fail.\n"
    },
    "pass_condition": "HTTP status code is 200.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 200,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Googlebot received HTTP status ${observed} instead of 200."
    ],
    "references": [
      {
        "doc_title": "Changing Your Web Hosting and SEO",
        "url": "https://developers.google.com/search/docs/hosting/migrate",
        "section_title": "Check that Googlebot is able to access the new hosting infrastructure",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["accessibility", "googlebot"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "HTTP 200 response.",
        "snippet": "HTTP/1.1 200 OK"
      },
      "failing": {
        "description": "HTTP 404 response.",
        "snippet": "HTTP/1.1 404 Not Found"
      }
    },
    "test_cases": [
      {
        "name": "HTTP 200 OK",
        "input_stub": {
          "html": null,
          "http_headers": {
            ":status": 200
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "HTTP 404 Not Found",
        "input_stub": {
          "html": null,
          "http_headers": {
            ":status": 404
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "URL_INSPECTION_TOOL_USER_ROLE",
    "title": "Verify user has required Search Console role for URL Inspection indexing request",
    "category": "Use the URL Inspection tool (just a few URLs)",
    "requirement": "MUST",
    "severity": "high",
    "scope": "site",
    "rationale": "The documentation states that a user must be an owner or full user of the Search Console property to request indexing via the URL Inspection tool.",
    "input_fields": [
      {
        "name": "search_console_user_role",
        "required": true,
        "description": "Role of the user in the Search Console property (e.g., owner, full_user, restricted_user)"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "search_console_user_role",
        "attribute": null,
        "notes": "Role value retrieved from Search Console API or UI"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: search_console_user_role\n# 1. Define allowed_roles = [\"owner\", \"full_user\"]\n# 2. If search_console_user_role is in allowed_roles, result = pass\n# 3. Else result = fail\n"
    },
    "pass_condition": "User role is either \"owner\" or \"full_user\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "User role ${observed} is not sufficient; required role is owner or full_user."
    ],
    "references": [
      {
        "doc_title": "Ask Google to Recrawl Your Website",
        "url": "https://developers.google.com/search/docs/monitoring/recrawl",
        "section_title": "Use the URL Inspection tool (just a few URLs)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["search_console", "url_inspection", "access_control"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "User is an owner of the Search Console property.",
        "snippet": "search_console_user_role: \"owner\"\n"
      },
      "failing": {
        "description": "User is a restricted user and cannot request indexing.",
        "snippet": "search_console_user_role: \"restricted_user\"\n"
      }
    },
    "test_cases": [
      {
        "name": "Owner role passes",
        "input_stub": {
          "search_console_user_role": "owner",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Restricted user fails",
        "input_stub": {
          "search_console_user_role": "restricted_user",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RESOURCES_NOT_BLOCKED_BY_ROBOTS_TXT",
    "title": "Ensure resources are not blocked by robots.txt",
    "category": "Resources",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "resource",
    "rationale": "Resources such as images, CSS, and JavaScript must be accessible to Google; if they are blocked by robots.txt Google cannot crawl the page properly.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to extract resource URLs."
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Full contents of the site's robots.txt file."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img[src], link[rel=stylesheet][href], script[src]",
        "attribute": "src",
        "notes": "URLs of resources referenced in the page."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, robots_txt\n# 1. Parse html and extract all URLs from img[src], link[rel=stylesheet][href], script[src].\n# 2. Parse robots_txt into a list of Disallow path patterns.\n# 3. For each extracted URL:\n#    a. Convert URL to path relative to site root.\n#    b. If any Disallow pattern matches the path, record as blocked.\n# 4. If any resource URL is recorded as blocked, the check fails.\n"
    },
    "pass_condition": "All extracted resource URLs are allowed by robots.txt.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Resource URL ${url} is blocked by robots.txt."],
    "references": [
      {
        "doc_title": "Technical SEO Techniques and Strategies",
        "url": "https://developers.google.com/search/docs/technical-seo",
        "section_title": "Resources",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["crawling", "indexing", "robots.txt"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page references images and CSS files that are not disallowed in robots.txt.",
        "snippet": "<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"/styles/main.css\">\n  </head>\n  <body>\n    <img src=\"/images/logo.png\">\n  </body>\n</html>\n# robots.txt\nUser-agent: *\nDisallow: /private/\n"
      },
      "failing": {
        "description": "Page references a script that is disallowed by robots.txt.",
        "snippet": "<html>\n  <head>\n    <script src=\"/js/analytics.js\"></script>\n  </head>\n</html>\n# robots.txt\nUser-agent: *\nDisallow: /js/\n"
      }
    },
    "test_cases": [
      {
        "name": "resources_allowed",
        "input_stub": {
          "html": "<img src=\"/images/a.png\"><link rel=\"stylesheet\" href=\"/css/b.css\">",
          "robots_txt": "User-agent: *\nDisallow: /private/",
          "http_headers": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "resources_blocked",
        "input_stub": {
          "html": "<script src=\"/js/blocked.js\"></script>",
          "robots_txt": "User-agent: *\nDisallow: /js/",
          "http_headers": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HREFLANG_TAGS_PRESENT",
    "title": "hreflang annotations present for multilingual pages",
    "category": "Internationalized or multi-lingual sites",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "hreflang tags tell Google which language or regional version of a page to serve, preventing duplicate content issues across locales.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to inspect for hreflang link elements."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=alternate][hreflang]",
        "attribute": "hreflang",
        "notes": "Value of the hreflang attribute for each alternate link."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html and find all <link> elements where rel=\"alternate\" and hreflang attribute exists.\n# 2. If at least one such element is found, the check passes.\n# 3. Otherwise, it fails.\n"
    },
    "pass_condition": "At least one hreflang link element is present in the page.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["No hreflang link tags found on the page."],
    "references": [
      {
        "doc_title": "Technical SEO Techniques and Strategies",
        "url": "https://developers.google.com/search/docs/technical-seo",
        "section_title": "Internationalized or multi-lingual sites",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "multilingual"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes hreflang links for English and French versions.",
        "snippet": "<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/page.html\">\n<link rel=\"alternate\" hreflang=\"fr\" href=\"https://example.com/fr/page.html\">\n"
      },
      "failing": {
        "description": "Page has no hreflang annotations.",
        "snippet": "<title>Example Page</title>\n"
      }
    },
    "test_cases": [
      {
        "name": "hreflang_present",
        "input_stub": {
          "html": "<link rel=\"alternate\" hreflang=\"es\" href=\"https://example.com/es/page.html\">",
          "robots_txt": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "hreflang_missing",
        "input_stub": {
          "html": "<title>Sample</title>",
          "robots_txt": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITE_USES_HTTPS",
    "title": "Site should be served over HTTPS",
    "category": "Manage the user experience",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "site",
    "rationale": "HTTPS provides security for users and is recommended by Google as a ranking signal.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "The canonical URL of the site to evaluate."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "scheme",
        "attribute": null,
        "notes": "URL scheme (http or https)."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url\n# 1. Parse the URL and extract its scheme component.\n# 2. If scheme equals \"https\", the check passes.\n# 3. Otherwise, it fails.\n"
    },
    "pass_condition": "URL scheme is https.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Site is served over HTTP instead of HTTPS."],
    "references": [
      {
        "doc_title": "Technical SEO Techniques and Strategies",
        "url": "https://developers.google.com/search/docs/technical-seo",
        "section_title": "Manage the user experience",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["security", "https"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL uses HTTPS.",
        "snippet": "https://www.example.com"
      },
      "failing": {
        "description": "URL uses HTTP.",
        "snippet": "http://www.example.com"
      }
    },
    "test_cases": [
      {
        "name": "https_used",
        "input_stub": {
          "url": "https://www.example.com",
          "html": null,
          "robots_txt": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "http_used",
        "input_stub": {
          "url": "http://www.example.com",
          "html": null,
          "robots_txt": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TRUE_404_FOR_NOT_FOUND",
    "title": "Return proper 404 status for missing pages",
    "category": "Migrating a single URL",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "A true 404 response signals to Google that a page is permanently unavailable; soft 404s can mislead indexing.",
    "input_fields": [
      {
        "name": "http_status",
        "required": true,
        "description": "HTTP response status code for the requested URL."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "Numeric HTTP status code."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_status\n# 1. If http_status equals 404, the check passes.\n# 2. Otherwise, it fails.\n"
    },
    "pass_condition": "HTTP status code is 404.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Page returned status ${observed} instead of 404."],
    "references": [
      {
        "doc_title": "Technical SEO Techniques and Strategies",
        "url": "https://developers.google.com/search/docs/technical-seo",
        "section_title": "Migrating a single URL",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["http", 404],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Server returns a 404 for a removed page.",
        "snippet": "GET /old-page.html HTTP/1.1\nHost: example.com\n\nHTTP/1.1 404 Not Found\n"
      },
      "failing": {
        "description": "Server returns 200 with a custom not\u2011found page (soft 404).",
        "snippet": "GET /old-page.html HTTP/1.1\nHost: example.com\n\nHTTP/1.1 200 OK\n"
      }
    },
    "test_cases": [
      {
        "name": "proper_404",
        "input_stub": {
          "http_status": 404,
          "html": null,
          "robots_txt": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "soft_404",
        "input_stub": {
          "http_status": 200,
          "html": "<h1>Page not found</h1>",
          "robots_txt": null,
          "lighthouse_metrics": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SEO_SHOULD_NOT_LINK_TO_SEO",
    "title": "Avoid linking to SEO provider",
    "category": "Helpful guidelines",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "site",
    "rationale": "Linking to an SEO provider can be considered a link scheme and may violate Google's policies.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the site to analyze outbound links."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href]",
        "attribute": "href",
        "notes": "Collect URLs of all outbound links."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html and extract all <a> elements with href.\n# 2. For each href, extract domain.\n# 3. If any domain matches known SEO provider domains (provided via configuration), flag as violation.\n# 4. If no such links, pass.\n"
    },
    "pass_condition": "No outbound links point to the SEO provider's domain.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found outbound link to SEO provider domain: ${observed}"
    ],
    "references": [
      {
        "doc_title": "Helpful guidelines",
        "url": "https://developers.google.com/search/docs/seo/choose-an-seo",
        "section_title": "Helpful guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["link_scheme", "outbound_links"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page without links to SEO provider.",
        "snippet": "<html><body><a href='https://example.com'>Home</a></body></html>"
      },
      "failing": {
        "description": "Page contains link to SEO provider.",
        "snippet": "<html><body><a href='https://seo-provider.com'>SEO</a></body></html>"
      }
    },
    "test_cases": [
      {
        "name": "No SEO link",
        "input_stub": {
          "html": "<a href='https://example.com'>Home</a>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Contains SEO link",
        "input_stub": {
          "html": "<a href='https://seo-provider.com'>SEO</a>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SEO_SHOULD_EXPLAIN_FTP_CHANGES",
    "title": "SEO with FTP access must explain changes",
    "category": "Helpful guidelines",
    "requirement": "SHOULD",
    "severity": "low",
    "scope": "site",
    "rationale": "Transparency about changes made via FTP ensures the site owner can verify compliance and avoid hidden manipulations.",
    "input_fields": [
      {
        "name": "ftp_access_granted",
        "required": true,
        "description": "Boolean indicating whether the SEO has FTP access to the site."
      },
      {
        "name": "change_explanations_provided",
        "required": true,
        "description": "Boolean indicating whether the SEO has provided explanations for all changes made via FTP."
      }
    ],
    "preconditions": ["ftp_access_granted == true"],
    "evidence_to_collect": [],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: ftp_access_granted, change_explanations_provided\n# 1. If ftp_access_granted is false, the check is not applicable.\n# 2. If ftp_access_granted is true, verify change_explanations_provided is true.\n# 3. Pass if explanations are provided; otherwise fail.\n"
    },
    "pass_condition": "When FTP access is granted, the SEO provides explanations for all changes.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["FTP access granted without explanations for changes."],
    "references": [
      {
        "doc_title": "Helpful guidelines",
        "url": "https://developers.google.com/search/docs/seo/choose-an-seo",
        "section_title": "Helpful guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["transparency", "ftp"],
    "insufficient_evidence": true,
    "notes": "Automated verification may require manual confirmation.",
    "examples": {
      "passing": {
        "description": "FTP access granted and explanations provided.",
        "snippet": ""
      },
      "failing": {
        "description": "FTP access granted but no explanations.",
        "snippet": ""
      }
    },
    "test_cases": [
      {
        "name": "FTP access with explanations",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null,
          "ftp_access_granted": true,
          "change_explanations_provided": true
        },
        "expected_outcome": "pass"
      },
      {
        "name": "FTP access without explanations",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null,
          "ftp_access_granted": true,
          "change_explanations_provided": false
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMG_ALT_TEXT",
    "title": "Ensure all images have descriptive alt text",
    "category": "Add images to your site, and optimize them",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Alt text helps search engines understand image content and improves accessibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "alt",
        "notes": "Collect the alt attribute value for each img element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n1. Parse html into a DOM.\n2. For each <img> element in the DOM:\n   a. Retrieve the value of its \"alt\" attribute.\n   b. If the attribute is missing or empty, record a failure.\n3. If any failures recorded, result = fail; else result = pass.\n"
    },
    "pass_condition": "All <img> elements have a non\u2011empty alt attribute.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Image at index ${index} is missing a non\u2011empty alt attribute."
    ],
    "references": [
      {
        "doc_title": "SEO Starter Guide",
        "url": "https://developers.google.com/search/docs/fundamentals/seo-starter-guide",
        "section_title": "Add images to your site, and optimize them",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["images", "accessibility", "alt-text"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Image with descriptive alt text.",
        "snippet": "<img src=\"cat.jpg\" alt=\"A tabby cat sitting on a windowsill\">"
      },
      "failing": {
        "description": "Image missing alt attribute.",
        "snippet": "<img src=\"cat.jpg\">"
      }
    },
    "test_cases": [
      {
        "name": "Image with alt",
        "input_stub": {
          "html": "<html><body><img src=\"a.jpg\" alt=\"A scenic mountain\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Image without alt",
        "input_stub": {
          "html": "<html><body><img src=\"b.jpg\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TITLE_ELEMENT_PRESENT",
    "title": "Verify presence of a <title> element",
    "category": "Influence your title links",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "The <title> element is used by Google to generate title links in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "title",
        "attribute": null,
        "notes": "Collect the text content of the <title> element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n1. Parse html into a DOM.\n2. Search for a <title> element in the <head>.\n3. If a <title> element exists and its text is non\u2011empty, result = pass.\n4. Otherwise, result = fail.\n"
    },
    "pass_condition": "Page contains a non\u2011empty <title> element.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "The page does not contain a <title> element or it is empty."
    ],
    "references": [
      {
        "doc_title": "SEO Starter Guide",
        "url": "https://developers.google.com/search/docs/fundamentals/seo-starter-guide",
        "section_title": "Influence your title links",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["title", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with a proper title.",
        "snippet": "<head><title>Delicious Apple Pie Recipe</title></head>"
      },
      "failing": {
        "description": "Missing title element.",
        "snippet": "<head></head>"
      }
    },
    "test_cases": [
      {
        "name": "Title present",
        "input_stub": {
          "html": "<html><head><title>Example Page</title></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Title missing",
        "input_stub": {
          "html": "<html><head></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "META_DESCRIPTION_PRESENT",
    "title": "Ensure presence of a meta description tag",
    "category": "Control your snippets",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Meta description often supplies the snippet shown in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='description']",
        "attribute": "content",
        "notes": "Collect the content attribute of the meta description."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n1. Parse html into a DOM.\n2. Locate <meta name=\"description\"> element.\n3. If element exists and its content attribute is non\u2011empty, result = pass.\n4. Otherwise, result = fail.\n"
    },
    "pass_condition": "Page contains a non\u2011empty meta description tag.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Meta description tag is missing or empty."],
    "references": [
      {
        "doc_title": "SEO Starter Guide",
        "url": "https://developers.google.com/search/docs/fundamentals/seo-starter-guide",
        "section_title": "Control your snippets",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["meta", "snippet"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with meta description.",
        "snippet": "<head><meta name=\"description\" content=\"Learn how to bake a chocolate cake in 5 easy steps.\"></head>"
      },
      "failing": {
        "description": "Missing meta description.",
        "snippet": "<head></head>"
      }
    },
    "test_cases": [
      {
        "name": "Meta description present",
        "input_stub": {
          "html": "<html><head><meta name=\"description\" content=\"A short summary.\"></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Meta description missing",
        "input_stub": {
          "html": "<html><head></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LINK_TEXT_DESCRIPTIVE",
    "title": "Verify that anchor text is non\u2011empty and descriptive",
    "category": "Link to relevant resources",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Descriptive anchor text helps users and search engines understand linked content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a",
        "attribute": null,
        "notes": "Collect the text content of each anchor element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n1. Parse html into a DOM.\n2. For each <a> element:\n   a. Retrieve its visible text (trim whitespace).\n   b. If text is empty, record a failure.\n3. If any failures recorded, result = fail; else result = pass.\n"
    },
    "pass_condition": "All anchor elements have non\u2011empty visible text.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Anchor at index ${index} has empty link text."],
    "references": [
      {
        "doc_title": "SEO Starter Guide",
        "url": "https://developers.google.com/search/docs/fundamentals/seo-starter-guide",
        "section_title": "Link to relevant resources",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["links", "anchor-text"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Anchor with descriptive text.",
        "snippet": "<a href=\"/about\">About Our Company</a>"
      },
      "failing": {
        "description": "Anchor with no text.",
        "snippet": "<a href=\"/contact\"></a>"
      }
    },
    "test_cases": [
      {
        "name": "Anchor text present",
        "input_stub": {
          "html": "<html><body><a href=\"/home\">Home</a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Anchor text missing",
        "input_stub": {
          "html": "<html><body><a href=\"/login\"></a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ROBOTS_TXT_DISALLOW_CRAWL",
    "title": "Ensure page is not disallowed by robots.txt",
    "category": "Crawling",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Pages disallowed by robots.txt cannot be crawled, which prevents Google from discovering and indexing them.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file"
      },
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "robots_txt",
        "attribute": null,
        "notes": "Extract Disallow rules for User-agent * or Googlebot and compare against the page path"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: robots_txt (string), url (string)\n# 1. Parse the URL to obtain its path component.\n# 2. Extract all Disallow directives applicable to User-agent * or Googlebot from robots_txt.\n# 3. For each Disallow rule, treat it as a path prefix.\n# 4. If the page path starts with any Disallow prefix, set disallowed = true.\n# 5. Otherwise, disallowed = false.\n"
    },
    "pass_condition": "No Disallow rule in robots.txt matches the page URL path.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Page URL ${url} is disallowed by robots.txt."],
    "references": [
      {
        "doc_title": "In-depth guide to how Google Search works",
        "url": "https://developers.google.com/search/docs/crawling-indexing/overview",
        "section_title": "Crawling",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["crawling", "robots_txt"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page URL not matched by any Disallow rule.",
        "snippet": "robots_txt:\n  User-agent: *\n  Disallow: /private/\nurl: https://example.com/public/page.html\n"
      },
      "failing": {
        "description": "Page URL matches a Disallow rule.",
        "snippet": "robots_txt:\n  User-agent: *\n  Disallow: /private/\nurl: https://example.com/private/secret.html\n"
      }
    },
    "test_cases": [
      {
        "name": "Allowed page",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /admin/",
          "url": "https://example.com/blog/post.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Disallowed page",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /blog/",
          "url": "https://example.com/blog/post.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HTTP_STATUS_NOT_5XX",
    "title": "Verify page does not return a server error status",
    "category": "Crawling",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "HTTP 5xx responses indicate server errors that prevent Googlebot from successfully crawling the page.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers including the status code"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "Capture the numeric HTTP status code from the response"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: http_headers (object with field status_code)\n# 1. Retrieve status_code from http_headers.\n# 2. If status_code >= 500 and status_code < 600, set error = true.\n# 3. Else, error = false.\n"
    },
    "pass_condition": "HTTP status code is not in the 5xx range.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page returned HTTP status ${observed}, which indicates a server error."
    ],
    "references": [
      {
        "doc_title": "In-depth guide to how Google Search works",
        "url": "https://developers.google.com/search/docs/crawling-indexing/overview",
        "section_title": "Crawling",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["crawling", "http_status"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page returns 200 OK.",
        "snippet": "http_headers:\n  status_code: 200\n"
      },
      "failing": {
        "description": "Page returns 503 Service Unavailable.",
        "snippet": "http_headers:\n  status_code: 503\n"
      }
    },
    "test_cases": [
      {
        "name": "Successful response",
        "input_stub": {
          "http_headers": {
            "status_code": 200
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Server error response",
        "input_stub": {
          "http_headers": {
            "status_code": 502
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "META_ROBOTS_NOINDEX",
    "title": "Ensure meta robots tag does not block indexing",
    "category": "Indexing",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "A meta robots tag containing \"noindex\" tells Google not to index the page, preventing it from appearing in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Extract the content attribute of the meta robots tag"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html (string)\n# 1. Parse html and locate <meta name=\"robots\"> element.\n# 2. If element exists, read its content attribute.\n# 3. Convert content to lower case and split by commas.\n# 4. If any token equals \"noindex\", set blocked = true.\n# 5. Else, blocked = false.\n"
    },
    "pass_condition": "Meta robots tag is absent or does not contain \"noindex\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Meta robots tag contains 'noindex', preventing indexing."
    ],
    "references": [
      {
        "doc_title": "In-depth guide to how Google Search works",
        "url": "https://developers.google.com/search/docs/crawling-indexing/overview",
        "section_title": "Indexing",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["indexing", "meta_robots"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No meta robots tag or tag without noindex.",
        "snippet": "<head>\n  <title>Example Page</title>\n</head>\n"
      },
      "failing": {
        "description": "Meta robots tag includes noindex.",
        "snippet": "<head>\n  <meta name=\"robots\" content=\"noindex, nofollow\">\n</head>\n"
      }
    },
    "test_cases": [
      {
        "name": "No meta robots tag",
        "input_stub": {
          "html": "<html><head><title>Test</title></head><body></body></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Meta robots with noindex",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex\"></head><body></body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGE_EXPERIENCE_DIVERSITY",
    "title": "Avoid focusing on only one or two aspects of page experience",
    "category": "Provide a great page experience",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google advises site owners not to focus on only one or two aspects of page experience, but to provide an overall great experience across many signals.",
    "input_fields": [
      {
        "name": "lighthouse_metrics",
        "required": true,
        "description": "Lighthouse performance metrics including core web vitals and other page\u2011experience signals."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "lighthouse_metrics",
        "attribute": null,
        "notes": "Collect pass/fail for each core page\u2011experience signal: LCP, FID, CLS, mobile_friendly, safe_browsing, https, no_intrusive_interstitials."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: lighthouse_metrics (object with boolean fields for each signal)\n# Steps:\n1. Define signals = [LCP, FID, CLS, mobile_friendly, safe_browsing, https, no_intrusive_interstitials].\n2. Initialize pass_count = 0.\n3. For each signal in signals:\n     if lighthouse_metrics[signal] == true:\n         pass_count += 1\n4. If pass_count >= 5 then result = \"pass\" else result = \"fail\".\n"
    },
    "pass_condition": "At least five of the seven core page\u2011experience signals have passing scores.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 5,
      "unit": null,
      "notes": "Number of passing signals required."
    },
    "fail_messages": [
      "Only ${observed} of the required 5 page\u2011experience signals passed."
    ],
    "references": [
      {
        "doc_title": "Provide a great page experience",
        "url": "https://developers.google.com/search/docs/advanced/guidelines/content",
        "section_title": "Provide a great page experience",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["page_experience", "seo", "guideline"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All core web vitals and other signals pass.",
        "snippet": "lighthouse_metrics:\n  LCP: true\n  FID: true\n  CLS: true\n  mobile_friendly: true\n  safe_browsing: true\n  https: true\n  no_intrusive_interstitials: true\n"
      },
      "failing": {
        "description": "Only two signals pass, indicating narrow focus.",
        "snippet": "lighthouse_metrics:\n  LCP: true\n  FID: false\n  CLS: false\n  mobile_friendly: true\n  safe_browsing: false\n  https: false\n  no_intrusive_interstitials: false\n"
      }
    },
    "test_cases": [
      {
        "name": "Sufficient page experience signals",
        "input_stub": {
          "lighthouse_metrics": {
            "LCP": true,
            "FID": true,
            "CLS": true,
            "mobile_friendly": true,
            "safe_browsing": true,
            "https": false,
            "no_intrusive_interstitials": false
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Insufficient page experience signals",
        "input_stub": {
          "lighthouse_metrics": {
            "LCP": true,
            "FID": false,
            "CLS": false,
            "mobile_friendly": false,
            "safe_browsing": false,
            "https": false,
            "no_intrusive_interstitials": false
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AI_GENERATED_IMAGE_METADATA_MUST_CONTAIN_IPTC_DIGITAL_SOURCE_TYPE",
    "title": "AI-generated images must include IPTC DigitalSourceType metadata",
    "category": "AI-generated image metadata",
    "requirement": "MUST",
    "severity": "low",
    "scope": "resource",
    "rationale": "Ensures AI\u2011generated images are identifiable and comply with Google Merchant Center policies.",
    "input_fields": [
      {
        "name": "image_metadata",
        "required": true,
        "description": "IPTC metadata extracted from the image file"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "DigitalSourceType",
        "attribute": null,
        "notes": "Must be present in IPTC metadata"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: image_metadata (object with IPTC fields)\n# Steps:\n1. IF \"DigitalSourceType\" NOT IN image_metadata:\n2.     RETURN fail\n3. IF image_metadata[\"DigitalSourceType\"] != \"TrainedAlgorithmicMedia\":\n4.     RETURN fail\n5. RETURN pass\n"
    },
    "pass_condition": "IPTC DigitalSourceType metadata exists and equals \"TrainedAlgorithmicMedia\"",
    "threshold": {
      "type": "string",
      "operator": "==",
      "value": "TrainedAlgorithmicMedia",
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing IPTC DigitalSourceType metadata or value is '${observed}' instead of required 'TrainedAlgorithmicMedia'."
    ],
    "references": [
      {
        "doc_title": "Google Search's guidance on using generative AI content on your website",
        "url": "https://developers.google.com/search/blog/2023/02/google-search-and-ai-content",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["ai", "image", "metadata"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Image file contains IPTC DigitalSourceType set to TrainedAlgorithmicMedia.",
        "snippet": "{\n  \"DigitalSourceType\": \"TrainedAlgorithmicMedia\",\n  \"OtherField\": \"value\"\n}\n"
      },
      "failing": {
        "description": "Image file lacks DigitalSourceType or has a different value.",
        "snippet": "{\n  \"OtherField\": \"value\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Image with correct IPTC metadata",
        "input_stub": {
          "image_metadata": "{\"DigitalSourceType\":\"TrainedAlgorithmicMedia\"}",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Image missing IPTC metadata",
        "input_stub": {
          "image_metadata": "{}",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AI_GENERATED_PRODUCT_DATA_MUST_BE_LABELED",
    "title": "AI-generated product titles and descriptions must be labeled as AI-generated",
    "category": "AI-generated product data",
    "requirement": "MUST",
    "severity": "low",
    "scope": "resource",
    "rationale": "Guarantees transparency for users and compliance with Google Merchant Center AI content policies.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source of the product page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='product-title'][data-ai-generated='true']",
        "attribute": null,
        "notes": "Presence indicates AI\u2011generated title label"
      },
      {
        "type": "selector",
        "selector": "meta[name='product-description'][data-ai-generated='true']",
        "attribute": null,
        "notes": "Presence indicates AI\u2011generated description label"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html (string)\n# Steps:\n1. Parse html into DOM.\n2. IF meta[name='product-title'][data-ai-generated='true'] NOT FOUND:\n3.     RETURN fail\n4. IF meta[name='product-description'][data-ai-generated='true'] NOT FOUND:\n5.     RETURN fail\n6. RETURN pass\n"
    },
    "pass_condition": "Both product title and description meta tags are present with data-ai-generated=\"true\"",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing AI\u2011generated label for product title or description."
    ],
    "references": [
      {
        "doc_title": "Google Search's guidance on using generative AI content on your website",
        "url": "https://developers.google.com/search/blog/2023/02/google-search-and-ai-content",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["ai", "ecommerce", "product"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Product page includes labeled meta tags for AI\u2011generated title and description.",
        "snippet": "<meta name=\"product-title\" content=\"Smartphone X\" data-ai-generated=\"true\">\n<meta name=\"product-description\" content=\"Latest model with AI features.\" data-ai-generated=\"true\">\n"
      },
      "failing": {
        "description": "Product page lacks AI\u2011generated labels.",
        "snippet": "<meta name=\"product-title\" content=\"Smartphone X\">\n<meta name=\"product-description\" content=\"Latest model with AI features.\">\n"
      }
    },
    "test_cases": [
      {
        "name": "Properly labeled AI-generated product data",
        "input_stub": {
          "html": "<meta name=\"product-title\" content=\"Smartphone X\" data-ai-generated=\"true\"><meta name=\"product-description\" content=\"Latest model\" data-ai-generated=\"true\">",
          "image_metadata": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing AI-generated label",
        "input_stub": {
          "html": "<meta name=\"product-title\" content=\"Smartphone X\"><meta name=\"product-description\" content=\"Latest model\">",
          "image_metadata": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FAVICON_CRAWLABILITY",
    "title": "Ensure favicon and home page are crawlable by Googlebot",
    "category": "Guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "site",
    "rationale": "Googlebot-Image and Googlebot must be able to crawl the favicon file and the home page; blocking them prevents the favicon from appearing in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the site's home page to locate the favicon <link> element."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the home page and favicon URL."
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Contents of the site's robots.txt file."
      }
    ],
    "preconditions": [
      "Home page contains a <link> element with rel='icon' (or apple-touch-icon variants)."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel~='icon'], link[rel='apple-touch-icon'], link[rel='apple-touch-icon-precomposed']",
        "attribute": "href",
        "notes": "Extracted favicon URL."
      },
      {
        "type": "http_status",
        "selector": "home_page",
        "attribute": null,
        "notes": "Status code for the home page request."
      },
      {
        "type": "http_status",
        "selector": "favicon_url",
        "attribute": null,
        "notes": "Status code for the favicon request."
      },
      {
        "type": "robots_txt",
        "selector": "User-agent: *",
        "attribute": null,
        "notes": "Check for Disallow rules that block the favicon path or home page."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse html to find favicon_href using the selector above.\n# 2. Perform HTTP GET on home page URL; record status_home.\n# 3. Perform HTTP GET on favicon_href; record status_favicon.\n# 4. Load robots_txt and verify no Disallow rule matches home page path or favicon_href.\n# 5. If status_home == 200 AND status_favicon == 200 AND not blocked by robots_txt => pass.\n#    Else => fail.\n"
    },
    "pass_condition": "Both the home page and the favicon URL return HTTP 200 and are not blocked by robots.txt.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Home page returned ${status_home} instead of 200.",
      "Favicon URL returned ${status_favicon} instead of 200.",
      "Robots.txt blocks crawling of ${blocked_path}."
    ],
    "references": [
      {
        "doc_title": "Define Website Favicon for Search Results",
        "url": "https://developers.google.com/search/docs/appearance/favicon",
        "section_title": "Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["favicon", "crawlability", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Home page and favicon both return 200 and are not disallowed.",
        "snippet": "<link rel=\"icon\" href=\"/favicon.ico\">\nHTTP/1.1 200 OK (home page)\nHTTP/1.1 200 OK (GET /favicon.ico)\nrobots.txt does not contain Disallow for /favicon.ico\n"
      },
      "failing": {
        "description": "Favicon is blocked by robots.txt.",
        "snippet": "<link rel=\"icon\" href=\"/private/favicon.ico\">\nrobots.txt contains \"Disallow: /private/\"\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass when both resources are accessible",
        "input_stub": {
          "html": "<html><head><link rel='icon' href='/favicon.ico'></head></html>",
          "http_headers": {
            "home_page": {
              "status": 200
            },
            "favicon_url": {
              "status": 200
            }
          },
          "robots_txt": "User-agent: *\nAllow: /",
          "url": "https://example.com"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail when favicon is blocked",
        "input_stub": {
          "html": "<html><head><link rel='icon' href='/secret/favicon.ico'></head></html>",
          "http_headers": {
            "home_page": {
              "status": 200
            },
            "favicon_url": {
              "status": 200
            }
          },
          "robots_txt": "User-agent: *\nDisallow: /secret/",
          "url": "https://example.com"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FAVICON_DIMENSIONS",
    "title": "Verify favicon is square and at least 8x8 pixels",
    "category": "Guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Google requires the favicon to be a square image with a minimum size of 8x8\u202fpx to be eligible for display in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the home page to locate the favicon link."
      },
      {
        "name": "favicon_image",
        "required": true,
        "description": "Binary image data of the favicon referenced by the link."
      }
    ],
    "preconditions": [
      "Home page contains a <link> element with rel='icon' (or apple-touch-icon variants)."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel~='icon'], link[rel='apple-touch-icon'], link[rel='apple-touch-icon-precomposed']",
        "attribute": "href",
        "notes": "Favicon URL."
      },
      {
        "type": "metric",
        "selector": "image_width",
        "attribute": null,
        "notes": "Width of the fetched favicon image in pixels."
      },
      {
        "type": "metric",
        "selector": "image_height",
        "attribute": null,
        "notes": "Height of the fetched favicon image in pixels."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract favicon_href from html using the selector.\n# 2. Fetch the image at favicon_href and obtain width and height.\n# 3. If width == height AND width >= 8 THEN pass ELSE fail.\n"
    },
    "pass_condition": "The favicon image is square (width equals height) and its width (and height) is at least 8\u202fpx.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 8,
      "unit": "px",
      "notes": "Applies to both width and height; they must be equal."
    },
    "fail_messages": [
      "Favicon dimensions are ${width}x${height}px; must be square and at least 8x8px."
    ],
    "references": [
      {
        "doc_title": "Define Website Favicon for Search Results",
        "url": "https://developers.google.com/search/docs/appearance/favicon",
        "section_title": "Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["favicon", "dimensions", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "48x48 square PNG favicon.",
        "snippet": "<link rel=\"icon\" href=\"/favicon.png\">\nImage size: 48px \u00d7 48px\n"
      },
      "failing": {
        "description": "16x32 rectangular favicon.",
        "snippet": "<link rel=\"icon\" href=\"/favicon.ico\">\nImage size: 16px \u00d7 32px\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with 48x48 square favicon",
        "input_stub": {
          "html": "<link rel='icon' href='/favicon.png'>",
          "favicon_image": {
            "width": 48,
            "height": 48
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail with non\u2011square favicon",
        "input_stub": {
          "html": "<link rel='icon' href='/favicon.ico'>",
          "favicon_image": {
            "width": 16,
            "height": 32
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FAVICON_URL_STABILITY",
    "title": "Ensure favicon URL is stable and not frequently changed",
    "category": "Guidelines",
    "requirement": "MUST",
    "severity": "low",
    "scope": "resource",
    "rationale": "A stable favicon URL prevents Google from losing the association between the site and its favicon, ensuring consistent display in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the home page to locate the favicon link."
      }
    ],
    "preconditions": [
      "Home page contains a <link> element with rel='icon' (or apple-touch-icon variants)."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel~='icon'], link[rel='apple-touch-icon'], link[rel='apple-touch-icon-precomposed']",
        "attribute": "href",
        "notes": "Favicon URL."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract favicon_href from html.\n# 2. If favicon_href contains a query string (e.g., \"?v=123\") OR\n#    matches a pattern indicating versioned filenames (e.g., \"favicon-*.ico\")\n#    THEN flag as unstable.\n# 3. Otherwise, consider the URL stable.\n"
    },
    "pass_condition": "The favicon href does not contain a query component and does not match a versioned filename pattern.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Favicon URL '${href}' appears to be dynamic (contains query parameters or versioned filename)."
    ],
    "references": [
      {
        "doc_title": "Define Website Favicon for Search Results",
        "url": "https://developers.google.com/search/docs/appearance/favicon",
        "section_title": "Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["favicon", "url", "stability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Simple stable path.",
        "snippet": "<link rel=\"icon\" href=\"/favicon.ico\">\n"
      },
      "failing": {
        "description": "URL with version query.",
        "snippet": "<link rel=\"icon\" href=\"/favicon.ico?v=20240101\">\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with stable URL",
        "input_stub": {
          "html": "<link rel='icon' href='/favicon.ico'>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail with query parameter",
        "input_stub": {
          "html": "<link rel='icon' href='/favicon.ico?v=20240101'>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_SELF_LINK",
    "title": "Web Story must have self-referential canonical link",
    "category": "Check if the Web Story is indexed",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "A self\u2011referential canonical link tells Google the definitive URL for the story, enabling correct indexing and avoiding duplicate content issues.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the Web Story page"
      },
      {
        "name": "url",
        "required": true,
        "description": "The URL at which the Web Story is served"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='canonical']",
        "attribute": "href",
        "notes": "Canonical URL declared in the page"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, url\n# 1. Parse the HTML document.\n# 2. Locate the first <link> element with rel=\"canonical\".\n# 3. If no such element exists, set observed = null and FAIL.\n# 4. Extract the href attribute as observed_canonical.\n# 5. Compare observed_canonical to the supplied url.\n# 6. If they are identical (case\u2011sensitive), PASS; else FAIL.\n"
    },
    "pass_condition": "The page contains a <link rel=\"canonical\"> whose href exactly matches the page URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Canonical link missing or href (${observed}) does not match the page URL (${expected})."
    ],
    "references": [
      {
        "doc_title": "Enable Web Stories on Google",
        "url": "https://developers.google.com/search/docs/guides/web-stories",
        "section_title": "Check if the Web Story is indexed",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "indexing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes correct self\u2011referential canonical link.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/story.html\">\n"
      },
      "failing": {
        "description": "Canonical link points to a different URL or is missing.",
        "snippet": "<!-- Missing canonical or wrong href -->\n<link rel=\"canonical\" href=\"https://example.com/other.html\">\n"
      }
    },
    "test_cases": [
      {
        "name": "Correct canonical",
        "input_stub": {
          "html": "<html><head><link rel='canonical' href='https://example.com/story.html'></head></html>",
          "url": "https://example.com/story.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Incorrect canonical",
        "input_stub": {
          "html": "<html><head><link rel='canonical' href='https://example.com/other.html'></head></html>",
          "url": "https://example.com/story.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REQUIRED_METADATA_FIELDS",
    "title": "Required Web Story metadata fields must be present",
    "category": "Make sure the Web Story is valid AMP",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Publisher\u2011logo, poster image, title, and publisher fields are mandatory for Web Stories to be eligible for Google Search and Discover.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the Web Story page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "amp-story",
        "attribute": "publisher-logo-src",
        "notes": "URL of the publisher logo"
      },
      {
        "type": "attribute",
        "selector": "amp-story",
        "attribute": "poster-portrait-src",
        "notes": "URL of the poster image"
      },
      {
        "type": "attribute",
        "selector": "amp-story",
        "attribute": "title",
        "notes": "Title of the story"
      },
      {
        "type": "attribute",
        "selector": "amp-story",
        "attribute": "publisher",
        "notes": "Name of the publisher"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Locate the <amp-story> element.\n# 3. For each required attribute (publisher-logo-src, poster-portrait-src, title, publisher):\n#    a. Retrieve its value.\n#    b. If the attribute is missing or its value is empty, record as missing.\n# 4. If any required attribute is missing or empty, FAIL; otherwise PASS.\n"
    },
    "pass_condition": "All four required attributes (publisher-logo-src, poster-portrait-src, title, publisher) are present on the <amp-story> element and have non\u2011empty values.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing or empty required attribute(s): ${observed_missing}."
    ],
    "references": [
      {
        "doc_title": "Enable Web Stories on Google",
        "url": "https://developers.google.com/search/docs/guides/web-stories",
        "section_title": "Make sure the Web Story is valid AMP",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["metadata", "amp"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All required metadata attributes are present.",
        "snippet": "<amp-story\n  publisher=\"Example Publisher\"\n  title=\"Amazing Story\"\n  publisher-logo-src=\"https://example.com/logo.png\"\n  poster-portrait-src=\"https://example.com/poster.jpg\">\n</amp-story>\n"
      },
      "failing": {
        "description": "One or more required attributes are missing.",
        "snippet": "<amp-story\n  publisher=\"Example Publisher\"\n  title=\"Amazing Story\">\n</amp-story>\n"
      }
    },
    "test_cases": [
      {
        "name": "All attributes present",
        "input_stub": {
          "html": "<html><head></head><body>\n<amp-story publisher=\"Pub\" title=\"Title\" publisher-logo-src=\"logo.png\" poster-portrait-src=\"poster.jpg\"></amp-story>\n</body></html>\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing attributes",
        "input_stub": {
          "html": "<html><head></head><body>\n<amp-story publisher=\"Pub\" title=\"Title\"></amp-story>\n</body></html>\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_LINK_SELF",
    "title": "Web Story must have self-referential canonical link",
    "category": "SEO",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Ensures Google indexes the story correctly and avoids duplicate content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the Web Story page."
      },
      {
        "name": "url",
        "required": true,
        "description": "The canonical URL of the page being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"canonical\"]",
        "attribute": "href",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, url\n# 1. Parse the HTML document.\n# 2. Find the first <link> element where rel=\"canonical\".\n# 3. If no such element exists, set observed = null and FAIL.\n# 4. Extract the href attribute value as observed_href.\n# 5. Normalize both observed_href and url (remove trailing slash, lower\u2011case scheme/host).\n# 6. If observed_href equals normalized url, PASS; else FAIL.\n"
    },
    "pass_condition": "The canonical link href matches the page URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Canonical link not found.",
      "Canonical link href (${observed}) does not match page URL (${expected})."
    ],
    "references": [
      {
        "doc_title": "Best practices for creating Web Stories",
        "url": "https://developers.google.com/search/docs/guides/enable-web-stories",
        "section_title": "Make the story self-canonical",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["seo", "canonical", "amp"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a correct self\u2011referential canonical link.",
        "snippet": "<link rel=\"canonical\" href=\"https://www.example.com/story.html\">\n"
      },
      "failing": {
        "description": "Page missing canonical link or points to a different URL.",
        "snippet": "<!-- No canonical link present -->\n"
      }
    },
    "test_cases": [
      {
        "name": "canonical_link_correct",
        "input_stub": {
          "html": "<html><head><link rel=\"canonical\" href=\"https://www.example.com/story.html\"></head></html>",
          "url": "https://www.example.com/story.html",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "canonical_link_missing",
        "input_stub": {
          "html": "<html><head></head></html>",
          "url": "https://www.example.com/story.html",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NOINDEX_META_ABSENCE",
    "title": "Web Story must not include noindex meta tag",
    "category": "SEO",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "A noindex directive prevents Google from indexing the story, making it undiscoverable in Search.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the Web Story page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name=\"robots\"]",
        "attribute": "content",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Locate any <meta name=\"robots\"> elements.\n# 3. For each found element, read its content attribute.\n# 4. If the content contains the token \"noindex\" (case\u2011insensitive), FAIL.\n# 5. If no such token is found in any meta robots tag, PASS.\n"
    },
    "pass_condition": "No meta robots tag contains a noindex directive.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Meta robots tag contains noindex directive (${observed})."
    ],
    "references": [
      {
        "doc_title": "Best practices for creating Web Stories",
        "url": "https://developers.google.com/search/docs/guides/enable-web-stories",
        "section_title": "Make sure Google Search can find your story",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["seo", "noindex"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page does not contain a noindex meta tag.",
        "snippet": "<meta name=\"description\" content=\"A great story.\">\n"
      },
      "failing": {
        "description": "Page includes a meta robots tag with noindex.",
        "snippet": "<meta name=\"robots\" content=\"noindex, nofollow\">\n"
      }
    },
    "test_cases": [
      {
        "name": "noindex_absent",
        "input_stub": {
          "html": "<html><head><meta name=\"description\" content=\"Story\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "noindex_present",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex, nofollow\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_VALIDATION",
    "title": "Web Story must be a valid AMP page",
    "category": "Technical",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Invalid AMP pages are rejected by Google Search and cannot appear in Search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the Web Story page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "amp_validator_error_count",
        "attribute": null,
        "notes": "Number of errors reported by the AMP Validator."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Run the official AMP Validator on the HTML.\n# 2. Capture the total number of validation errors as error_count.\n# 3. If error_count == 0, PASS; otherwise FAIL.\n"
    },
    "pass_condition": "AMP validator reports zero errors.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 0,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["AMP validation failed with ${observed} errors."],
    "references": [
      {
        "doc_title": "Best practices for creating Web Stories",
        "url": "https://developers.google.com/search/docs/guides/enable-web-stories",
        "section_title": "Make the story valid",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["amp", "validation", "technical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page passes AMP validation with no errors.",
        "snippet": "<!-- Valid AMP HTML -->\n"
      },
      "failing": {
        "description": "Page fails AMP validation due to missing required AMP script.",
        "snippet": "<!-- Invalid AMP HTML -->\n"
      }
    },
    "test_cases": [
      {
        "name": "amp_valid",
        "input_stub": {
          "html": "<!doctype html><html amp><head><meta charset=\"utf-8\"><script async src=\"https://cdn.ampproject.org/v0.js\"></script></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "amp_invalid",
        "input_stub": {
          "html": "<!doctype html><html><head></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TITLE_ELEMENT_PRESENT",
    "title": "Ensure each page has a <title> element",
    "category": "Best practices for influencing title links",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google requires a <title> element to generate title links; pages without it cannot provide a proper title.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "title",
        "attribute": null,
        "notes": "Extract the content of the <title> element"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n1. Parse the html document.\n2. Locate the first <title> element using the selector \"title\".\n3. If a <title> element is found, retrieve its text content and trim whitespace.\n4. If the element is missing or the trimmed content is empty, set result to FAIL.\n5. Otherwise, set result to PASS.\n"
    },
    "pass_condition": "The page contains a non\u2011empty <title> element.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing or empty <title> element (observed: ${observed})"
    ],
    "references": [
      {
        "doc_title": "Influencing Title Links in Google Search",
        "url": "https://developers.google.com/search/docs/appearance/title-link",
        "section_title": "Best practices for influencing title links",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["title", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with a proper <title> element.",
        "snippet": "<html><head><title>Example Page</title></head><body>...</body></html>"
      },
      "failing": {
        "description": "Page missing a <title> element.",
        "snippet": "<html><head></head><body>...</body></html>"
      }
    },
    "test_cases": [
      {
        "name": "Title present and non\u2011empty",
        "input_stub": {
          "html": "<html><head><title>Test Page</title></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Title missing",
        "input_stub": {
          "html": "<html><head></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LCP_THRESHOLD",
    "title": "Largest Contentful Paint within 2.5 seconds",
    "category": "Core Web Vitals metrics",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "LCP measures loading performance; keeping it within 2.5 seconds improves user experience and aligns with Google Search recommendations.",
    "input_fields": [
      {
        "name": "lighthouse_metrics",
        "required": true,
        "description": "Metrics object containing Largest Contentful Paint value in seconds."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "largest_contentful_paint",
        "attribute": null,
        "notes": "Value in seconds."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: lighthouse_metrics.largest_contentful_paint (seconds)\n# Step 1: Retrieve LCP value.\nlcp = lighthouse_metrics.largest_contentful_paint\n# Step 2: Compare against threshold.\nif lcp <= 2.5:\n    result = \"pass\"\nelse:\n    result = \"fail\"\n"
    },
    "pass_condition": "LCP is less than or equal to 2.5 seconds.",
    "threshold": {
      "type": "number",
      "operator": "<=",
      "value": 2.5,
      "unit": "seconds",
      "notes": null
    },
    "fail_messages": [
      "LCP is ${observed}s, which exceeds the recommended maximum of 2.5s."
    ],
    "references": [
      {
        "doc_title": "Understanding Core Web Vitals and Google search results",
        "url": "https://developers.google.com/search/docs/appearance/page-experience",
        "section_title": "Core Web Vitals metrics",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["core_web_vitals", "lcp", "performance"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "LCP of 2.0 seconds.",
        "snippet": "{\"largest_contentful_paint\": 2.0}"
      },
      "failing": {
        "description": "LCP of 3.0 seconds.",
        "snippet": "{\"largest_contentful_paint\": 3.0}"
      }
    },
    "test_cases": [
      {
        "name": "LCP passes",
        "input_stub": {
          "lighthouse_metrics": {
            "largest_contentful_paint": 2.0
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "LCP fails",
        "input_stub": {
          "lighthouse_metrics": {
            "largest_contentful_paint": 3.0
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "INP_THRESHOLD",
    "title": "Interaction To Next Paint less than 200 milliseconds",
    "category": "Core Web Vitals metrics",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "INP measures responsiveness; keeping it under 200\u202fms provides a good user experience as recommended by Google.",
    "input_fields": [
      {
        "name": "lighthouse_metrics",
        "required": true,
        "description": "Metrics object containing Interaction To Next Paint value in milliseconds."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "interaction_to_next_paint",
        "attribute": null,
        "notes": "Value in milliseconds."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: lighthouse_metrics.interaction_to_next_paint (ms)\ninp = lighthouse_metrics.interaction_to_next_paint\nif inp < 200:\n    result = \"pass\"\nelse:\n    result = \"fail\"\n"
    },
    "pass_condition": "INP is less than 200 milliseconds.",
    "threshold": {
      "type": "number",
      "operator": "<",
      "value": 200,
      "unit": "milliseconds",
      "notes": null
    },
    "fail_messages": [
      "INP is ${observed}ms, which exceeds the recommended maximum of 200ms."
    ],
    "references": [
      {
        "doc_title": "Understanding Core Web Vitals and Google search results",
        "url": "https://developers.google.com/search/docs/appearance/page-experience",
        "section_title": "Core Web Vitals metrics",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["core_web_vitals", "inp", "responsiveness"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "INP of 150 milliseconds.",
        "snippet": "{\"interaction_to_next_paint\": 150}"
      },
      "failing": {
        "description": "INP of 250 milliseconds.",
        "snippet": "{\"interaction_to_next_paint\": 250}"
      }
    },
    "test_cases": [
      {
        "name": "INP passes",
        "input_stub": {
          "lighthouse_metrics": {
            "interaction_to_next_paint": 150
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "INP fails",
        "input_stub": {
          "lighthouse_metrics": {
            "interaction_to_next_paint": 250
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CLS_THRESHOLD",
    "title": "Cumulative Layout Shift less than 0.1",
    "category": "Core Web Vitals metrics",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "CLS measures visual stability; a score below 0.1 is recommended for a good user experience.",
    "input_fields": [
      {
        "name": "lighthouse_metrics",
        "required": true,
        "description": "Metrics object containing Cumulative Layout Shift value."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "cumulative_layout_shift",
        "attribute": null,
        "notes": "Unitless score."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: lighthouse_metrics.cumulative_layout_shift\ncls = lighthouse_metrics.cumulative_layout_shift\nif cls < 0.1:\n    result = \"pass\"\nelse:\n    result = \"fail\"\n"
    },
    "pass_condition": "CLS is less than 0.1.",
    "threshold": {
      "type": "number",
      "operator": "<",
      "value": 0.1,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "CLS is ${observed}, which exceeds the recommended maximum of 0.1."
    ],
    "references": [
      {
        "doc_title": "Understanding Core Web Vitals and Google search results",
        "url": "https://developers.google.com/search/docs/appearance/page-experience",
        "section_title": "Core Web Vitals metrics",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["core_web_vitals", "cls", "visual_stability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "CLS of 0.05.",
        "snippet": "{\"cumulative_layout_shift\": 0.05}"
      },
      "failing": {
        "description": "CLS of 0.15.",
        "snippet": "{\"cumulative_layout_shift\": 0.15}"
      }
    },
    "test_cases": [
      {
        "name": "CLS passes",
        "input_stub": {
          "lighthouse_metrics": {
            "cumulative_layout_shift": 0.05
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "CLS fails",
        "input_stub": {
          "lighthouse_metrics": {
            "cumulative_layout_shift": 0.15
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FULL_PAGE_INTERSTITIAL_OVERLAY_DETECTED",
    "title": "Detect full-page interstitial overlay that obscures content",
    "category": "Avoid intrusive interstitials and dialogs",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Intrusive interstitials that obscure the entire page hinder user experience and make it difficult for search engines to understand and index the underlying content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source of the page to be evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "*",
        "attribute": "style",
        "notes": "Collect inline style attributes and computed CSS properties for each element"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n1. Parse the HTML into a DOM tree.\n2. For each element in the DOM:\n   a. Compute its rendered width, height, position (fixed or absolute), top, left, right, bottom.\n   b. Determine its z-index (default 0 if not set).\n3. Identify elements where:\n   - position is fixed or absolute\n   - top <= 0, left <= 0, width >= 100% of viewport, height >= 100% of viewport\n   - z-index is greater than the z-index of the main content container (e.g., <main> or body > * with highest z-index)\n4. If any such element exists, set overlay_found = true and record its coverage percentage (observed_percentage = 100).\n5. Else, set overlay_found = false.\n"
    },
    "pass_condition": "No element that covers the full viewport and blocks underlying content is found.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": false,
      "unit": null,
      "notes": "false indicates that no full-page overlay is present"
    },
    "fail_messages": [
      "Full-page interstitial detected covering ${observed_percentage}% of the viewport."
    ],
    "references": [
      {
        "doc_title": "Avoid intrusive interstitials and dialogs",
        "url": "https://developers.google.com/search/docs/advanced/guidelines/avoid-intrusive-interstitials",
        "section_title": "Avoid intrusive interstitials and dialogs",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["interstitial", "seo", "accessibility"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with a small banner that does not cover the full viewport.",
        "snippet": "<div class='banner' style='position:fixed;top:0;width:100%;height:50px;background:#eee;'>Banner</div>"
      },
      "failing": {
        "description": "Page with a full-screen overlay that obscures all content.",
        "snippet": "<div class='overlay' style='position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:9999;'></div>"
      }
    },
    "test_cases": [
      {
        "name": "banner_without_full_overlay",
        "input_stub": {
          "html": "<html><body><div class='banner' style='position:fixed;top:0;width:100%;height:50px;background:#eee;'>Banner</div><p>Content</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "full_page_overlay_present",
        "input_stub": {
          "html": "<html><body><div class='overlay' style='position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:9999;'></div></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DECODE_HOSTNAME_CORRECTNESS",
    "title": "Decoded hostname matches original publisher hostname",
    "category": "Convert the Google Translate URL to the original URL",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Ensures that ad networks can map a Google Translate proxy URL back to the publisher\u2019s original hostname so ads render and attribute correctly, as described in the step\u2011by\u2011step decoding guide.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Google Translate proxy URL to be decoded"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url (string)\n# 1. Parse the URL, extract hostname as fullHost.\n# 2. Remove the suffix \".translate.goog\" from fullHost to obtain domainPrefix.\n# 3. If query parameter \"_x_tr_hp\" exists, prepend its value to domainPrefix.\n# 4. Split query parameter \"_x_tr_enc\" by \",\" into encodingList (empty list if absent).\n# 5. If encodingList contains \"1\" and domainPrefix starts with \"1-\", remove the leading \"1-\".\n# 6. If encodingList contains \"0\" and domainPrefix starts with \"0-\", set isIdn = true and remove the leading \"0-\"; else isIdn = false.\n# 7. Replace all occurrences of the regex /\\b-\\b/ in domainPrefix with \".\".\n# 8. Replace all occurrences of \"--\" in domainPrefix with \"-\".\n# 9. If isIdn is true, prepend \"xn--\" to the result.\n# 10. Return the resulting string as decodedHostname.\n"
    },
    "pass_condition": "Decoded hostname produced by the algorithm matches the expected original publisher hostname.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Decoded hostname ${observed} does not match expected ${expected}"
    ],
    "references": [
      {
        "doc_title": "Ad Networks & Translation Search Features",
        "url": "https://developers.google.com/search/translated-results.html",
        "section_title": "Convert the Google Translate URL to the original URL",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["ad_network", "translate", "hostname"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JavaScript decodeHostname returns the correct original hostname.",
        "snippet": "decodeHostname('https://foo--example-com.translate.goog') // returns \"foo-example.com\"\n"
      },
      "failing": {
        "description": "decodeHostname returns an incorrect hostname.",
        "snippet": "decodeHostname('https://foo--example-com.translate.goog') // returns \"foo--example.com\"\n"
      }
    },
    "test_cases": [
      {
        "name": "Simple domain",
        "input_stub": {
          "url": "https://example-com.translate.goog"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Subdomain with double hyphen",
        "input_stub": {
          "url": "https://foo--example-com.translate.goog"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "IDN with encoding 0",
        "input_stub": {
          "url": "https://0-57hw060o-com.translate.goog/?_x_tr_enc=0"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Encoding 1 prefix removal",
        "input_stub": {
          "url": "https://1-en--us-example-com/?_x_tr_enc=1"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing _x_tr_enc parameter (should still decode)",
        "input_stub": {
          "url": "https://bar-baz-com.translate.goog"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Incorrect decoding (expected fail)",
        "input_stub": {
          "url": "https://foo--example-com.translate.goog"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGE_INDEXED_NOINDEX_META",
    "title": "Noindex meta tag not present",
    "category": "Technical requirements for appearing in AI features",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Page must be indexed to be eligible for AI Overviews or AI Mode; a meta robots noindex directive prevents indexing.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Check for presence of 'noindex' token in the meta robots content"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Locate the <meta name=\"robots\"> tag.\n# 3. If the tag is not found, set observed = \"none\".\n# 4. If the tag is found, extract its content attribute.\n# 5. If the content contains the token \"noindex\" (case\u2011insensitive), set observed = \"contains_noindex\".\n# 6. Else set observed = \"no_noindex\".\n# 7. Pass if observed == \"none\" or observed == \"no_noindex\"; otherwise fail.\n"
    },
    "pass_condition": "The page does not contain a meta robots tag with a \"noindex\" directive (or the tag is absent).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page contains a 'noindex' directive in meta robots tag: ${observed}"
    ],
    "references": [
      {
        "doc_title": "AI features and your website",
        "url": "https://developers.google.com/search/blog/2023/09/ai-features-and-your-website",
        "section_title": "Technical requirements for appearing in AI features",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["indexing", "meta-robots"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page without a meta robots noindex tag.",
        "snippet": "<html>\n  <head><title>Example</title></head>\n  <body>Content here.</body>\n</html>\n"
      },
      "failing": {
        "description": "Page includes a meta robots tag with noindex.",
        "snippet": "<html>\n  <head>\n    <meta name=\"robots\" content=\"noindex, nofollow\">\n    <title>Example</title>\n  </head>\n  <body>Content here.</body>\n</html>\n"
      }
    },
    "test_cases": [
      {
        "name": "No meta robots tag",
        "input_stub": {
          "html": "<html><head><title>Test</title></head><body>Hi</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Meta robots with noindex",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex\"><title>Test</title></head><body>Hi</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ROBOTS_TXT_ALLOW_GOOGLEBOT",
    "title": "robots.txt allows crawling for Googlebot",
    "category": "SEO best practices",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "site",
    "rationale": "Allowing Googlebot to crawl ensures the site can be indexed and appear in AI Overviews or AI Mode.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "User-agent:\\s*\\*\\s*\\nDisallow:\\s*/",
        "attribute": null,
        "notes": "Detects a blanket disallow for all agents"
      },
      {
        "type": "regex",
        "selector": "User-agent:\\s*Googlebot\\s*\\nDisallow:\\s*/",
        "attribute": null,
        "notes": "Detects a disallow specifically for Googlebot"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: robots_txt\n# 1. If robots_txt contains a line \"User-agent: *\" followed by a \"Disallow: /\" (allowing whitespace), set observed = \"global_disallow\".\n# 2. Else if robots_txt contains a line \"User-agent: Googlebot\" followed by a \"Disallow: /\", set observed = \"googlebot_disallow\".\n# 3. Else set observed = \"allowed\".\n# 4. Pass if observed == \"allowed\"; otherwise fail.\n"
    },
    "pass_condition": "robots.txt does not contain a Disallow rule that blocks Googlebot (or all agents) from crawling the site.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["robots.txt blocks Googlebot crawling: ${observed}"],
    "references": [
      {
        "doc_title": "AI features and your website",
        "url": "https://developers.google.com/search/blog/2023/09/ai-features-and-your-website",
        "section_title": "SEO best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "crawling"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt does not disallow Googlebot.",
        "snippet": "User-agent: *\nDisallow:\n"
      },
      "failing": {
        "description": "robots.txt disallows all agents (including Googlebot).",
        "snippet": "User-agent: *\nDisallow: /\n"
      }
    },
    "test_cases": [
      {
        "name": "No disallow",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow:",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Global disallow",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow: /",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "API_RESPONSE_TIME",
    "title": "API response time meets availability requirements",
    "category": "Availability and responsiveness",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "The documentation requires the API to respond within 700\u202fms on average and the 95th percentile not exceeding 1\u202f000\u202fms.",
    "input_fields": [
      {
        "name": "api_response_times",
        "required": true,
        "description": "List of recent API response times in milliseconds"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "average_response_time_ms",
        "attribute": null,
        "notes": "Average response time calculated from recent calls"
      },
      {
        "type": "metric",
        "selector": "p95_response_time_ms",
        "attribute": null,
        "notes": "95th percentile response time"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: api_response_times (list of numbers)\n# Steps:\n1. Compute average_response_time_ms = sum(api_response_times) / len(api_response_times)\n2. Compute p95_response_time_ms = percentile(api_response_times, 95)\n3. If average_response_time_ms <= 700 AND p95_response_time_ms <= 1000 then PASS else FAIL\n"
    },
    "pass_condition": "Average response time \u2264\u202f700\u202fms and 95th percentile \u2264\u202f1\u202f000\u202fms.",
    "threshold": {
      "type": "number",
      "operator": "and",
      "value": null,
      "unit": "ms",
      "notes": "Both average and 95th percentile thresholds must be met."
    },
    "fail_messages": [
      "Observed average ${average_response_time_ms}\u202fms exceeds 700\u202fms or 95th percentile ${p95_response_time_ms}\u202fms exceeds 1\u202f000\u202fms."
    ],
    "references": [
      {
        "doc_title": "Package Tracking on Google",
        "url": "https://developers.google.com/search/docs/appearance/package-tracking",
        "section_title": "Availability and responsiveness",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["performance", "availability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All response times are within limits.",
        "snippet": "api_response_times: [620, 680, 710, 690, 730]  # average 686\u202fms, p95 730\u202fms\n"
      },
      "failing": {
        "description": "Average exceeds limit.",
        "snippet": "api_response_times: [800, 820, 790, 810]  # average 805\u202fms\n"
      }
    },
    "test_cases": [
      {
        "name": "average_and_p95_within_limits",
        "input_stub": {
          "api_response_times": "[650, 680, 720, 690, 710]",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "API_HTTP_METHOD",
    "title": "API accepts only POST requests",
    "category": "Requirements",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "resource",
    "rationale": "The feature makes real\u2011time calls (POST requests only) to the API.",
    "input_fields": [
      {
        "name": "http_method",
        "required": true,
        "description": "HTTP method used for the API call (e.g., GET, POST)"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "method",
        "attribute": null,
        "notes": "HTTP method of the request"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: http_method (string)\n# Steps:\n1. If http_method == \"POST\" then PASS else FAIL\n"
    },
    "pass_condition": "The HTTP method is POST.",
    "threshold": {
      "type": "string",
      "operator": "==",
      "value": "POST",
      "unit": null,
      "notes": "Must be exactly POST."
    },
    "fail_messages": ["Observed method ${http_method} is not POST."],
    "references": [
      {
        "doc_title": "Package Tracking on Google",
        "url": "https://developers.google.com/search/docs/appearance/package-tracking",
        "section_title": "Requirements",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["http", "method"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Request uses POST.",
        "snippet": "http_method: POST\n"
      },
      "failing": {
        "description": "Request uses GET.",
        "snippet": "http_method: GET\n"
      }
    },
    "test_cases": [
      {
        "name": "post_method_allowed",
        "input_stub": {
          "http_method": "POST",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "REQUIRED_FIELD_CURRENT_STATUS",
    "title": "API returns required field CurrentStatus",
    "category": "Content",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "resource",
    "rationale": "The API must return the `CurrentStatus` field for integration to work.",
    "input_fields": [
      {
        "name": "api_response_body",
        "required": true,
        "description": "JSON object returned by the API"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "field",
        "selector": "CurrentStatus",
        "attribute": null,
        "notes": "Presence of the required field in the JSON response"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: api_response_body (JSON object)\n# Steps:\n1. If \"CurrentStatus\" key exists in api_response_body then PASS else FAIL\n"
    },
    "pass_condition": "The JSON response contains the `CurrentStatus` key.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": "Presence evaluated as true/false."
    },
    "fail_messages": ["Missing required field CurrentStatus in API response."],
    "references": [
      {
        "doc_title": "Package Tracking on Google",
        "url": "https://developers.google.com/search/docs/appearance/package-tracking",
        "section_title": "Content",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["json", "required_field"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Response includes CurrentStatus.",
        "snippet": "{\n  \"CurrentStatus\": \"In Transit\",\n  \"TrackingNumber\": \"12345\"\n}\n"
      },
      "failing": {
        "description": "Response lacks CurrentStatus.",
        "snippet": "{\n  \"TrackingNumber\": \"12345\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "current_status_present",
        "input_stub": {
          "api_response_body": "{\"CurrentStatus\":\"Delivered\"}",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "COMPANY_ELIGIBILITY",
    "title": "Company eligibility based on location or authorization",
    "category": "Feature availability",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "site",
    "rationale": "Participation requires the company to be based in India, Japan, Brazil, or be the sole authorized provider for those regions.",
    "input_fields": [
      {
        "name": "company_location",
        "required": true,
        "description": "Country where the company is headquartered"
      },
      {
        "name": "sole_authorized_provider",
        "required": true,
        "description": "Boolean indicating if the company is the sole authorized provider for the target regions"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "country",
        "attribute": null,
        "notes": "Company headquarters country"
      },
      {
        "type": "attribute",
        "selector": "authorized_provider",
        "attribute": null,
        "notes": "True if sole authorized provider for the regions"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: company_location (string), sole_authorized_provider (boolean)\n# Steps:\n1. allowed_countries = [\"India\", \"Japan\", \"Brazil\"]\n2. If company_location in allowed_countries OR sole_authorized_provider == true then PASS else FAIL\n"
    },
    "pass_condition": "Company is located in India, Japan, Brazil, or is the sole authorized provider.",
    "threshold": {
      "type": "string",
      "operator": "in",
      "value": "[India, Japan, Brazil]",
      "unit": null,
      "notes": "OR authorized_provider == true"
    },
    "fail_messages": [
      "Company location ${company_location} is not eligible and not an authorized provider."
    ],
    "references": [
      {
        "doc_title": "Package Tracking on Google",
        "url": "https://developers.google.com/search/docs/appearance/package-tracking",
        "section_title": "Feature availability",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["eligibility", "geography"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Company based in Japan.",
        "snippet": "company_location: Japan\nsole_authorized_provider: false\n"
      },
      "failing": {
        "description": "Company based in Canada and not authorized.",
        "snippet": "company_location: Canada\nsole_authorized_provider: false\n"
      }
    },
    "test_cases": [
      {
        "name": "eligible_by_location",
        "input_stub": {
          "company_location": "Japan",
          "sole_authorized_provider": false,
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "RECOMMENDED_FIELDS_PRESENCE",
    "title": "Presence of recommended fields in API response",
    "category": "Content",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "resource",
    "rationale": "While not required, the API is strongly recommended to include additional fields to enhance the tracking experience.",
    "input_fields": [
      {
        "name": "api_response_body",
        "required": true,
        "description": "JSON object returned by the API"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "field",
        "selector": "DeliveredDate",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "PromisedDate",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "TrackingNumber",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "TrackingURL",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "SupportPhoneNumbers",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "TransitEvents",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "CreateDate",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "PickupDate",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "TimestampEvent",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "LocationEvent",
        "attribute": null,
        "notes": "Recommended field"
      },
      {
        "type": "field",
        "selector": "CanReschedule",
        "attribute": null,
        "notes": "Recommended field"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: api_response_body (JSON)\n# Steps:\n1. recommended = [\"DeliveredDate\",\"PromisedDate\",\"TrackingNumber\",\"TrackingURL\",\"SupportPhoneNumbers\",\"TransitEvents\",\"CreateDate\",\"PickupDate\",\"TimestampEvent\",\"LocationEvent\",\"CanReschedule\"]\n2. present = count of fields in recommended that exist in api_response_body\n3. If present > 0 then PASS else NOT_APPLICABLE\n"
    },
    "pass_condition": "At least one recommended field is present in the API response.",
    "threshold": {
      "type": "number",
      "operator": ">",
      "value": 0,
      "unit": "fields",
      "notes": "Number of recommended fields found."
    },
    "fail_messages": ["No recommended fields were found in the API response."],
    "references": [
      {
        "doc_title": "Package Tracking on Google",
        "url": "https://developers.google.com/search/docs/appearance/package-tracking",
        "section_title": "Content",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["recommendation", "optional_fields"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Response includes DeliveredDate and TrackingNumber.",
        "snippet": "{\n  \"CurrentStatus\": \"In Transit\",\n  \"DeliveredDate\": \"2023-09-01\",\n  \"TrackingNumber\": \"12345\"\n}\n"
      },
      "failing": {
        "description": "Response includes only required field.",
        "snippet": "{\n  \"CurrentStatus\": \"In Transit\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "recommended_fields_present",
        "input_stub": {
          "api_response_body": "{\"CurrentStatus\":\"In Transit\",\"DeliveredDate\":\"2023-09-01\"}",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "SITE_NAME_STRUCTURED_DATA_PRESENT",
    "title": "Presence of WebSite structured data on home page",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google uses WebSite structured data on the home page to generate the site name in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page being evaluated"
      },
      {
        "name": "url",
        "required": true,
        "description": "URL of the page (to verify it is the home page)"
      }
    ],
    "preconditions": [
      "The URL must be a domain- or subdomain-level root (e.g., https://example.com/ or https://www.example.com/)"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract JSON-LD content and verify it contains \"@type\":\"WebSite\""
      },
      {
        "type": "selector",
        "selector": "div[itemscope][itemtype=\"https://schema.org/WebSite\"]",
        "attribute": null,
        "notes": "Detect Microdata WebSite block"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Verify the URL path is '/' (home page). If not, skip this check.\n# 2. Parse the HTML.\n# 3. Search for a <script type=\"application/ld+json\"> node.\n#    a. If found, parse its JSON.\n#    b. If the JSON object has \"@type\" == \"WebSite\", mark found = true.\n# 4. If not found, search for a <div> with itemscope and itemtype=\"https://schema.org/WebSite\".\n#    a. If such element exists, mark found = true.\n# 5. Pass if found == true, else fail.\n"
    },
    "pass_condition": "WebSite structured data block is present on the home page.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["No WebSite structured data found on the home page."],
    "references": [
      {
        "doc_title": "Provide a site name to Google Search",
        "url": "https://developers.google.com/search/site-name",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "homepage"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON-LD WebSite block on the home page",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"WebSite\",\n  \"name\": \"Example\",\n  \"url\": \"https://example.com/\"\n}\n</script>\n"
      },
      "failing": {
        "description": "No WebSite block present",
        "snippet": "<html><head><title>Example</title></head><body></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "JSON-LD present",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@context\":\"https://schema.org\", \"@type\":\"WebSite\", \"name\":\"Example\", \"url\":\"https://example.com/\" }</script>",
          "url": "https://example.com/"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing WebSite",
        "input_stub": {
          "html": "<html><head><title>Example</title></head></html>",
          "url": "https://example.com/"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITE_NAME_REQUIRED_PROPERTIES",
    "title": "Required properties name and url in WebSite structured data",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Google requires the name and url properties to identify and display the site name.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the home page"
      }
    ],
    "preconditions": ["WebSite structured data block is present on the page"],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Parse JSON and extract name and url fields"
      },
      {
        "type": "attribute",
        "selector": "meta[itemprop=\"name\"]",
        "attribute": "content",
        "notes": "Microdata name value"
      },
      {
        "type": "attribute",
        "selector": "link[itemprop=\"url\"]",
        "attribute": "href",
        "notes": "Microdata url value"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Locate WebSite structured data (JSON-LD or Microdata).\n# 2. Extract the value of the \"name\" property.\n# 3. Extract the value of the \"url\" property.\n# 4. If both values exist and are non\u2011empty strings, pass; otherwise fail.\n"
    },
    "pass_condition": "Both \"name\" and \"url\" properties are present and non\u2011empty in the WebSite structured data.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property ${missing_property} in WebSite structured data."
    ],
    "references": [
      {
        "doc_title": "Provide a site name to Google Search",
        "url": "https://developers.google.com/search/site-name",
        "section_title": "Add required site name properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "required-properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both name and url present in JSON-LD",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"WebSite\",\n  \"name\":\"Example\",\n  \"url\":\"https://example.com/\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Missing url property",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"WebSite\",\n  \"name\":\"Example\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Both properties present",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"WebSite\", \"name\":\"Example\", \"url\":\"https://example.com/\" }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing url",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"WebSite\", \"name\":\"Example\" }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HOME_PAGE_CRAWLABLE",
    "title": "Home page must be crawlable by Google",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "If Google cannot access the home page, it cannot generate a site name.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers of the home page request"
      },
      {
        "name": "http_status",
        "required": true,
        "description": "HTTP status code of the home page request"
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Contents of the site's robots.txt file"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "",
        "attribute": null,
        "notes": "Status must be 200"
      },
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": "Must not contain 'noindex'"
      },
      {
        "type": "regex",
        "selector": "User-agent: \\*\\s*Disallow: /",
        "attribute": null,
        "notes": "Disallow of '/' blocks the home page"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Verify HTTP status == 200. If not, fail.\n# 2. Check X-Robots-Tag header; if it contains \"noindex\", fail.\n# 3. Parse robots.txt.\n#    If there is a rule \"User-agent: *\" followed by \"Disallow: /\", fail.\n# 4. If none of the above conditions trigger, pass.\n"
    },
    "pass_condition": "HTTP 200, no noindex header, and robots.txt does not disallow the root path.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Home page returned HTTP status ${http_status}.",
      "X-Robots-Tag header contains noindex.",
      "robots.txt disallows access to '/'"
    ],
    "references": [
      {
        "doc_title": "Provide a site name to Google Search",
        "url": "https://developers.google.com/search/site-name",
        "section_title": "The home page must be crawlable by Google",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["crawlability", "robots"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "HTTP 200, no noindex, robots.txt allows /",
        "snippet": "HTTP/1.1 200 OK\nX-Robots-Tag: index, follow\n(robots.txt does not contain Disallow: /)\n"
      },
      "failing": {
        "description": "robots.txt blocks root",
        "snippet": "User-agent: *\nDisallow: /\n"
      }
    },
    "test_cases": [
      {
        "name": "Crawlable page",
        "input_stub": {
          "http_status": 200,
          "http_headers": {
            "X-Robots-Tag": "index, follow"
          },
          "robots_txt": "User-agent: *\nDisallow: /private"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Blocked by robots.txt",
        "input_stub": {
          "http_status": 200,
          "http_headers": {
            "X-Robots-Tag": "index, follow"
          },
          "robots_txt": "User-agent: *\nDisallow: /"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITE_NAME_UNSUPPORTED_SUBDIRECTORY",
    "title": "Site name structured data not supported on subdirectory-level home pages",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google only generates site names for domain- or subdomain-level home pages, not for subdirectory-level pages.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "/",
        "attribute": null,
        "notes": "Check URL path component"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the URL.\n# 2. Extract the path component (the part after the domain, before query).\n# 3. If the path is empty or \"/\", the page is a domain/subdomain home page \u2192 pass.\n# 4. If the path contains any segment (e.g., \"/news\" or \"/index.html\"), fail.\n"
    },
    "pass_condition": "URL path is empty or '/' (indicating a domain or subdomain root).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Site name structured data placed on subdirectory page ${url} which is not supported."
    ],
    "references": [
      {
        "doc_title": "Provide a site name to Google Search",
        "url": "https://developers.google.com/search/site-name",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["url-structure", "site-name"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL is https://example.com/",
        "snippet": "https://example.com/\n"
      },
      "failing": {
        "description": "URL is https://example.com/news",
        "snippet": "https://example.com/news\n"
      }
    },
    "test_cases": [
      {
        "name": "Domain root",
        "input_stub": {
          "url": "https://example.com/"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Subdirectory page",
        "input_stub": {
          "url": "https://example.com/news"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TEXT_HEAVY_WEB_STORIES_CHECK",
    "title": "Text-heavy Web Stories character limit",
    "category": "Text-heavy Web Stories",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "resource",
    "rationale": "Pages with more than 180 characters of visible text are considered text\u2011heavy and may be ineligible for Google Discover and Search.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the Web Story, containing all amp-story-page elements."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "amp-story-page",
        "attribute": null,
        "notes": "Extract visible text content from each amp-story-page element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\npages = select_all(html, \"amp-story-page\")\ntotal_pages = count(pages)\nover_limit = 0\nfor page in pages:\n    text = extract_visible_text(page)\n    char_count = length(text)\n    if char_count > 180:\n        over_limit += 1\nratio = over_limit / total_pages\n# Pass if ratio <= 0.5 (i.e., not a majority)\n"
    },
    "pass_condition": "Less than or equal to 50% of pages have more than 180 characters of text.",
    "threshold": {
      "type": "ratio",
      "operator": "<=",
      "value": 0.5,
      "unit": null,
      "notes": "Majority means >50% of pages."
    },
    "fail_messages": [
      "Web Story has ${over_limit_percent}% of pages exceeding 180 characters, exceeding the allowed majority."
    ],
    "references": [
      {
        "doc_title": "Google Web Story Content Policies",
        "url": "https://developers.google.com/search/docs/guides/enable-web-stories",
        "section_title": "Text-heavy Web Stories",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["content", "text", "eligibility"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Story where only 2 of 5 pages exceed 180 characters.",
        "snippet": "<amp-story>...<amp-story-page>Short text</amp-story-page>...<amp-story-page>Long text exceeding 180 characters...</amp-story-page>...</amp-story>"
      },
      "failing": {
        "description": "Story where 4 of 5 pages exceed 180 characters.",
        "snippet": "<amp-story>...<amp-story-page>Long text exceeding 180 characters...</amp-story-page>... (repeated 4 times) ...</amp-story>"
      }
    },
    "test_cases": [
      {
        "name": "Pass when less than majority exceeds limit",
        "input_stub": {
          "html": "<amp-story><amp-story-page>Short</amp-story-page><amp-story-page>Long text exceeding 180 characters.........................................................</amp-story-page></amp-story>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail when majority exceeds limit",
        "input_stub": {
          "html": "<amp-story><amp-story-page>Long text exceeding 180 characters.........................................................</amp-story-page><amp-story-page>Long text exceeding 180 characters.........................................................</amp-story-page></amp-story>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMG_SRC_PRESENT",
    "title": "Ensure images are embedded using <img> with a src attribute",
    "category": "Use HTML image elements to embed images",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google can find images only in the src attribute of <img> elements; CSS background images are not indexed.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "src",
        "notes": "Collect the src attribute of each <img> element"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\nimg_elements = parse_html(html).select_all('img')\nfor img in img_elements:\n    src = img.get_attribute('src')\n    if src is null or src.trim() == \"\":\n        record_failure(img, \"Missing src attribute\")\nif any failures recorded:\n    result = \"fail\"\nelse:\n    result = \"pass\"\n"
    },
    "pass_condition": "All <img> elements have a non\u2011empty src attribute",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Image element at line ${line} is missing a src attribute"
    ],
    "references": [
      {
        "doc_title": "Google image SEO best practices",
        "url": "https://developers.google.com/search/docs/appearance/images",
        "section_title": "Use HTML image elements to embed images",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["image", "html"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "An <img> with a valid src",
        "snippet": "<img src=\"puppy.jpg\" alt=\"A golden retriever puppy\" />"
      },
      "failing": {
        "description": "An <img> without src",
        "snippet": "<img alt=\"Missing src\" />"
      }
    },
    "test_cases": [
      {
        "name": "img_with_src",
        "input_stub": {
          "html": "<html><body><img src=\"dog.jpg\" alt=\"dog\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "img_missing_src",
        "input_stub": {
          "html": "<html><body><img alt=\"no src\"></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PICTURE_FALLBACK_SRC",
    "title": "Ensure <picture> elements include an <img> fallback with src",
    "category": "Responsive images",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "The HTML standard requires an <img> fallback with src when using <picture> so browsers and crawlers can retrieve the image.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "picture",
        "attribute": null,
        "notes": "Collect each <picture> element"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\npicture_elements = parse_html(html).select_all('picture')\nfor pic in picture_elements:\n    img_fallback = pic.select('img')\n    if img_fallback is null:\n        record_failure(pic, \"Missing <img> fallback\")\n    else:\n        src = img_fallback.get_attribute('src')\n        if src is null or src.trim() == \"\":\n            record_failure(img_fallback, \"Fallback <img> missing src\")\nresult = \"fail\" if any failures else \"pass\"\n"
    },
    "pass_condition": "Every <picture> contains an <img> child with a non\u2011empty src attribute",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Picture element at line ${line} lacks an <img> fallback with src"
    ],
    "references": [
      {
        "doc_title": "Google image SEO best practices",
        "url": "https://developers.google.com/search/docs/appearance/images",
        "section_title": "Responsive images",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["picture", "responsive"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Picture with img fallback",
        "snippet": "<picture>\n  <source type=\"image/webp\" srcset=\"pyramid.webp\">\n  <img src=\"pyramid.png\" alt=\"Pyramid\">\n</picture>\n"
      },
      "failing": {
        "description": "Picture without img fallback",
        "snippet": "<picture>\n  <source type=\"image/webp\" srcset=\"pyramid.webp\">\n</picture>\n"
      }
    },
    "test_cases": [
      {
        "name": "picture_with_fallback",
        "input_stub": {
          "html": "<picture><source srcset=\"a.webp\"><img src=\"a.png\"></picture>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "picture_missing_fallback",
        "input_stub": {
          "html": "<picture><source srcset=\"b.webp\"></picture>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SUPPORTED_IMAGE_FORMAT",
    "title": "Verify image URLs use supported file formats",
    "category": "Use supported image formats",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "resource",
    "rationale": "Google indexes only images in BMP, GIF, JPEG, PNG, WebP, SVG, and AVIF formats.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML to extract image URLs"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "src",
        "notes": "Collect src URLs of all <img> elements"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\nallowed_ext = [\"bmp\",\"gif\",\"jpeg\",\"jpg\",\"png\",\"webp\",\"svg\",\"avif\"]\nimg_srcs = parse_html(html).select_all('img').map(e => e.get_attribute('src'))\nfor src in img_srcs:\n    ext = lower_case(file_extension(src))\n    if ext not in allowed_ext:\n        record_failure(src, \"Unsupported image format\")\nresult = \"fail\" if any failures else \"pass\"\n"
    },
    "pass_condition": "All image src URLs end with an allowed extension",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Image URL ${observed} uses unsupported format; allowed: BMP, GIF, JPEG, PNG, WebP, SVG, AVIF"
    ],
    "references": [
      {
        "doc_title": "Google image SEO best practices",
        "url": "https://developers.google.com/search/docs/appearance/images",
        "section_title": "Use supported image formats",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["format", "image"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JPEG image",
        "snippet": "<img src=\"cat.jpeg\" alt=\"cat\">"
      },
      "failing": {
        "description": "TIFF image (unsupported)",
        "snippet": "<img src=\"cat.tiff\" alt=\"cat\">"
      }
    },
    "test_cases": [
      {
        "name": "supported_format",
        "input_stub": {
          "html": "<img src=\"dog.png\">",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "unsupported_format",
        "input_stub": {
          "html": "<img src=\"dog.tiff\">",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "STRUCTURED_DATA_IMAGE_ATTRIBUTE",
    "title": "Ensure structured data includes required image attribute",
    "category": "Add structured data",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The image attribute is required for eligibility for badges and rich results in Google Images.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML containing JSON\u2011LD or other structured data"
      }
    ],
    "preconditions": ["Structured data block is present on the page"],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "application/ld\\+json",
        "attribute": null,
        "notes": "Extract JSON\u2011LD blocks and verify presence of \"image\" property"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\njson_ld_blocks = extract_json_ld(html)\nfor block in json_ld_blocks:\n    if block.contains_required_type():\n        if not block.has_key(\"image\"):\n            record_failure(block, \"Missing required image attribute\")\nresult = \"fail\" if any failures else \"pass\"\n"
    },
    "pass_condition": "All required structured\u2011data types on the page contain an image attribute",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Structured data block at line ${line} lacks required \"image\" attribute"
    ],
    "references": [
      {
        "doc_title": "Google image SEO best practices",
        "url": "https://developers.google.com/search/docs/appearance/images",
        "section_title": "Add structured data",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "rich-results"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Article with image property",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Article\",\n  \"headline\": \"Cute cats\",\n  \"image\": \"https://example.com/cat.jpg\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Article missing image property",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Article\",\n  \"headline\": \"Cute cats\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "structured_data_with_image",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Article\",\"image\":\"a.jpg\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "structured_data_missing_image",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Article\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMG_ALT_TEXT_PRESENT",
    "title": "Ensure <img> elements include non\u2011empty alt attribute",
    "category": "Use descriptive filenames, titles, and alt text",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Alt text provides context for Google\u2019s image understanding and improves accessibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML source"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "alt",
        "notes": "Collect alt attribute values"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\nimg_elements = parse_html(html).select_all('img')\nfor img in img_elements:\n    alt = img.get_attribute('alt')\n    if alt is null or alt.trim() == \"\":\n        record_failure(img, \"Missing or empty alt attribute\")\nresult = \"fail\" if any failures else \"pass\"\n"
    },
    "pass_condition": "Every <img> element has a non\u2011empty alt attribute",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Image at line ${line} lacks a descriptive alt attribute"
    ],
    "references": [
      {
        "doc_title": "Google image SEO best practices",
        "url": "https://developers.google.com/search/docs/appearance/images",
        "section_title": "Use descriptive filenames, titles, and alt text",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["alt", "accessibility"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Image with alt",
        "snippet": "<img src=\"puppy.jpg\" alt=\"Dalmatian puppy playing fetch\">"
      },
      "failing": {
        "description": "Image without alt",
        "snippet": "<img src=\"puppy.jpg\">"
      }
    },
    "test_cases": [
      {
        "name": "img_with_alt",
        "input_stub": {
          "html": "<img src=\"cat.jpg\" alt=\"cat\">",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "img_missing_alt",
        "input_stub": {
          "html": "<img src=\"cat.jpg\">",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DISCOVER_LARGE_IMAGE_REQUIREMENT",
    "title": "Large images must be at least 1200\u202fpx wide and enabled via max-image-preview:large",
    "category": "Content Recommendations",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Large images need to be at least 1200\u202fpx wide and enabled by the max-image-preview:large setting to increase the likelihood of appearing in Google Discover.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Content should include 'max-image-preview:large'"
      },
      {
        "type": "selector",
        "selector": "img",
        "attribute": "width",
        "notes": "Width attribute expressed in pixels"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse the HTML document.\n# 2. Find a <meta> tag where name='robots' and its content attribute contains the substring 'max-image-preview:large'.\n#    Set meta_present = true if found, else false.\n# 3. Iterate over all <img> tags.\n#    For each, read the width attribute (as integer). If width >= 1200, set large_image_found = true and break.\n#    If no width attribute or non-numeric, treat as not meeting size.\n# 4. Pass if meta_present == true AND large_image_found == true.\n"
    },
    "pass_condition": "Meta tag with max-image-preview:large is present and at least one <img> has a width attribute \u2265 1200.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required meta tag with max-image-preview:large or no image with width \u2265 1200 found."
    ],
    "references": [
      {
        "doc_title": "Discover and your website",
        "url": "https://developers.google.com/search/docs/appearance/discover",
        "section_title": "How content appears in Discover",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["discover", "image", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes required meta tag and a large image.",
        "snippet": "<html>\n  <head>\n    <meta name=\"robots\" content=\"max-image-preview:large\">\n  </head>\n  <body>\n    <img src=\"photo.jpg\" width=\"1300\" alt=\"Large photo\">\n  </body>\n</html>\n"
      },
      "failing": {
        "description": "Page missing the meta tag or large image.",
        "snippet": "<html>\n  <head>\n    <meta name=\"robots\" content=\"max-image-preview:none\">\n  </head>\n  <body>\n    <img src=\"thumb.jpg\" width=\"800\" alt=\"Small thumbnail\">\n  </body>\n</html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Passing case with meta and large image",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"max-image-preview:large\"></head>\n<body><img src=\"big.jpg\" width=\"1500\"></body></html>\n",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Failing case missing meta tag",
        "input_stub": {
          "html": "<html><head></head><body><img src=\"big.jpg\" width=\"1500\"></body></html>\n",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NOTRANSLATE_META_TAG_FORMAT",
    "title": "Correct implementation of notranslate meta tag",
    "category": "Opting out of translated results",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "To opt out of translation features, Google supports a notranslate rule that can be implemented via a meta tag; correct syntax ensures the rule is recognized by search engines.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to be inspected"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name=\"robots\"], meta[name=\"googlebot\"]",
        "attribute": "content",
        "notes": "Collect the content attribute of each matching meta tag"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse the HTML document.\n# 2. Find all <meta> elements where name attribute is \"robots\" or \"googlebot\".\n# 3. For each found element, retrieve its content attribute.\n# 4. If any content attribute is present and not exactly \"notranslate\", mark as failure.\n# 5. If no such meta tags are present, the check is not applicable.\n# 6. If all present content attributes equal \"notranslate\", the check passes.\n"
    },
    "pass_condition": "All detected notranslate meta tags have content exactly \"notranslate\"; otherwise fail. If none are present, the check is not applicable.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Meta tag with name '${name}' has content '${observed}' which does not equal 'notranslate'."
    ],
    "references": [
      {
        "doc_title": "Translated results in Google Search",
        "url": "https://developers.google.com/search/docs/appearance/translated-results",
        "section_title": "Opting in or out of translated results",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["translation", "robots", "meta"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Correct notranslate meta tag implementation",
        "snippet": "<meta name=\"robots\" content=\"notranslate\">\n<meta name=\"googlebot\" content=\"notranslate\">\n"
      },
      "failing": {
        "description": "Incorrect content value in notranslate meta tag",
        "snippet": "<meta name=\"robots\" content=\"noindex, notranslate\">\n"
      }
    },
    "test_cases": [
      {
        "name": "valid_notranslate_meta",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"notranslate\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "invalid_notranslate_meta",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex, notranslate\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ENRICHED_REQUIRED_PROPERTIES",
    "title": "Required structured data properties present",
    "category": "Enriched search quality guidelines",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Required properties are mandatory for eligibility in enriched search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [
      "Page contains a recognized enriched search type markup (JobPosting, Recipe, or Event)."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD block(s) for analysis."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block, parse JSON.\n# 3. Identify the @type value (e.g., JobPosting, Recipe, Event).\n# 4. Load the list of required properties for that @type from the official type specification.\n# 5. For each required property, check if it exists in the JSON object.\n# 6. If any required property is missing, record it as a failure.\n# 7. If all required properties are present for at least one enriched item, the check passes.\n"
    },
    "pass_condition": "All required properties for the identified enriched type are present in the structured data.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property ${property} for enriched type ${type}."
    ],
    "references": [
      {
        "doc_title": "Enriched search quality guidelines",
        "url": "https://developers.google.com/search/docs/advanced/structured-data/enriched-search",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a Recipe JSON\u2011LD block with all required fields (name, recipeIngredient, recipeInstructions, etc.).",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org/\",\n  \"@type\": \"Recipe\",\n  \"name\": \"Chicken Soup\",\n  \"recipeIngredient\": [\"chicken\", \"water\"],\n  \"recipeInstructions\": \"...\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Page includes a JobPosting JSON\u2011LD block missing the salaryCurrency property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org/\",\n  \"@type\": \"JobPosting\",\n  \"title\": \"Software Engineer\",\n  \"hiringOrganization\": { \"name\": \"Acme Corp\" }\n  // salaryCurrency missing\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Required properties present",
        "input_stub": {
          "html": "<html><head></head><body><script type='application/ld+json'>{\"@context\":\"https://schema.org/\",\"@type\":\"Recipe\",\"name\":\"Soup\",\"recipeIngredient\":[\"water\"],\"recipeInstructions\":\"...\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing required property",
        "input_stub": {
          "html": "<html><head></head><body><script type='application/ld+json'>{\"@context\":\"https://schema.org/\",\"@type\":\"JobPosting\",\"title\":\"Engineer\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ENRICHED_LEAF_PAGE",
    "title": "Page is a leaf page (not a listing page)",
    "category": "Enriched search quality guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Enriched search is only available for leaf pages that describe a single item.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [
      "Page contains a recognized enriched search type markup."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Count the number of top\u2011level enriched items in the JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. Parse each block as JSON.\n# 3. Count how many objects have @type equal to a supported enriched type (JobPosting, Recipe, Event).\n# 4. If the count is exactly 1, the page is a leaf page \u2192 pass.\n# 5. If the count is 0 or >1, the page is not a leaf page \u2192 fail.\n"
    },
    "pass_condition": "Exactly one enriched item is present in the structured data.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 1,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page contains ${count} enriched items; enriched search is only allowed on leaf pages with a single item."
    ],
    "references": [
      {
        "doc_title": "Enriched search quality guidelines",
        "url": "https://developers.google.com/search/docs/advanced/structured-data/enriched-search",
        "section_title": "Leaf content",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["leaf_page", "listing_detection"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a single Recipe JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@context\":\"https://schema.org/\", \"@type\":\"Recipe\", \"name\":\"Soup\", \"recipeIngredient\":[\"water\"] }\n</script>\n"
      },
      "failing": {
        "description": "Page includes two JobPosting JSON\u2011LD blocks, indicating a listing page.",
        "snippet": "<script type=\"application/ld+json\">{ \"@type\":\"JobPosting\", \"title\":\"Job A\" }</script>\n<script type=\"application/ld+json\">{ \"@type\":\"JobPosting\", \"title\":\"Job B\" }</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Single enriched item (leaf)",
        "input_stub": {
          "html": "<html><body><script type='application/ld+json'>{\"@context\":\"https://schema.org/\",\"@type\":\"Recipe\",\"name\":\"Soup\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Multiple enriched items (listing)",
        "input_stub": {
          "html": "<html><body><script type='application/ld+json'>{\"@type\":\"JobPosting\",\"title\":\"A\"}</script><script type='application/ld+json'>{\"@type\":\"JobPosting\",\"title\":\"B\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ENRICHED_RELEVANT_DATA",
    "title": "Structured data relevance to page content",
    "category": "Enriched search quality guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Marked\u2011up data must be relevant to the enriched search type to avoid spam and ensure proper indexing.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [
      "Page contains a recognized enriched search type markup."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "title",
        "attribute": null,
        "notes": "Page title text."
      },
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract @type from JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract page <title> text and normalize to lowercase.\n# 2. Extract @type from the first enriched JSON\u2011LD block.\n# 3. Define a simple relevance map:\n#    - Recipe  -> keywords: [\"recipe\", \"cook\", \"ingredients\", \"meal\"]\n#    - JobPosting -> keywords: [\"job\", \"career\", \"position\", \"hiring\"]\n#    - Event   -> keywords: [\"event\", \"concert\", \"festival\", \"schedule\"]\n# 4. If any keyword from the map for the detected @type appears in the title, consider the data relevant.\n# 5. Otherwise, mark as irrelevant \u2192 fail.\n"
    },
    "pass_condition": "The page title contains at least one keyword associated with the detected enriched type.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Structured data type ${type} appears irrelevant to page title \"${title}\"."
    ],
    "references": [
      {
        "doc_title": "Enriched search quality guidelines",
        "url": "https://developers.google.com/search/docs/advanced/structured-data/enriched-search",
        "section_title": "Relevance",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["relevance", "spam_policy"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "A Recipe page with title \"Easy Chicken Soup Recipe\".",
        "snippet": "<title>Easy Chicken Soup Recipe</title>\n<script type=\"application/ld+json\">{ \"@type\":\"Recipe\", \"name\":\"Chicken Soup\" }</script>\n"
      },
      "failing": {
        "description": "An Event JSON\u2011LD on a page titled \"Live Sports Streaming\".",
        "snippet": "<title>Live Sports Streaming</title>\n<script type=\"application/ld+json\">{ \"@type\":\"Event\", \"name\":\"Football Match\" }</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Relevant data",
        "input_stub": {
          "html": "<html><head><title>Delicious Pancake Recipe</title></head><body><script type='application/ld+json'>{\"@type\":\"Recipe\",\"name\":\"Pancake\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Irrelevant data",
        "input_stub": {
          "html": "<html><head><title>Latest Tech News</title></head><body><script type='application/ld+json'>{\"@type\":\"JobPosting\",\"title\":\"Engineer\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BLOCK_ALL_SNIPPETS_NOSNIPPET_META",
    "title": "Presence of nosnippet meta tag to block all snippets",
    "category": "Opt-out from featured snippets",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Adding the `nosnippet` rule to a page prevents both featured and regular snippets from appearing, as described in the documentation.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='robots'][content~='nosnippet']",
        "attribute": null,
        "notes": "Check meta robots tag for nosnippet directive"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse the HTML document.\n# 2. Search for a <meta> element where name=\"robots\" and the content attribute contains the token \"nosnippet\".\n# 3. If such an element exists, set observed = true else observed = false.\n"
    },
    "pass_condition": "Page contains a meta robots tag with `nosnippet` in its content attribute.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No `nosnippet` meta tag found; page may appear in snippets."
    ],
    "references": [
      {
        "doc_title": "Featured snippets and your website",
        "url": "https://developers.google.com/search/docs/appearance/featured-snippets",
        "section_title": "Block all snippets",
        "line_range": null,
        "anchor": "#block-both"
      }
    ],
    "tags": ["featured_snippet", "nosnippet"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Meta tag with nosnippet present",
        "snippet": "<meta name=\"robots\" content=\"nosnippet\">"
      },
      "failing": {
        "description": "No meta tag with nosnippet",
        "snippet": "<meta name=\"robots\" content=\"index,follow\">"
      }
    },
    "test_cases": [
      {
        "name": "nosnippet present",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"nosnippet\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "nosnippet absent",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"index,follow\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BLOCK_ALL_SNIPPETS_DATA_NOSNIPPET_ATTR",
    "title": "Presence of data-nosnippet attribute to block snippet content",
    "category": "Opt-out from featured snippets",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Elements with `data-nosnippet` attribute are excluded from featured and regular snippets per documentation.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "[data-nosnippet]",
        "attribute": null,
        "notes": "Any element with data-nosnippet attribute"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse the HTML document.\n# 2. Search for any element that has an attribute named \"data-nosnippet\".\n# 3. If at least one such element exists, set observed = true else observed = false.\n"
    },
    "pass_condition": "At least one element in the page has the `data-nosnippet` attribute.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No element with `data-nosnippet` attribute found; content may be used in snippets."
    ],
    "references": [
      {
        "doc_title": "Featured snippets and your website",
        "url": "https://developers.google.com/search/docs/appearance/featured-snippets",
        "section_title": "Block all snippets",
        "line_range": null,
        "anchor": "#block-both"
      }
    ],
    "tags": ["featured_snippet", "data-nosnippet"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Element with data-nosnippet attribute present",
        "snippet": "<p data-nosnippet>This paragraph will not appear in snippets.</p>"
      },
      "failing": {
        "description": "No data-nosnippet attribute in the page",
        "snippet": "<p>This paragraph may appear in snippets.</p>"
      }
    },
    "test_cases": [
      {
        "name": "data-nosnippet present",
        "input_stub": {
          "html": "<html><body><div data-nosnippet>Hidden from snippets</div></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "data-nosnippet absent",
        "input_stub": {
          "html": "<html><body><div>Visible to snippets</div></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BLOCK_FEATURED_SNIPPETS_MAX_SNIPPET",
    "title": "Use of max-snippet rule to limit snippet length",
    "category": "Opt-out from featured snippets",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Setting a lower `max-snippet` value reduces the likelihood of appearing in featured snippets, as described in the documentation.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='robots'][content~='max-snippet']",
        "attribute": null,
        "notes": "Meta robots tag containing max-snippet directive"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse the HTML document.\n# 2. Locate a <meta> element where name=\"robots\" and the content attribute contains the token \"max-snippet\".\n# 3. If such an element exists, extract the numeric value following \"max-snippet:\" (e.g., max-snippet:50).\n# 4. Set observed = true if the directive is present, otherwise false.\n"
    },
    "pass_condition": "Page includes a meta robots tag with a `max-snippet` directive.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No `max-snippet` directive found; page may appear in featured snippets."
    ],
    "references": [
      {
        "doc_title": "Featured snippets and your website",
        "url": "https://developers.google.com/search/docs/appearance/featured-snippets",
        "section_title": "Block featured snippets only",
        "line_range": null,
        "anchor": "#block-fs"
      }
    ],
    "tags": ["featured_snippet", "max-snippet"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Meta tag with max-snippet directive present",
        "snippet": "<meta name=\"robots\" content=\"max-snippet:50\">"
      },
      "failing": {
        "description": "No max-snippet directive in meta tags",
        "snippet": "<meta name=\"robots\" content=\"index,follow\">"
      }
    },
    "test_cases": [
      {
        "name": "max-snippet present",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"max-snippet:30\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "max-snippet absent",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"index,follow\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ORG_LOGO_PRESENT",
    "title": "Organization structured data includes logo",
    "category": "Add structured data",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "The guide advises adding Organization structured data that identifies the location of the preferred logo so Google can use it in search results and the knowledge panel.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to be evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "<script[^>]*type=[\"']application/ld\\+json[\"'][^>]*>(.*?)</script>",
        "attribute": null,
        "notes": "Capture JSON-LD blocks and search for \"@type\":\"Organization\" with a \"logo\" property"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Find all <script type=\"application/ld+json\"> blocks using the regex selector.\n# 2. For each block, parse the JSON content.\n# 3. If a JSON object (or any object in @graph) has \"@type\" == \"Organization\":\n#    a. Check if the object contains a \"logo\" key with a non\u2011empty string value.\n#    b. If found, set result = pass.\n# 4. If no such Organization object with logo is found, set result = fail.\n"
    },
    "pass_condition": "Organization structured data with a non\u2011empty logo property is present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No Organization structured data with a logo property was detected in the page."
    ],
    "references": [
      {
        "doc_title": "Add Business Details to Google",
        "url": "https://developers.google.com/search/docs/appearance/add-business-details",
        "section_title": "Add structured data",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "logo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains Organization JSON\u2011LD with a logo URL.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Organization\",\n  \"url\": \"https://example.com\",\n  \"logo\": \"https://example.com/logo.png\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Page lacks Organization JSON\u2011LD or the logo field.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Organization\",\n  \"url\": \"https://example.com\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Organization with logo present",
        "input_stub": {
          "html": "<html><head></head><body><script type=\"application/ld+json\">{ \"@type\": \"Organization\", \"logo\": \"https://example.com/logo.png\" }</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Organization without logo",
        "input_stub": {
          "html": "<html><head></head><body><script type=\"application/ld+json\">{ \"@type\": \"Organization\" }</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BREADCRUMB_STRUCTURED_DATA_PRESENT",
    "title": "Breadcrumb structured data is included",
    "category": "Add structured data",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "The documentation recommends adding Breadcrumb structured data so Google can understand page hierarchy and display breadcrumb trails in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to be evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "<script[^>]*type=[\"']application/ld\\+json[\"'][^>]*>(.*?)</script>",
        "attribute": null,
        "notes": "Search captured JSON-LD for \"@type\":\"BreadcrumbList\""
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all JSON-LD script blocks using the regex selector.\n# 2. Parse each block as JSON.\n# 3. If any object (or any object in @graph) has \"@type\" == \"BreadcrumbList\":\n#    set result = pass.\n# 4. If no such object is found, set result = fail.\n"
    },
    "pass_condition": "At least one BreadcrumbList structured data block is present on the page.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Breadcrumb structured data (BreadcrumbList) was not found in the page."
    ],
    "references": [
      {
        "doc_title": "Add Business Details to Google",
        "url": "https://developers.google.com/search/docs/appearance/add-business-details",
        "section_title": "Add structured data",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "breadcrumb"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes BreadcrumbList JSON\u2011LD.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"BreadcrumbList\",\n  \"itemListElement\": [\n    {\n      \"@type\": \"ListItem\",\n      \"position\": 1,\n      \"name\": \"Home\",\n      \"item\": \"https://example.com/\"\n    },\n    {\n      \"@type\": \"ListItem\",\n      \"position\": 2,\n      \"name\": \"Products\",\n      \"item\": \"https://example.com/products\"\n    }\n  ]\n}\n</script>\n"
      },
      "failing": {
        "description": "Page does not contain BreadcrumbList structured data.",
        "snippet": "<p>No breadcrumb markup present.</p>\n"
      }
    },
    "test_cases": [
      {
        "name": "BreadcrumbList present",
        "input_stub": {
          "html": "<html><body><script type=\"application/ld+json\">{ \"@type\": \"BreadcrumbList\", \"itemListElement\": [] }</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "BreadcrumbList absent",
        "input_stub": {
          "html": "<html><body><p>No structured data here.</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "WATCH_PAGE_INDEXED",
    "title": "Watch page must be indexed",
    "category": "Ensure your videos can be indexed",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "A watch page must be indexed before its video can be considered for indexing and appear in video results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the watch page."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers including status code."
      }
    ],
    "preconditions": [
      "Page contains a video element (<video>, <iframe>, <embed>, or <object>)"
    ],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "",
        "attribute": null,
        "notes": "HTTP status code of the watch page request"
      },
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Meta robots tag content"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Verify HTTP status is 200.\nif http_headers.status != 200:\n    fail\n# 2. Parse html for <meta name=\"robots\"> tag.\nrobots_content = select(html, \"meta[name='robots']\").attr(\"content\")\n# 3. If meta tag exists and contains \"noindex\", fail.\nif robots_content and \"noindex\" in robots_content.lower():\n    fail\n# 4. Otherwise, pass.\npass\n"
    },
    "pass_condition": "HTTP status is 200 and no meta robots tag contains \"noindex\".",
    "threshold": null,
    "fail_messages": [
      "Watch page returned HTTP status ${observed_status} (expected 200).",
      "Watch page contains meta robots directive '${observed_content}' which includes 'noindex'."
    ],
    "references": [
      {
        "doc_title": "Video SEO best practices",
        "url": "https://developers.google.com/search/docs/advanced/video",
        "section_title": "Ensure your videos can be indexed",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["indexing", "video", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page returns 200 and has no noindex meta tag.",
        "snippet": "HTTP/1.1 200 OK\n<html>\n  <head></head>\n  <body><video src=\"movie.mp4\"></video></body>\n</html>\n"
      },
      "failing": {
        "description": "Page returns 404.",
        "snippet": "HTTP/1.1 404 Not Found\n<html><head></head><body>Not found</body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass when indexed and no noindex",
        "input_stub": {
          "html": "<html><head></head><body><video src='v.mp4'></video></body></html>",
          "http_headers": {
            "status": 200
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail on 404 status",
        "input_stub": {
          "html": "<html><head></head><body>Missing</body></html>",
          "http_headers": {
            "status": 404
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VIDEO_EMBEDDED_ON_WATCH_PAGE",
    "title": "Video must be embedded on watch page",
    "category": "Ensure your videos can be indexed",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "A video must be present on its watch page for Google to discover and index it.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the watch page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "video, iframe, embed, object",
        "attribute": "src",
        "notes": "Source URL of embedded video elements"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Search HTML for any of the allowed embedding tags.\nembeds = select_all(html, \"video, iframe, embed, object\")\n# 2. If at least one embed with a non\u2011empty src attribute exists, pass.\nfor e in embeds:\n    src = e.attr(\"src\")\n    if src and src.strip() != \"\":\n        pass\n# 3. If none found, fail.\nfail\n"
    },
    "pass_condition": "At least one <video>, <iframe>, <embed>, or <object> element with a non\u2011empty src attribute is present.",
    "threshold": null,
    "fail_messages": [
      "No video embedding element with a src attribute was found on the page."
    ],
    "references": [
      {
        "doc_title": "Video SEO best practices",
        "url": "https://developers.google.com/search/docs/advanced/video",
        "section_title": "Ensure your videos can be indexed",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["embedding", "video"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a <video> tag with src.",
        "snippet": "<html><body><video src=\"movie.mp4\"></video></body></html>\n"
      },
      "failing": {
        "description": "Page has no embedding tags.",
        "snippet": "<html><body><p>No video here.</p></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with video tag",
        "input_stub": {
          "html": "<html><body><video src='v.mp4'></video></body></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail with no embed",
        "input_stub": {
          "html": "<html><body><p>Text only</p></body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VALID_THUMBNAIL_PRESENT",
    "title": "Video must have a valid thumbnail URL",
    "category": "Ensure your videos can be indexed",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "resource",
    "rationale": "A valid thumbnail is required for a video to appear in rich results and other video features.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the watch page (including structured data scripts)."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[property='og:video:image']",
        "attribute": "content",
        "notes": "Open Graph thumbnail URL"
      },
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "JSON\u2011LD VideoObject thumbnailUrl property"
      },
      {
        "type": "selector",
        "selector": "video[poster]",
        "attribute": "poster",
        "notes": "HTML5 video poster attribute"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Check for Open Graph thumbnail.\nog = select(html, \"meta[property='og:video:image']\").attr(\"content\")\nif og and og.strip() != \"\":\n    pass\n# 2. Check for JSON\u2011LD VideoObject thumbnailUrl.\njson_ld = select_all(html, \"script[type='application/ld+json']\")\nfor s in json_ld:\n    data = parse_json(s.text)\n    if data[\"@type\"] == \"VideoObject\" and data.get(\"thumbnailUrl\"):\n        pass\n# 3. Check for <video poster>.\nposter = select(html, \"video[poster]\").attr(\"poster\")\nif poster and poster.strip() != \"\":\n    pass\n# 4. If none found, fail.\nfail\n"
    },
    "pass_condition": "At least one thumbnail URL is found via Open Graph, JSON\u2011LD VideoObject, or video poster attribute.",
    "threshold": null,
    "fail_messages": [
      "No thumbnail URL detected in Open Graph, JSON\u2011LD, or video poster attribute."
    ],
    "references": [
      {
        "doc_title": "Video SEO best practices",
        "url": "https://developers.google.com/search/docs/advanced/video",
        "section_title": "Provide a high-quality video thumbnail",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["thumbnail", "video"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes og:video:image meta tag.",
        "snippet": "<meta property=\"og:video:image\" content=\"https://example.com/thumb.jpg\">\n"
      },
      "failing": {
        "description": "No thumbnail metadata present.",
        "snippet": "<html><body><video src=\"v.mp4\"></video></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with Open Graph thumbnail",
        "input_stub": {
          "html": "<meta property='og:video:image' content='https://example.com/thumb.jpg'>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail with no thumbnail",
        "input_stub": {
          "html": "<html><body><video src='v.mp4'></video></body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SUPPORTED_VIDEO_FILE_TYPE",
    "title": "Video file must be of a supported type",
    "category": "Ensure your videos can be indexed",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Only supported video file formats can be processed and indexed by Google.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the watch page containing video embed tags."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "video[src], iframe[src], embed[src], object[data]",
        "attribute": "src",
        "notes": "URL of the video file"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Gather all possible video source URLs.\nsources = []\nfor el in select_all(html, \"video[src], iframe[src], embed[src], object[data]\"):\n    url = el.attr(\"src\") or el.attr(\"data\")\n    if url:\n        sources.append(url.lower())\n# 2. Define allowed extensions.\nallowed = [\"3gp\",\"3g2\",\"asf\",\"avi\",\"divx\",\"m2v\",\"m3u\",\"m3u8\",\"m4v\",\"mkv\",\"mov\",\"mp4\",\"mpeg\",\"ogv\",\"qvt\",\"ram\",\"rm\",\"vob\",\"webm\",\"wmv\",\"xap\"]\n# 3. Verify each source ends with an allowed extension.\nfor u in sources:\n    if any(u.endswith('.' + ext) for ext in allowed):\n        pass\n    else:\n        fail\n# 4. If no sources found, fail.\nif not sources:\n    fail\n"
    },
    "pass_condition": "All discovered video source URLs end with an allowed file extension.",
    "threshold": null,
    "fail_messages": [
      "Video source URL '${observed}' does not use a supported file extension.",
      "No video source URL found on the page."
    ],
    "references": [
      {
        "doc_title": "Video SEO best practices",
        "url": "https://developers.google.com/search/docs/advanced/video",
        "section_title": "Use a supported video file type",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["filetype", "video"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Video tag with .mp4 source.",
        "snippet": "<video src=\"https://example.com/movie.mp4\"></video>\n"
      },
      "failing": {
        "description": "Video tag with unsupported .flv source.",
        "snippet": "<video src=\"https://example.com/movie.flv\"></video>\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with supported extension",
        "input_stub": {
          "html": "<video src='https://example.com/clip.mp4'></video>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail with unsupported extension",
        "input_stub": {
          "html": "<video src='https://example.com/clip.flv'></video>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "UNIQUE_PAGINATED_URLS",
    "title": "Each paginated page must have a unique URL",
    "category": "General URL recommendations",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Duplicate URLs in pagination cause Google to miss content or waste crawl budget.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      },
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[rel=next], a[rel=prev]",
        "attribute": "href",
        "notes": "Collect pagination link URLs from rel=next and rel=prev anchors"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, url\n# 1. Parse html and extract href values of <a> elements with rel=next or rel=prev.\n# 2. Normalize extracted URLs (remove trailing slash, resolve relative to page URL).\n# 3. If any extracted URL equals the page's own url, then FAIL (duplicate pagination URL).\n# 4. Otherwise PASS.\n"
    },
    "pass_condition": "No pagination link points to the same URL as the current page.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Duplicate pagination URL detected: ${observed} matches the page URL."
    ],
    "references": [
      {
        "doc_title": "Ecommerce URL Structure Best Practices",
        "url": "https://developers.google.com/search/docs/ecommerce-url-structure",
        "section_title": "General URL recommendations",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["pagination", "url-uniqueness"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with distinct next/prev URLs.",
        "snippet": "<a rel=\"prev\" href=\"/category/page/1\">Prev</a> <a rel=\"next\" href=\"/category/page/3\">Next</a>"
      },
      "failing": {
        "description": "Page where next link points to the same URL.",
        "snippet": "<a rel=\"next\" href=\"/category/page/2\">Next</a>"
      }
    },
    "test_cases": [
      {
        "name": "Unique pagination URLs",
        "input_stub": {
          "html": "<a rel=\"prev\" href=\"/cat/page/1\"></a><a rel=\"next\" href=\"/cat/page/3\"></a>",
          "url": "https://example.com/cat/page/2",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Duplicate pagination URL",
        "input_stub": {
          "html": "<a rel=\"next\" href=\"/cat/page/2\"></a>",
          "url": "https://example.com/cat/page/2",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NO_FRAGMENT_IDENTIFIERS_FOR_CONTENT",
    "title": "URLs must not rely on fragment identifiers to differentiate content",
    "category": "Why URL structure matters",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Google ignores fragment identifiers when indexing, so content differentiated only by fragments may be missed.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": null,
        "attribute": null,
        "notes": "Detect presence of a '#' character in the URL"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url\n# 1. If url contains the character '#', then FAIL.\n# 2. Otherwise PASS.\n"
    },
    "pass_condition": "URL does not contain a fragment identifier ('#').",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "URL contains fragment identifier '#${fragment}' which Google ignores for indexing."
    ],
    "references": [
      {
        "doc_title": "Ecommerce URL Structure Best Practices",
        "url": "https://developers.google.com/search/docs/ecommerce-url-structure",
        "section_title": "Why URL structure matters",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["fragment", "indexing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL without fragment.",
        "snippet": "https://example.com/product/t-shirt"
      },
      "failing": {
        "description": "URL using fragment to indicate color.",
        "snippet": "https://example.com/product/t-shirt#black"
      }
    },
    "test_cases": [
      {
        "name": "URL without fragment",
        "input_stub": {
          "url": "https://example.com/product/t-shirt",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "URL with fragment",
        "input_stub": {
          "url": "https://example.com/product/t-shirt#black",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CONSISTENT_QUERY_PARAMETER_FORMAT",
    "title": "Query parameters should use key=value format",
    "category": "URL query parameter recommendations",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Using key=value lets Google understand site structure and crawl efficiently.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": null,
        "attribute": null,
        "notes": "Extract each query parameter and verify it contains an '=' character"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url\n# 1. Parse the query string (portion after '?').\n# 2. Split the query string on '&' to get individual parameters.\n# 3. For each parameter, if it does not contain '=', then FAIL and record the parameter.\n# 4. If all parameters contain '=', PASS.\n"
    },
    "pass_condition": "Every query parameter in the URL follows the key=value pattern.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Query parameter '${param}' lacks key=value format."],
    "references": [
      {
        "doc_title": "Ecommerce URL Structure Best Practices",
        "url": "https://developers.google.com/search/docs/ecommerce-url-structure",
        "section_title": "URL query parameter recommendations",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["query-parameters", "format"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Proper key=value parameters.",
        "snippet": "https://example.com/t-shirt?color=green&size=m"
      },
      "failing": {
        "description": "Parameter without key.",
        "snippet": "https://example.com/t-shirt?green"
      }
    },
    "test_cases": [
      {
        "name": "Proper query parameters",
        "input_stub": {
          "url": "https://example.com/t-shirt?color=green&size=m",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing key in query parameter",
        "input_stub": {
          "url": "https://example.com/t-shirt?green",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SELF_REFERENCING_CANONICAL_TAG",
    "title": "Pages must include a self-referencing canonical link tag",
    "category": "Using URLs in your content",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "A self-referencing canonical tag helps Google consolidate duplicate URLs and understand the preferred version.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      },
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the page being evaluated"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=canonical]",
        "attribute": "href",
        "notes": "Canonical URL declared in the page"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, url\n# 1. Parse html and locate <link rel=\"canonical\"> element.\n# 2. If no such element exists, FAIL.\n# 3. Extract its href attribute and normalize (resolve relative URLs).\n# 4. If extracted href does not exactly match the page's own url, FAIL.\n# 5. Otherwise PASS.\n"
    },
    "pass_condition": "A <link rel=\"canonical\"> tag exists and its href equals the page URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing or mismatched self-referencing canonical tag (found '${observed}', expected '${expected}')."
    ],
    "references": [
      {
        "doc_title": "Ecommerce URL Structure Best Practices",
        "url": "https://developers.google.com/search/docs/ecommerce-url-structure",
        "section_title": "Using URLs in your content",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "duplicate-content"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with correct self-referencing canonical.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/product/t-shirt\">"
      },
      "failing": {
        "description": "Missing canonical tag.",
        "snippet": "<!-- no canonical tag -->"
      }
    },
    "test_cases": [
      {
        "name": "Correct self-referencing canonical",
        "input_stub": {
          "html": "<head><link rel=\"canonical\" href=\"https://example.com/product/t-shirt\"></head>",
          "url": "https://example.com/product/t-shirt",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing canonical tag",
        "input_stub": {
          "html": "<head></head>",
          "url": "https://example.com/product/t-shirt",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "EVIDENCE_PRESENT",
    "title": "Presence of personal experience evidence",
    "category": "Write high quality reviews",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Provide evidence such as visuals, audio, or other links of your own experience with what you are reviewing, to support expertise and reinforce authenticity.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the review page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img, audio, a[href]",
        "attribute": null,
        "notes": "Collect all image, audio, and anchor elements that could serve as evidence."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Parse html into a DOM.\n# 2. Select all elements matching \"img, audio, a[href]\".\n# 3. Count the number of selected elements.\n# 4. Set evidence_count = count.\n"
    },
    "pass_condition": "At least one evidence element (image, audio, or link) is present on the page.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": null,
      "notes": "Minimum of one evidence element required."
    },
    "fail_messages": [
      "No visual, audio, or personal experience link found (observed ${observed} elements)."
    ],
    "references": [
      {
        "doc_title": "Write high quality reviews",
        "url": "https://developers.google.com/search/docs/appearance/review-snippet",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["content", "evidence"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes an image showing the product.",
        "snippet": "<img src='product.jpg' alt='Product photo'>"
      },
      "failing": {
        "description": "Page contains only text with no media or external links.",
        "snippet": "<p>This is a great product.</p>"
      }
    },
    "test_cases": [
      {
        "name": "Evidence present",
        "input_stub": {
          "html": "<html><body><img src='a.jpg'></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "No evidence",
        "input_stub": {
          "html": "<html><body><p>Great product.</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUANTITATIVE_MEASUREMENTS_PRESENT",
    "title": "Presence of quantitative measurements",
    "category": "Write high quality reviews",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Share quantitative measurements about how something measures up in various categories of performance.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the review page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "html",
        "attribute": null,
        "notes": "Matches numbers possibly followed by units or rating symbols."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Search html text for regex pattern /\\b\\d+(\\.\\d+)?\\s*(%|stars?|\\/10|\\/5|points?)\\b/i.\n# 2. Count matches as quantitative_count.\n"
    },
    "pass_condition": "At least one quantitative measurement (numeric value with a unit or rating) is found in the content.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": null,
      "notes": "Minimum of one quantitative measurement required."
    },
    "fail_messages": [
      "No quantitative measurements detected (observed ${observed} matches)."
    ],
    "references": [
      {
        "doc_title": "Write high quality reviews",
        "url": "https://developers.google.com/search/docs/appearance/review-snippet",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["content", "measurement"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Review includes a rating like \"4.5 out of 5 stars\".",
        "snippet": "<p>We give it 4.5 out of 5 stars.</p>"
      },
      "failing": {
        "description": "Review contains only descriptive text with no numbers.",
        "snippet": "<p>The product feels solid and well-built.</p>"
      }
    },
    "test_cases": [
      {
        "name": "Quantitative present",
        "input_stub": {
          "html": "<html><body><p>Score: 8/10.</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "No quantitative",
        "input_stub": {
          "html": "<html><body><p>Excellent build quality.</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "EXTERNAL_RESOURCE_LINKS_PRESENT",
    "title": "Inclusion of links to other useful resources",
    "category": "Write high quality reviews",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Include links to other useful resources (your own or from other sites) to help a reader make a decision.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the review page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href]",
        "attribute": "href",
        "notes": "Collect all anchor href values."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# Steps:\n# 1. Parse html and select all <a> elements with href.\n# 2. Extract href values.\n# 3. Filter out links that are internal (same domain as the page URL, if known) \u2013 assume all are external for this check.\n# 4. Count distinct href values as external_link_count.\n"
    },
    "pass_condition": "At least one external link to another resource is present on the page.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": null,
      "notes": "Minimum of one external resource link required."
    },
    "fail_messages": [
      "No external resource links found (observed ${observed} links)."
    ],
    "references": [
      {
        "doc_title": "Write high quality reviews",
        "url": "https://developers.google.com/search/docs/appearance/review-snippet",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["content", "linking"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Review includes a link to a detailed spec page.",
        "snippet": "<a href='https://example.com/specs'>Full specifications</a>"
      },
      "failing": {
        "description": "Review contains no outbound links.",
        "snippet": "<p>Read more in the article above.</p>"
      }
    },
    "test_cases": [
      {
        "name": "External link present",
        "input_stub": {
          "html": "<html><body><a href='https://external.com/info'>Info</a></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "No external links",
        "input_stub": {
          "html": "<html><body><p>No links here.</p></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LOCAL_BUSINESS_STRUCTURED_DATA_PRESENT",
    "title": "Presence of LocalBusiness structured data",
    "category": "LocalBusiness",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "LocalBusiness structured data helps Google understand physical store information such as location and opening hours.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks from the page"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and select all <script type=\"application/ld+json\"> elements.\n# 2. For each selected element, parse its text content as JSON.\n# 3. If any parsed JSON object (or object within an array) has \"@type\" == \"LocalBusiness\", set found = true.\n# 4. Return found.\n"
    },
    "pass_condition": "At least one JSON-LD block contains \"@type\" equal to \"LocalBusiness\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["No LocalBusiness structured data found in the page."],
    "references": [
      {
        "doc_title": "Structured Data for Ecommerce Sites",
        "url": "https://developers.google.com/search/docs/structured-data/ecommerce",
        "section_title": "LocalBusiness",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "localbusiness", "ecommerce"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a LocalBusiness JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"LocalBusiness\",\n  \"name\": \"My Store\",\n  \"address\": { \"streetAddress\": \"123 Main St\", \"addressLocality\": \"City\", \"postalCode\": \"12345\", \"addressCountry\": \"US\" },\n  \"openingHours\": \"Mo-Fr 09:00-17:00\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Page lacks any LocalBusiness JSON\u2011LD.",
        "snippet": "<html><head></head><body><p>Welcome to our site.</p></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "LocalBusiness present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"LocalBusiness\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "LocalBusiness absent",
        "input_stub": {
          "html": "<p>No structured data here.</p>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ORGANIZATION_STRUCTURED_DATA_PRESENT",
    "title": "Presence of Organization structured data",
    "category": "Organization",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Organization structured data conveys business details such as logo, contact information, and identifiers to Google.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Select all <script type=\"application/ld+json\"> elements.\n# 2. Parse each element's text as JSON.\n# 3. If any JSON object (or object in an array) has \"@type\" == \"Organization\", set found = true.\n# 4. Return found.\n"
    },
    "pass_condition": "At least one JSON-LD block contains \"@type\" equal to \"Organization\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Organization structured data not detected on the page."],
    "references": [
      {
        "doc_title": "Structured Data for Ecommerce Sites",
        "url": "https://developers.google.com/search/docs/structured-data/ecommerce",
        "section_title": "Organization",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "organization", "ecommerce"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes an Organization JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Organization\",\n  \"name\": \"Acme Corp\",\n  \"url\": \"https://www.acme.com\",\n  \"logo\": \"https://www.acme.com/logo.png\",\n  \"contactPoint\": [{ \"telephone\": \"+1-800-555-1212\", \"contactType\": \"Customer service\" }]\n}\n</script>\n"
      },
      "failing": {
        "description": "No Organization JSON\u2011LD present.",
        "snippet": "<html><body><p>About us content without structured data.</p></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Organization present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Organization\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Organization absent",
        "input_stub": {
          "html": "<p>Plain page.</p>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PRODUCT_STRUCTURED_DATA_PRESENT",
    "title": "Presence of Product structured data",
    "category": "Product",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Product structured data enables Google to display rich product information such as price, availability, and reviews in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> elements.\n# 2. Parse each as JSON.\n# 3. If any object (or object within an array) has \"@type\" == \"Product\", set found = true.\n# 4. Return found.\n"
    },
    "pass_condition": "At least one JSON-LD block contains \"@type\" equal to \"Product\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Product structured data missing on product page."],
    "references": [
      {
        "doc_title": "Structured Data for Ecommerce Sites",
        "url": "https://developers.google.com/search/docs/structured-data/ecommerce",
        "section_title": "Product",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "product", "ecommerce"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a Product JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Product\",\n  \"name\": \"Running Shoes\",\n  \"image\": [\"https://example.com/shoe.jpg\"],\n  \"description\": \"Lightweight running shoes.\",\n  \"sku\": \"12345\",\n  \"offers\": {\n    \"@type\": \"Offer\",\n    \"priceCurrency\": \"USD\",\n    \"price\": \"79.99\",\n    \"availability\": \"https://schema.org/InStock\"\n  }\n}\n</script>\n"
      },
      "failing": {
        "description": "No Product JSON\u2011LD present.",
        "snippet": "<html><body><h1>Running Shoes</h1><p>Details about the shoes.</p></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Product present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Product\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Product absent",
        "input_stub": {
          "html": "<p>Product description without structured data.</p>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REVIEW_STRUCTURED_DATA_PRESENT",
    "title": "Presence of Review structured data",
    "category": "Review",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Review structured data helps Google understand product reviews and can enable rich review snippets in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Select all <script type=\"application/ld+json\"> elements.\n# 2. Parse each as JSON.\n# 3. If any object (or nested object) has \"@type\" == \"Review\", set found = true.\n# 4. Return found.\n"
    },
    "pass_condition": "At least one JSON-LD block contains \"@type\" equal to \"Review\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Review structured data not found on the page."],
    "references": [
      {
        "doc_title": "Structured Data for Ecommerce Sites",
        "url": "https://developers.google.com/search/docs/structured-data/ecommerce",
        "section_title": "Review",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "review", "ecommerce"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a Review JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Review\",\n  \"author\": { \"@type\": \"Person\", \"name\": \"Jane Doe\" },\n  \"reviewRating\": { \"@type\": \"Rating\", \"ratingValue\": \"5\", \"bestRating\": \"5\" },\n  \"reviewBody\": \"Excellent product!\"\n}\n</script>\n"
      },
      "failing": {
        "description": "No Review JSON\u2011LD present.",
        "snippet": "<html><body><p>Customer testimonials without structured data.</p></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Review present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Review\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Review absent",
        "input_stub": {
          "html": "<p>Plain testimonial text.</p>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VIDEOOBJECT_STRUCTURED_DATA_PRESENT",
    "title": "Presence of VideoObject structured data",
    "category": "VideoObject",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "VideoObject structured data enables Google to display video rich results for pages primarily about videos.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> elements.\n# 2. Parse each as JSON.\n# 3. If any object (or nested object) has \"@type\" == \"VideoObject\", set found = true.\n# 4. Return found.\n"
    },
    "pass_condition": "At least one JSON-LD block contains \"@type\" equal to \"VideoObject\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["VideoObject structured data missing on video page."],
    "references": [
      {
        "doc_title": "Structured Data for Ecommerce Sites",
        "url": "https://developers.google.com/search/docs/structured-data/ecommerce",
        "section_title": "VideoObject",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "videoobject", "ecommerce"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a VideoObject JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"VideoObject\",\n  \"name\": \"Product Demo\",\n  \"description\": \"Demo of the product in use.\",\n  \"thumbnailUrl\": \"https://example.com/thumbnail.jpg\",\n  \"uploadDate\": \"2023-01-01\",\n  \"contentUrl\": \"https://example.com/video.mp4\",\n  \"embedUrl\": \"https://example.com/embed/video\"\n}\n</script>\n"
      },
      "failing": {
        "description": "No VideoObject JSON\u2011LD present.",
        "snippet": "<html><body><p>Video content without structured data.</p></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "VideoObject present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VideoObject\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "VideoObject absent",
        "input_stub": {
          "html": "<p>Page with embedded video but no structured data.</p>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BREADCRUMB_STRUCTURED_DATA_PRESENT",
    "title": "Presence of Breadcrumb structured data",
    "category": "Breadcrumb",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Breadcrumb structured data helps Google understand page hierarchy and can enhance breadcrumb display in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Select all <script type=\"application/ld+json\"> elements.\n# 2. Parse each as JSON.\n# 3. If any object (or nested object) has \"@type\" == \"BreadcrumbList\", set found = true.\n# 4. Return found.\n"
    },
    "pass_condition": "At least one JSON-LD block contains \"@type\" equal to \"BreadcrumbList\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Breadcrumb structured data not detected on the page."],
    "references": [
      {
        "doc_title": "Structured Data for Ecommerce Sites",
        "url": "https://developers.google.com/search/docs/structured-data/ecommerce",
        "section_title": "Breadcrumb",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "breadcrumb", "ecommerce"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a BreadcrumbList JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"BreadcrumbList\",\n  \"itemListElement\": [\n    { \"@type\": \"ListItem\", \"position\": 1, \"name\": \"Home\", \"item\": \"https://example.com/\" },\n    { \"@type\": \"ListItem\", \"position\": 2, \"name\": \"Category\", \"item\": \"https://example.com/category\" },\n    { \"@type\": \"ListItem\", \"position\": 3, \"name\": \"Product\", \"item\": \"https://example.com/category/product\" }\n  ]\n}\n</script>\n"
      },
      "failing": {
        "description": "No BreadcrumbList JSON\u2011LD present.",
        "snippet": "<html><body><nav>Home > Category > Product</nav></body></html>\n"
      }
    },
    "test_cases": [
      {
        "name": "Breadcrumb present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"BreadcrumbList\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Breadcrumb absent",
        "input_stub": {
          "html": "<nav>Home > Category > Product</nav>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SEQUENTIAL_LINKS_PRESENT",
    "title": "Presence of next-page link",
    "category": "Link pages sequentially",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Google crawlers follow <a href> links to discover subsequent paginated pages; without such links the crawler may miss content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      },
      {
        "name": "url",
        "required": true,
        "description": "Fully qualified URL of the page being evaluated"
      }
    ],
    "preconditions": [
      "Page URL contains a pagination indicator (e.g., '?page=' parameter)"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href*='?page=']",
        "attribute": "href",
        "notes": "Collect href values of pagination links"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, url\n# 1. Parse html to extract all <a> elements where href contains \"?page=\".\n# 2. If no such links are found, FAIL.\n# 3. For each extracted href, resolve to absolute URL.\n# 4. If any resolved href is different from the current page URL, PASS.\n# 5. Otherwise, FAIL.\n"
    },
    "pass_condition": "At least one pagination link (<a href>) points to a different page URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No pagination link to a subsequent page was found on ${url}."
    ],
    "references": [
      {
        "doc_title": "Pagination Best Practices for Google",
        "url": "https://developers.google.com/search/docs/advanced/crawling/pagination-best-practices",
        "section_title": "Link pages sequentially",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["pagination", "crawlability", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a link to page 2.",
        "snippet": "<a href=\"/products?page=2\">Next</a>"
      },
      "failing": {
        "description": "Page lacks any pagination links.",
        "snippet": "<p>No more results.</p>"
      }
    },
    "test_cases": [
      {
        "name": "Page with next link",
        "input_stub": {
          "html": "<a href=\"/category?page=2\">Next</a>",
          "url": "https://example.com/category?page=1",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Page without pagination link",
        "input_stub": {
          "html": "<p>End of list.</p>",
          "url": "https://example.com/category?page=3",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "UNIQUE_URL_PER_PAGE",
    "title": "Pagination URL contains page parameter",
    "category": "Use URLs correctly",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Distinct URLs allow Google to treat each paginated segment as a separate page for indexing.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Fully qualified URL of the page being evaluated"
      }
    ],
    "preconditions": [
      "Page is part of a paginated series (e.g., known from site structure)."
    ],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "url",
        "attribute": null,
        "notes": "Check that URL matches pattern containing '?page=' followed by a positive integer."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url\n# 1. Apply regex /\\?page=\\d+/ to the URL.\n# 2. If the regex matches, PASS.\n# 3. Otherwise, FAIL.\n"
    },
    "pass_condition": "URL includes a \"?page=\" query parameter with a numeric value.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Pagination URL ${url} does not contain a numeric '?page=' parameter."
    ],
    "references": [
      {
        "doc_title": "Pagination Best Practices for Google",
        "url": "https://developers.google.com/search/docs/advanced/crawling/pagination-best-practices",
        "section_title": "Use URLs correctly",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["pagination", "url-structure", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL includes page parameter.",
        "snippet": "https://example.com/products?page=3"
      },
      "failing": {
        "description": "URL lacks page parameter.",
        "snippet": "https://example.com/products"
      }
    },
    "test_cases": [
      {
        "name": "URL with page param",
        "input_stub": {
          "html": null,
          "url": "https://example.com/list?page=2",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "URL without page param",
        "input_stub": {
          "html": null,
          "url": "https://example.com/list",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_NOT_FIRST_PAGE",
    "title": "Canonical tag does not point to first page for non\u2011first paginated pages",
    "category": "Use URLs correctly",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Each paginated page should have its own canonical URL to avoid duplicate\u2011content issues and to signal the correct landing page to Google.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      },
      {
        "name": "url",
        "required": true,
        "description": "Fully qualified URL of the page being evaluated"
      }
    ],
    "preconditions": [
      "Page URL contains '?page=' with a numeric value greater than 1"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='canonical']",
        "attribute": "href",
        "notes": "Canonical URL declared for the page"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html, url\n# 1. Extract the value of the 'href' attribute from <link rel=\"canonical\">.\n# 2. Parse the current page's URL to obtain its page number (N).\n# 3. Construct the first\u2011page URL by setting page=1 (or removing the page parameter if the first page has no parameter).\n# 4. If canonical href equals the first\u2011page URL, FAIL.\n# 5. Otherwise, PASS.\n"
    },
    "pass_condition": "Canonical URL differs from the first\u2011page URL when the current page is not the first page.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Canonical URL ${canonical} incorrectly points to the first page for ${url}."
    ],
    "references": [
      {
        "doc_title": "Pagination Best Practices for Google",
        "url": "https://developers.google.com/search/docs/advanced/crawling/pagination-best-practices",
        "section_title": "Use URLs correctly",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["pagination", "canonical", "duplicate-content"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Non\u2011first page has its own canonical URL.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/products?page=3\"/>"
      },
      "failing": {
        "description": "Non\u2011first page incorrectly canonicalizes to first page.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/products?page=1\"/>"
      }
    },
    "test_cases": [
      {
        "name": "Correct canonical on page 3",
        "input_stub": {
          "html": "<link rel='canonical' href='https://example.com/products?page=3'/>",
          "url": "https://example.com/products?page=3",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Incorrect canonical on page 2",
        "input_stub": {
          "html": "<link rel='canonical' href='https://example.com/products?page=1'/>",
          "url": "https://example.com/products?page=2",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NO_FRAGMENT_IN_PAGINATION_URLS",
    "title": "Pagination links must not use URL fragments for page numbers",
    "category": "Use URLs correctly",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google ignores fragment identifiers when crawling; using them for pagination prevents the crawler from reaching subsequent pages.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [
      "Page contains pagination links (e.g., links with '?page=' in href)."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href*='?page=']",
        "attribute": "href",
        "notes": "Href values of pagination links"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract all hrefs from <a> elements where href contains \"?page=\".\n# 2. For each href, check if it contains a '#' character.\n# 3. If any href contains '#', FAIL.\n# 4. If none contain '#', PASS.\n"
    },
    "pass_condition": "No pagination link href includes a fragment identifier ('#').",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Pagination link ${href} uses a fragment identifier, which Google ignores."
    ],
    "references": [
      {
        "doc_title": "Pagination Best Practices for Google",
        "url": "https://developers.google.com/search/docs/advanced/crawling/pagination-best-practices",
        "section_title": "Use URLs correctly",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["pagination", "url-fragment", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Pagination link without fragment.",
        "snippet": "<a href=\"/products?page=2\">Next</a>"
      },
      "failing": {
        "description": "Pagination link uses fragment for page number.",
        "snippet": "<a href=\"/products?page=2#section\">Next</a>"
      }
    },
    "test_cases": [
      {
        "name": "Link without fragment",
        "input_stub": {
          "html": "<a href=\"/list?page=2\">Next</a>",
          "url": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Link with fragment",
        "input_stub": {
          "html": "<a href=\"/list?page=2#results\">Next</a>",
          "url": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "GOOGLEBOT_IP_BLOCKING_CONSISTENCY",
    "title": "Ensure Googlebot is not blocked inconsistently based on IP locale",
    "category": "Geo-distributed crawling",
    "requirement": "SHOULD",
    "severity": "high",
    "scope": "site",
    "rationale": "Googlebot should be treated like any other user from the same country; if users from a locale are allowed, Googlebot from that locale must not be blocked.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "Headers for the HTTP request, including User-Agent set to Googlebot."
      },
      {
        "name": "url",
        "required": true,
        "description": "Target URL to request."
      },
      {
        "name": "ip_location",
        "required": true,
        "description": "Simulated IP location (e.g., US, AU) for the request."
      }
    ],
    "preconditions": [
      "Site serves locale-adaptive content based on visitor location."
    ],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "HTTP status code returned for the request."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: url, http_headers, ip_location\n# 1. Send request to url with http_headers (User-Agent=Googlebot) and simulate ip_location.\n# 2. Record status_us if ip_location == \"US\".\n# 3. Send request with ip_location == \"AU\".\n# 4. Record status_au.\n# 5. If status_us != status_au then fail.\n"
    },
    "pass_condition": "Googlebot receives the same HTTP status for all simulated IP locations.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Observed status codes differ between locales: US=${status_us}, AU=${status_au}."
    ],
    "references": [
      {
        "doc_title": "How Google Crawls Locale-Adaptive Pages",
        "url": "https://developers.google.com/search/docs/crawling-indexing/locale-adaptive-pages",
        "section_title": "Geo-distributed crawling",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["geo-distributed", "crawling"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both US and AU requests return 200.",
        "snippet": "GET /page HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\nX-Forwarded-For: 34.56.78.90   # AU IP\n=> 200 OK\n"
      },
      "failing": {
        "description": "US request returns 403 while AU returns 200.",
        "snippet": "GET /page HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\nX-Forwarded-For: 12.34.56.78   # US IP\n=> 403 Forbidden\n"
      }
    },
    "test_cases": [
      {
        "name": "Consistent status across locales",
        "input_stub": {
          "url": "https://example.com/page",
          "http_headers": {
            "User-Agent": "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
          },
          "ip_location": "US"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Inconsistent status",
        "input_stub": {
          "url": "https://example.com/page",
          "http_headers": {
            "User-Agent": "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
          },
          "ip_location": "US"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ROBOTS_RULES_CONSISTENCY_LOCALE",
    "title": "Robots directives must be consistent across locales",
    "category": "Robots exclusion protocol",
    "requirement": "MUST",
    "severity": "high",
    "scope": "site",
    "rationale": "Robots meta tags and robots.txt must specify the same rules in each locale to ensure consistent crawling.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file."
      },
      {
        "name": "html",
        "required": true,
        "description": "HTML of a page in a specific locale."
      }
    ],
    "preconditions": ["Site uses the robots exclusion protocol."],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Robots meta tag content on the page."
      },
      {
        "type": "robots_txt",
        "selector": "rules",
        "attribute": null,
        "notes": "Disallowed/allowed paths from robots.txt."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: robots_txt, html\n# 1. Extract meta_robots from html using selector meta[name='robots'] attribute content.\n# 2. Parse robots_txt to obtain directives for the same path.\n# 3. If meta_robots directives differ from robots_txt directives for that path, fail.\n"
    },
    "pass_condition": "Robots meta tag directives match the robots.txt directives for the same URL in every locale.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Meta robots directive '${meta_robots}' does not match robots.txt directive '${txt_directive}' for locale '${locale}'."
    ],
    "references": [
      {
        "doc_title": "How Google Crawls Locale-Adaptive Pages",
        "url": "https://developers.google.com/search/docs/crawling-indexing/locale-adaptive-pages",
        "section_title": "Other considerations",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "localization"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both robots.txt and meta tag disallow /private in all locales.",
        "snippet": "robots.txt:\nUser-agent: *\nDisallow: /private\n<meta name=\"robots\" content=\"noindex, nofollow\">\n"
      },
      "failing": {
        "description": "Meta tag allows indexing but robots.txt disallows the path.",
        "snippet": "robots.txt:\nUser-agent: *\nDisallow: /private\n<meta name=\"robots\" content=\"index, follow\">\n"
      }
    },
    "test_cases": [
      {
        "name": "Consistent directives",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /private\n",
          "html": "<html><head><meta name=\"robots\" content=\"noindex, nofollow\"></head></html>\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Inconsistent directives",
        "input_stub": {
          "robots_txt": "User-agent: *\nDisallow: /private\n",
          "html": "<html><head><meta name=\"robots\" content=\"index, follow\"></head></html>\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HTML_SELF_LINK",
    "title": "Self-referential hreflang link present in HTML",
    "category": "Guidelines for all methods",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Each language version must list itself as a hreflang alternate so Google can recognize the page as part of the set.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Rendered HTML of the page."
      },
      {
        "name": "url",
        "required": true,
        "description": "Canonical URL of the page being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head link[rel=\"alternate\"][hreflang][href]",
        "attribute": "href",
        "notes": "Collect href values of all hreflang link tags."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the HTML document.\n# 2. Select all <link> elements with rel=\"alternate\" and hreflang attributes inside <head>.\n# 3. Extract their href attributes into a list hrefs.\n# 4. Compare each href to the page's own URL (input url).\n# 5. If any href equals the page URL, PASS; else FAIL.\n"
    },
    "pass_condition": "The page's own URL appears in at least one hreflang link href.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["No self-referential hreflang link found for ${url}."],
    "references": [
      {
        "doc_title": "Tell Google about localized versions of your page",
        "url": "https://developers.google.com/search/docs/advanced/crawling/localized-versions",
        "section_title": "Guidelines for all methods",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "html"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a self-referential hreflang link.",
        "snippet": "<head><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/page.html\"/></head>"
      },
      "failing": {
        "description": "Page lacks a self-referential hreflang link.",
        "snippet": "<head></head>"
      }
    },
    "test_cases": [
      {
        "name": "Self link present",
        "input_stub": {
          "html": "<head><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/page.html\"/></head>",
          "url": "https://example.com/page.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Self link missing",
        "input_stub": {
          "html": "<head></head>",
          "url": "https://example.com/page.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HTML_ABSOLUTE_URLS",
    "title": "hreflang link href attributes must be fully-qualified URLs",
    "category": "Guidelines for all methods",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires absolute URLs (including scheme) for alternate URLs.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Rendered HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head link[rel=\"alternate\"][href]",
        "attribute": "href",
        "notes": "Collect href values."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML.\n# 2. Find all <link rel=\"alternate\"> elements.\n# 3. For each href, verify it matches the regex ^https?://\n# 4. If all hrefs are absolute, PASS; else FAIL.\n"
    },
    "pass_condition": "Every hreflang link href starts with \"http://\" or \"https://\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Found non-absolute href '${href}' in hreflang link."],
    "references": [
      {
        "doc_title": "Tell Google about localized versions of your page",
        "url": "https://developers.google.com/search/docs/advanced/crawling/localized-versions",
        "section_title": "Guidelines for all methods",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "url"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All hrefs are absolute.",
        "snippet": "<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/page.html\"/>"
      },
      "failing": {
        "description": "Relative href used.",
        "snippet": "<link rel=\"alternate\" hreflang=\"en\" href=\"/en/page.html\"/>"
      }
    },
    "test_cases": [
      {
        "name": "Absolute href",
        "input_stub": {
          "html": "<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/page.html\"/>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Relative href",
        "input_stub": {
          "html": "<link rel=\"alternate\" hreflang=\"en\" href=\"/en/page.html\"/>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HTML_LINK_IN_HEAD",
    "title": "hreflang link tags must be placed inside <head>",
    "category": "HTML tags",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google only reads hreflang links that appear in the document head.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"alternate\"][hreflang]",
        "attribute": null,
        "notes": "Collect location of each matching link element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML into DOM.\n# 2. For each <link rel=\"alternate\" hreflang> element, check if its ancestor is <head>.\n# 3. If any such link is outside <head>, FAIL; otherwise PASS.\n"
    },
    "pass_condition": "All hreflang link elements are descendants of the <head> element.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["hreflang link found outside <head> at line ${line}."],
    "references": [
      {
        "doc_title": "Tell Google about localized versions of your page",
        "url": "https://developers.google.com/search/docs/advanced/crawling/localized-versions",
        "section_title": "HTML tags",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "html"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Link placed inside head.",
        "snippet": "<head><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en.html\"/></head>"
      },
      "failing": {
        "description": "Link placed in body.",
        "snippet": "<body><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en.html\"/></body>"
      }
    },
    "test_cases": [
      {
        "name": "Link in head",
        "input_stub": {
          "html": "<head><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en.html\"/></head>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Link in body",
        "input_stub": {
          "html": "<body><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en.html\"/></body>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HTTP_HEADER_SELF_LINK",
    "title": "Link header must include self-referential hreflang entry",
    "category": "HTTP Headers",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "The set of URLs in the Link header must contain the requested URL so Google knows the page is part of the locale group.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers map."
      },
      {
        "name": "url",
        "required": true,
        "description": "URL of the requested resource."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "Link",
        "attribute": null,
        "notes": "Full value of the Link header."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Retrieve the 'Link' header value.\n# 2. Split the header by commas to get individual link entries.\n# 3. For each entry, extract the URL between '<' and '>'.\n# 4. Check if any extracted URL equals the requested URL.\n# 5. PASS if found, else FAIL.\n"
    },
    "pass_condition": "The Link header contains an entry whose URL matches the requested resource URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Link header does not contain a self-referential hreflang entry for ${url}."
    ],
    "references": [
      {
        "doc_title": "Tell Google about localized versions of your page",
        "url": "https://developers.google.com/search/docs/advanced/crawling/localized-versions",
        "section_title": "HTTP Headers",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "http"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Link header includes the page URL.",
        "snippet": "Link: <https://example.com/page.pdf>; rel=\"alternate\"; hreflang=\"en\""
      },
      "failing": {
        "description": "Link header missing self URL.",
        "snippet": "Link: <https://example.com/other.pdf>; rel=\"alternate\"; hreflang=\"de\""
      }
    },
    "test_cases": [
      {
        "name": "Self link present",
        "input_stub": {
          "http_headers": {
            "Link": "<https://example.com/page.pdf>; rel=\"alternate\"; hreflang=\"en\""
          },
          "url": "https://example.com/page.pdf"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Self link missing",
        "input_stub": {
          "http_headers": {
            "Link": "<https://example.com/other.pdf>; rel=\"alternate\"; hreflang=\"de\""
          },
          "url": "https://example.com/page.pdf"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITEMAP_SELF_LINK",
    "title": "Sitemap entries must include self-referential hreflang link",
    "category": "Sitemap",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Each <url> element must list every alternate version, including itself, to be recognized as a localized set.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "XML content of the sitemap file."
      },
      {
        "name": "url",
        "required": true,
        "description": "URL of the page whose entry is being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url[loc[text() = '${url}']]/xhtml:link",
        "attribute": "href",
        "notes": "Collect href attributes of all xhtml:link elements for the given URL."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the sitemap XML with namespace support.\n# 2. Locate the <url> element whose <loc> text equals the input URL.\n# 3. Gather all <xhtml:link> elements under that <url>.\n# 4. Extract their href attributes.\n# 5. If any href equals the input URL, PASS; else FAIL.\n"
    },
    "pass_condition": "The sitemap entry for the page contains an xhtml:link with href equal to the page URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Sitemap entry for ${url} lacks a self-referential hreflang link."
    ],
    "references": [
      {
        "doc_title": "Tell Google about localized versions of your page",
        "url": "https://developers.google.com/search/docs/advanced/crawling/localized-versions",
        "section_title": "Sitemap",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "sitemap"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Sitemap entry includes self link.",
        "snippet": "<url>\n  <loc>https://example.com/en/page.html</loc>\n  <xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/page.html\"/>\n  <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de/page.html\"/>\n</url>\n"
      },
      "failing": {
        "description": "Sitemap entry missing self link.",
        "snippet": "<url>\n  <loc>https://example.com/en/page.html</loc>\n  <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de/page.html\"/>\n</url>\n"
      }
    },
    "test_cases": [
      {
        "name": "Self link present",
        "input_stub": {
          "sitemap_xml": "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n  <url>\n    <loc>https://example.com/en/page.html</loc>\n    <xhtml:link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/page.html\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de/page.html\"/>\n  </url>\n</urlset>\n",
          "url": "https://example.com/en/page.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Self link missing",
        "input_stub": {
          "sitemap_xml": "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n  <url>\n    <loc>https://example.com/en/page.html</loc>\n    <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de/page.html\"/>\n  </url>\n</urlset>\n",
          "url": "https://example.com/en/page.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HREFLANG_VALUE_VALIDITY",
    "title": "hreflang attribute values must use supported ISO language and region codes",
    "category": "Supported language and region codes",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Only ISO 639-1 language codes and ISO 3166-1 Alpha\u20112 region codes are recognized by Google.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Rendered HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"alternate\"][hreflang]",
        "attribute": "hreflang",
        "notes": "Collect all hreflang attribute values."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML.\n# 2. For each <link rel=\"alternate\" hreflang=\"value\">, extract value.\n# 3. Split value on '-'.\n# 4. Verify first part is a two\u2011letter code present in ISO 639\u20111 list.\n# 5. If a second part exists, verify it is a two\u2011letter code present in ISO 3166\u20111 Alpha\u20112 list.\n# 6. If any value fails validation, FAIL; else PASS.\n"
    },
    "pass_condition": "All hreflang values consist of a valid ISO 639\u20111 language code and, if present, a valid ISO 3166\u20111 region code.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Invalid hreflang value '${value}' detected."],
    "references": [
      {
        "doc_title": "Tell Google about localized versions of your page",
        "url": "https://developers.google.com/search/docs/advanced/crawling/localized-versions",
        "section_title": "Supported language and region codes",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "validation"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Valid hreflang values.",
        "snippet": "<link rel=\"alternate\" hreflang=\"en\" href=\"...\"/><link rel=\"alternate\" hreflang=\"de-CH\" href=\"...\"/>"
      },
      "failing": {
        "description": "Invalid language or region code.",
        "snippet": "<link rel=\"alternate\" hreflang=\"es-419\" href=\"...\"/>"
      }
    },
    "test_cases": [
      {
        "name": "Valid values",
        "input_stub": {
          "html": "<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en.html\"/><link rel=\"alternate\" hreflang=\"de-CH\" href=\"https://example.com/de-ch.html\"/>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Invalid value",
        "input_stub": {
          "html": "<link rel=\"alternate\" hreflang=\"es-419\" href=\"https://example.com/es.html\"/>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BIDIRECTIONAL_LINKS",
    "title": "hreflang links must be bidirectional between pages",
    "category": "Common Mistakes",
    "requirement": "MUST",
    "severity": "high",
    "scope": "site",
    "rationale": "Google ignores hreflang annotations that are not reciprocated, preventing correct localization.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the page being evaluated."
      },
      {
        "name": "url",
        "required": true,
        "description": "URL of the page being evaluated."
      },
      {
        "name": "fetch_page",
        "required": true,
        "description": "Function or stub to retrieve HTML of a given URL."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "head link[rel=\"alternate\"][hreflang][href]",
        "attribute": "href",
        "notes": "Collect hrefs of all hreflang links on the page."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse current page HTML, collect set A of hrefs from hreflang links.\n# 2. For each href in set A:\n#    a. Retrieve the HTML of that href (using fetch_page).\n#    b. Collect its hreflang href set B.\n#    c. Verify that the original page URL is present in B.\n# 3. If every href reciprocates, PASS; else FAIL.\n"
    },
    "pass_condition": "Every alternate URL listed on the page also lists the original page as an alternate.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page ${url} lists ${target} without a reciprocal link back."
    ],
    "references": [
      {
        "doc_title": "Tell Google about localized versions of your page",
        "url": "https://developers.google.com/search/docs/advanced/crawling/localized-versions",
        "section_title": "Common Mistakes",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "reciprocity"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both pages reference each other.",
        "snippet": "Page A:\n<link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de.html\"/>\nPage B:\n<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en.html\"/>\n"
      },
      "failing": {
        "description": "Page A references Page B, but Page B does not reference Page A.",
        "snippet": "Page A:\n<link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de.html\"/>\nPage B:\n(no link back to en page)\n"
      }
    },
    "test_cases": [
      {
        "name": "Reciprocal links present",
        "input_stub": {
          "html": "<link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de.html\"/>",
          "url": "https://example.com/en.html",
          "fetch_page": {
            "https://example.com/de.html": "<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en.html\"/>"
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing reciprocal link",
        "input_stub": {
          "html": "<link rel=\"alternate\" hreflang=\"de\" href=\"https://example.com/de.html\"/>",
          "url": "https://example.com/en.html",
          "fetch_page": {
            "https://example.com/de.html": "<head></head>"
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HREFLANG_ANNOTATIONS_PRESENT",
    "title": "hreflang annotations must be present for each language version URL",
    "category": "Managing multilingual versions of your site",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Google uses hreflang annotations to associate language versions and help search results link to the correct page.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The rendered HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='alternate'][hreflang]",
        "attribute": "hreflang",
        "notes": "Collect all hreflang values from link elements."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html.\n# 2. Find all <link> elements where rel=\"alternate\" and hreflang attribute exists.\n# 3. If at least one such element is found, pass; else fail.\n"
    },
    "pass_condition": "At least one <link rel=\"alternate\" hreflang=\"...\"> element is present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["No hreflang annotations found on the page."],
    "references": [
      {
        "doc_title": "Managing multi-regional and multilingual sites",
        "url": "https://developers.google.com/search/docs/advanced/crawling/managing-multi-regional-multilingual-sites",
        "section_title": "Use different URLs for different language versions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["hreflang", "multilingual"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes hreflang link elements.",
        "snippet": "<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/\"/>"
      },
      "failing": {
        "description": "Page lacks hreflang annotations.",
        "snippet": "<!-- no hreflang links -->"
      }
    },
    "test_cases": [
      {
        "name": "Page with hreflang",
        "input_stub": {
          "html": "<html><head><link rel=\"alternate\" hreflang=\"fr\" href=\"https://example.com/fr/\"/></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Page without hreflang",
        "input_stub": {
          "html": "<html><head></head><body>Content</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NO_URL_PARAMETERS_FOR_GEO_TARGETING",
    "title": "URLs must not use query parameters for geotargeting",
    "category": "Using locale-specific URLs",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google recommends against using URL parameters (e.g., ?loc=de) for geotargeting because they are not reliable signals.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "The full URL of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": null,
        "attribute": null,
        "notes": "Match query parameter 'loc' with two-letter country code."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url\n# 1. Parse query string of the URL.\n# 2. If a parameter named 'loc' exists, fail.\n# 3. Otherwise, pass.\n"
    },
    "pass_condition": "URL does not contain a 'loc' query parameter.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "URL contains a 'loc' query parameter (${observed}), which is not recommended for geotargeting."
    ],
    "references": [
      {
        "doc_title": "Managing multi-regional and multilingual sites",
        "url": "https://developers.google.com/search/docs/advanced/crawling/managing-multi-regional-multilingual-sites",
        "section_title": "Using locale-specific URLs",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["geotargeting", "url-parameters"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL without loc parameter.",
        "snippet": "https://example.com/de/page.html"
      },
      "failing": {
        "description": "URL with loc parameter.",
        "snippet": "https://example.com/page.html?loc=de"
      }
    },
    "test_cases": [
      {
        "name": "URL without loc",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/fr/about"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "URL with loc",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/about?loc=fr"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NO_LOCATIONAL_META_TAGS",
    "title": "Locational meta tags must not be used",
    "category": "What Google doesn't do",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Google ignores locational meta tags such as geo.position or distribution, so they should be omitted.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML content."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='geo.position'], meta[name='distribution']",
        "attribute": "content",
        "notes": "Collect content of any locational meta tags."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html.\n# 2. Search for <meta> elements with name=\"geo.position\" or name=\"distribution\".\n# 3. If any are found, fail; else pass.\n"
    },
    "pass_condition": "No <meta name=\"geo.position\"> or <meta name=\"distribution\"> elements are present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Locational meta tag ${observed} found; Google ignores these tags."
    ],
    "references": [
      {
        "doc_title": "Managing multi-regional and multilingual sites",
        "url": "https://developers.google.com/search/docs/advanced/crawling/managing-multi-regional-multilingual-sites",
        "section_title": "What Google doesn't do",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["meta-tags", "geotargeting"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page without locational meta tags.",
        "snippet": "<head><title>Example</title></head>"
      },
      "failing": {
        "description": "Page with geo.position meta tag.",
        "snippet": "<meta name=\"geo.position\" content=\"48.8566;2.3522\"/>"
      }
    },
    "test_cases": [
      {
        "name": "No locational meta",
        "input_stub": {
          "html": "<html><head><title>Test</title></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "With geo.position meta",
        "input_stub": {
          "html": "<html><head><meta name=\"geo.position\" content=\"48.8566;2.3522\"/></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_AND_HREFLANG_FOR_DUPLICATE_CONTENT",
    "title": "Duplicate regional pages must include rel=canonical and hreflang tags",
    "category": "Handling duplicate pages with multilingual/multi-regional sites",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Using rel=canonical together with hreflang signals the preferred version and correct language/region to search engines.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='canonical']",
        "attribute": "href",
        "notes": "Canonical URL"
      },
      {
        "type": "selector",
        "selector": "link[rel='alternate'][hreflang]",
        "attribute": "hreflang",
        "notes": "hreflang annotations"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html.\n# 2. Check for <link rel=\"canonical\"> element; record presence.\n# 3. Check for at least one <link rel=\"alternate\" hreflang=\"...\"> element.\n# 4. If both are present, pass; else fail.\n"
    },
    "pass_condition": "Both a canonical link and at least one hreflang alternate link are present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing rel=canonical tag.",
      "Missing hreflang alternate tags."
    ],
    "references": [
      {
        "doc_title": "Managing multi-regional and multilingual sites",
        "url": "https://developers.google.com/search/docs/advanced/crawling/managing-multi-regional-multilingual-sites",
        "section_title": "Handling duplicate pages with multilingual/multi-regional sites",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "hreflang", "duplicate-content"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes both canonical and hreflang links.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/de/\"/><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/\"/>"
      },
      "failing": {
        "description": "Page missing canonical link.",
        "snippet": "<link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/\"/>"
      }
    },
    "test_cases": [
      {
        "name": "Both present",
        "input_stub": {
          "html": "<html><head><link rel=\"canonical\" href=\"https://example.com/de/\"/><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/\"/></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing canonical",
        "input_stub": {
          "html": "<html><head><link rel=\"alternate\" hreflang=\"en\" href=\"https://example.com/en/\"/></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "META_RATING_ADULT_TAG_PRESENT",
    "title": "Explicit page marked with rating meta tag",
    "category": "Mark specific pages as explicit with metadata",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Adding a rating meta tag lets Google reliably identify pages that contain sexually explicit content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='rating']",
        "attribute": "content",
        "notes": "Capture the content attribute of the rating meta tag."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Search for a <meta> element where name=\"rating\".\n# 3. If found, retrieve its content attribute.\n# 4. If content equals \"adult\" or matches the pattern \"RTA-.*\", set observed = true.\n# 5. Else, set observed = false.\n"
    },
    "pass_condition": "The page contains a <meta name=\"rating\" content=\"adult\"> tag or an equivalent RTA rating tag.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No rating meta tag with content 'adult' or equivalent RTA value found on the page."
    ],
    "references": [
      {
        "doc_title": "SEO Guidelines for Explicit Content",
        "url": "https://developers.google.com/search/docs/explicit-content",
        "section_title": "Mark specific pages as explicit with metadata",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["explicit", "metadata"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes the required meta tag.",
        "snippet": "<meta name=\"rating\" content=\"adult\">"
      },
      "failing": {
        "description": "Page lacks the rating meta tag.",
        "snippet": "<title>Example Page</title>"
      }
    },
    "test_cases": [
      {
        "name": "Page with adult rating meta tag",
        "input_stub": {
          "html": "<html><head><meta name=\"rating\" content=\"adult\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Page without rating meta tag",
        "input_stub": {
          "html": "<html><head><title>Test</title></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VIDEO_SITEMAP_FAMILY_FRIENDLY_NO",
    "title": "Explicit videos marked with video:family_friendly=no in video sitemap",
    "category": "Mark specific pages as explicit with metadata",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "The video:family_friendly tag signals to Google that a video is not safe for all audiences, preventing it from appearing in SafeSearch results.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the video sitemap."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//video:family_friendly[text()='no']",
        "attribute": null,
        "notes": "Select any video entry where family_friendly is set to 'no'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml\n# 1. Parse the XML document.\n# 2. Locate all <video:family_friendly> elements.\n# 3. If any element's text equals \"no\", set observed = true.\n# 4. Otherwise, set observed = false.\n"
    },
    "pass_condition": "At least one <video:family_friendly> element with value \"no\" is present in the sitemap.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No video:family_friendly='no' entries found in the video sitemap."
    ],
    "references": [
      {
        "doc_title": "SEO Guidelines for Explicit Content",
        "url": "https://developers.google.com/search/docs/explicit-content",
        "section_title": "Use the <video:family_friendly> tag in your video sitemap",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video", "sitemap", "explicit"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Sitemap contains a video entry marked as not family friendly.",
        "snippet": "<url>\n  <loc>https://example.com/video1</loc>\n  <video:video>\n    <video:family_friendly>no</video:family_friendly>\n  </video:video>\n</url>\n"
      },
      "failing": {
        "description": "Sitemap has no family_friendly tags set to \"no\".",
        "snippet": "<url>\n  <loc>https://example.com/video2</loc>\n  <video:video>\n    <video:family_friendly>yes</video:family_friendly>\n  </video:video>\n</url>\n"
      }
    },
    "test_cases": [
      {
        "name": "Sitemap with explicit video tag",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": "<urlset xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n  <url>\n    <loc>https://example.com/video1</loc>\n    <video:video>\n      <video:family_friendly>no</video:family_friendly>\n    </video:video>\n  </url>\n</urlset>\n",
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Sitemap without explicit tag",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": "<urlset xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n  <url>\n    <loc>https://example.com/video2</loc>\n    <video:video>\n      <video:family_friendly>yes</video:family_friendly>\n    </video:video>\n  </url>\n</urlset>\n",
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "GOOGLEBOT_VIDEO_FETCH_ALLOWED",
    "title": "Googlebot allowed to fetch video content files",
    "category": "Allow Google to fetch your video content files",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "site",
    "rationale": "Allowing Googlebot to fetch video files enables automated safety checks and prevents demotion of pages with video content.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "The content of the site's robots.txt file."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "User-agent:\\s*Googlebot[\\s\\S]*?Disallow:\\s*(.*\\.mp4|.*\\.webm|.*\\.mov)",
        "attribute": null,
        "notes": "Capture any Disallow rule for common video extensions under the Googlebot user-agent."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: robots_txt\n# 1. Locate the \"User-agent: Googlebot\" section.\n# 2. Within that section, search for Disallow lines that end with .mp4, .webm, or .mov (case\u2011insensitive).\n# 3. If such a Disallow line exists, set observed = false.\n# 4. Otherwise, set observed = true.\n"
    },
    "pass_condition": "No Disallow rule for video file extensions is present for Googlebot in robots.txt.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "robots.txt blocks Googlebot from fetching video files (e.g., Disallow: *.mp4)."
    ],
    "references": [
      {
        "doc_title": "SEO Guidelines for Explicit Content",
        "url": "https://developers.google.com/search/docs/explicit-content",
        "section_title": "Allow Google to fetch your video content files",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "video", "fetch"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt does not block video extensions for Googlebot.",
        "snippet": "User-agent: *\nDisallow: /private/\nUser-agent: Googlebot\nAllow: /\n"
      },
      "failing": {
        "description": "robots.txt blocks .mp4 files for Googlebot.",
        "snippet": "User-agent: Googlebot\nDisallow: /*.mp4\n"
      }
    },
    "test_cases": [
      {
        "name": "No video block for Googlebot",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow: /private/\nUser-agent: Googlebot\nAllow: /\n",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Video block for Googlebot",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: Googlebot\nDisallow: /*.mp4\n",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "GOOGLEBOT_AGE_GATE_BYPASSED",
    "title": "Googlebot can crawl without triggering age gate",
    "category": "Allow Googlebot to crawl without age gate",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "If Googlebot is blocked by an age gate, Google cannot assess the content, leading to possible demotion or exclusion from SafeSearch.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "The URL of the page to request with Googlebot user\u2011agent."
      },
      {
        "name": "http_status",
        "required": true,
        "description": "HTTP status code returned when requesting the URL with Googlebot UA."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "Status code observed for a request using Googlebot UA."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: url, http_status\n# 1. Perform an HTTP GET to the URL using the Googlebot user\u2011agent string.\n# 2. Record the response status code.\n# 3. If status_code is 200, set observed = true.\n# 4. If status_code is a redirect (3xx) to an age\u2011gate page, set observed = false.\n"
    },
    "pass_condition": "The page returns HTTP 200 when fetched with the Googlebot user\u2011agent, indicating no age\u2011gate redirect.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 200,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Googlebot receives a non\u2011200 response (e.g., redirect to age gate) for the page."
    ],
    "references": [
      {
        "doc_title": "SEO Guidelines for Explicit Content",
        "url": "https://developers.google.com/search/docs/explicit-content",
        "section_title": "Allow Googlebot to crawl without age gate",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["age_gate", "crawl", "googlebot"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Googlebot receives a 200 OK response.",
        "snippet": "GET /explicit/page.html HTTP/1.1\nUser-Agent: Googlebot/2.1"
      },
      "failing": {
        "description": "Googlebot is redirected to an age\u2011gate page.",
        "snippet": "GET /explicit/page.html HTTP/1.1\nUser-Agent: Googlebot/2.1\nResponse: 302 Location: /age-gate"
      }
    },
    "test_cases": [
      {
        "name": "Googlebot receives 200 OK",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/explicit/page.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Googlebot redirected to age gate",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/explicit/page.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "EXPLICIT_CONTENT_SEPARATE_SUBDOMAIN",
    "title": "Explicit content hosted on a separate subdomain",
    "category": "Group explicit pages in a separate domain or subdomain",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "site",
    "rationale": "Hosting explicit and non\u2011explicit content on different subdomains prevents the entire site from being classified as explicit.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "XML sitemap listing URLs of the site."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url/loc",
        "attribute": null,
        "notes": "Collect all page URLs from the sitemap."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml\n# 1. Parse the XML and extract all <loc> URLs.\n# 2. For each URL, extract the hostname (including subdomain).\n# 3. Identify URLs that contain explicit content (assume they are flagged elsewhere; for deterministic check we require at least one URL whose path includes '/explicit/').\n# 4. Verify that at least one explicit URL's hostname differs from the hostname of a non\u2011explicit URL.\n# 5. If such a difference exists, set observed = true; else false.\n"
    },
    "pass_condition": "At least one explicit URL resides on a different subdomain than a non\u2011explicit URL.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "All URLs share the same hostname, indicating explicit and non\u2011explicit content are not separated."
    ],
    "references": [
      {
        "doc_title": "SEO Guidelines for Explicit Content",
        "url": "https://developers.google.com/search/docs/explicit-content",
        "section_title": "Group explicit pages in a separate domain or subdomain",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["domain", "explicit", "separation"],
    "insufficient_evidence": false,
    "notes": "The check assumes explicit pages can be identified by a path pattern such as '/explicit/'. Adjust the pattern as needed.",
    "examples": {
      "passing": {
        "description": "Explicit pages are on explicit.example.com while others are on www.example.com.",
        "snippet": "<url><loc>https://explicit.example.com/explicit/video1</loc></url>\n<url><loc>https://www.example.com/blog/post1</loc></url>\n"
      },
      "failing": {
        "description": "All pages are under the same domain.",
        "snippet": "<url><loc>https://www.example.com/explicit/video1</loc></url>\n<url><loc>https://www.example.com/blog/post1</loc></url>\n"
      }
    },
    "test_cases": [
      {
        "name": "Separate subdomains for explicit content",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <url><loc>https://explicit.example.com/explicit/video1</loc></url>\n  <url><loc>https://www.example.com/blog/post1</loc></url>\n</urlset>\n",
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Same domain for all content",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <url><loc>https://www.example.com/explicit/video1</loc></url>\n  <url><loc>https://www.example.com/blog/post1</loc></url>\n</urlset>\n",
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REQUIRED_DATASET_PROPERTIES",
    "title": "Required Dataset properties present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Dataset rich results require the 'name' and 'description' properties as defined in the documentation.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing the structured data."
      }
    ],
    "preconditions": [
      "Page includes a JSON-LD script block with \"@type\": \"Dataset\"."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse the JSON-LD and extract the Dataset object."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML and locate <script type=\"application/ld+json\"> blocks.\n# 2. For each block, parse JSON.\n# 3. If JSON[\"@type\"] == \"Dataset\" (or contains \"Dataset\"):\n#    a. Check if \"name\" exists and is non\u2011empty.\n#    b. Check if \"description\" exists and is non\u2011empty.\n# 4. If both properties are present, result = PASS else FAIL.\n"
    },
    "pass_condition": "Both 'name' and 'description' properties exist and are non\u2011empty in the Dataset markup.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property '${property}' in Dataset markup."
    ],
    "references": [
      {
        "doc_title": "Dataset Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/dataset",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Dataset JSON-LD includes both name and description.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org/\",\n  \"@type\":\"Dataset\",\n  \"name\":\"Example Dataset\",\n  \"description\":\"A description of the dataset.\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Dataset JSON-LD missing description.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org/\",\n  \"@type\":\"Dataset\",\n  \"name\":\"Example Dataset\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass when both properties present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org/\",\"@type\":\"Dataset\",\"name\":\"Test\",\"description\":\"Desc\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail when description missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org/\",\"@type\":\"Dataset\",\"name\":\"Test\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "REQUIRED_DISTRIBUTION_CONTENTURL",
    "title": "Distribution objects must include contentUrl",
    "category": "DataDownload",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The 'distribution.contentUrl' property is required for DataDownload objects to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing the structured data."
      }
    ],
    "preconditions": [
      "Page includes a JSON-LD script block with a Dataset object that contains a 'distribution' array."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse the JSON-LD and locate each object inside the 'distribution' array."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Locate <script type=\"application/ld+json\"> blocks and parse JSON.\n# 2. Find the Dataset object ([\"@type\"] == \"Dataset\").\n# 3. If Dataset has a \"distribution\" array:\n#    For each item in the array:\n#        a. Verify that \"contentUrl\" property exists and is non\u2011empty.\n# 4. If every distribution item has a valid contentUrl, result = PASS else FAIL.\n"
    },
    "pass_condition": "Every object in the Dataset's distribution array contains a non\u2011empty 'contentUrl' property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Distribution entry at index ${index} missing required 'contentUrl' property."
    ],
    "references": [
      {
        "doc_title": "Dataset Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/dataset",
        "section_title": "DataDownload",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "distribution"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Each distribution object includes contentUrl.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org/\",\n  \"@type\":\"Dataset\",\n  \"distribution\":[\n    {\"@type\":\"DataDownload\",\"contentUrl\":\"https://example.com/file1.csv\"},\n    {\"@type\":\"DataDownload\",\"contentUrl\":\"https://example.com/file2.xml\"}\n  ]\n}\n</script>\n"
      },
      "failing": {
        "description": "One distribution object lacks contentUrl.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org/\",\n  \"@type\":\"Dataset\",\n  \"distribution\":[\n    {\"@type\":\"DataDownload\",\"contentUrl\":\"https://example.com/file1.csv\"},\n    {\"@type\":\"DataDownload\"}\n  ]\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass when all distributions have contentUrl",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org/\",\"@type\":\"Dataset\",\"distribution\":[{\"@type\":\"DataDownload\",\"contentUrl\":\"https://example.com/a.csv\"},{\"@type\":\"DataDownload\",\"contentUrl\":\"https://example.com/b.xml\"}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail when a distribution lacks contentUrl",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org/\",\"@type\":\"Dataset\",\"distribution\":[{\"@type\":\"DataDownload\",\"contentUrl\":\"https://example.com/a.csv\"},{\"@type\":\"DataDownload\"}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ORGANIZATION_STRUCTURED_DATA_PRESENT",
    "title": "Presence of Organization structured data markup",
    "category": "Guidelines",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Structured data must be present on the page to be eligible for inclusion in Google Search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to evaluate"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Collect JSON-LD script blocks for parsing"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse the HTML and extract all <script type=\"application/ld+json\"> elements.\n# 2. For each extracted script, parse its text content as JSON.\n# 3. If the JSON object contains an \"@type\" field whose value is \"Organization\" or a known subtype (e.g., \"OnlineStore\", \"LocalBusiness\", etc.), mark as found.\n# 4. If any script satisfies step 3, the check passes; otherwise, it fails.\n"
    },
    "pass_condition": "At least one JSON-LD script contains an \"@type\" value that is \"Organization\" or a recognized subtype of Organization.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No Organization structured data found in JSON-LD scripts."
    ],
    "references": [
      {
        "doc_title": "Organization structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/organization",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "organization", "json-ld"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes a JSON-LD script with @type \"Organization\".",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Organization\",\n  \"name\": \"Example Corp\",\n  \"url\": \"https://www.example.com\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Page does not contain any Organization JSON-LD script.",
        "snippet": "<p>No structured data on this page.</p>\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass when Organization markup present",
        "input_stub": {
          "html": "<html><head>\n<script type=\"application/ld+json\">\n{\"@context\":\"https://schema.org\",\"@type\":\"Organization\",\"name\":\"Example\"}\n</script>\n</head><body></body></html>\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail when no Organization markup",
        "input_stub": {
          "html": "<html><head></head><body><p>No structured data.</p></body></html>\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SHIPPINGSERVICE_REQUIRED_SHIPPINGCONDITIONS",
    "title": "ShippingService must include shippingConditions property",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "shippingConditions is a required property for ShippingService to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing JSON\u2011LD script."
      }
    ],
    "preconditions": [
      "JSON\u2011LD contains an object with \"@type\": \"ShippingService\""
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse the JSON and verify that the ShippingService object has a non\u2011empty shippingConditions array."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block, parse JSON.\n# 3. Locate object where \"@type\" == \"ShippingService\".\n# 4. If such object exists, check if \"shippingConditions\" key exists and is an array with length >= 1.\n# 5. Set result = pass if condition true, else fail.\n"
    },
    "pass_condition": "shippingConditions property exists and contains at least one entry.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": null,
      "notes": "Minimum one shipping condition required."
    },
    "fail_messages": [
      "Missing or empty shippingConditions property in ShippingService."
    ],
    "references": [
      {
        "doc_title": "Merchant Shipping Policy Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/shipping-policy",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "shipping"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ShippingService with a populated shippingConditions array.",
        "snippet": "\"hasShippingService\": {\n  \"@type\": \"ShippingService\",\n  \"shippingConditions\": [ { \"@type\": \"ShippingConditions\", ... } ]\n}\n"
      },
      "failing": {
        "description": "ShippingService missing shippingConditions.",
        "snippet": "\"hasShippingService\": {\n  \"@type\": \"ShippingService\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass when shippingConditions present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ShippingService\",\"shippingConditions\":[{}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail when shippingConditions absent",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ShippingService\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DEFINEDREGION_REQUIRED_ADDRESSCOUNTRY",
    "title": "DefinedRegion must include addressCountry property",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "addressCountry is required to identify the destination region for shipping conditions.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML containing JSON\u2011LD."
      }
    ],
    "preconditions": [
      "JSON\u2011LD contains an object with \"@type\": \"DefinedRegion\""
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON and verify each DefinedRegion object has an addressCountry field."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD scripts.\n# 2. Parse JSON.\n# 3. For each object where \"@type\" == \"DefinedRegion\":\n#    a. Check if \"addressCountry\" key exists and is a non\u2011empty string.\n# 4. Pass if all DefinedRegion objects satisfy the check; otherwise fail.\n"
    },
    "pass_condition": "Every DefinedRegion object includes a non\u2011empty addressCountry.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "N/A"
    },
    "fail_messages": [
      "DefinedRegion missing required addressCountry property."
    ],
    "references": [
      {
        "doc_title": "Merchant Shipping Policy Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/shipping-policy",
        "section_title": "DefinedRegion",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "shipping"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "DefinedRegion with addressCountry.",
        "snippet": "\"shippingDestination\": [\n  { \"@type\": \"DefinedRegion\", \"addressCountry\": \"US\" }\n]\n"
      },
      "failing": {
        "description": "DefinedRegion without addressCountry.",
        "snippet": "\"shippingDestination\": [\n  { \"@type\": \"DefinedRegion\" }\n]\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with addressCountry",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"DefinedRegion\",\"addressCountry\":\"US\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail without addressCountry",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"DefinedRegion\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MONETARYAMOUNT_REQUIRED_PROPERTIES",
    "title": "MonetaryAmount must include currency, minValue, and maxValue",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "These properties define the monetary range for order values or shipping rates.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML with JSON\u2011LD."
      }
    ],
    "preconditions": [
      "JSON\u2011LD contains an object with \"@type\": \"MonetaryAmount\""
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse each MonetaryAmount object and verify presence of currency, minValue, and maxValue."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD.\n# 2. Parse JSON.\n# 3. For each object where \"@type\" == \"MonetaryAmount\":\n#    a. Verify keys \"currency\", \"minValue\", \"maxValue\" exist.\n#    b. Ensure values are non\u2011empty (currency string, numeric min/max).\n# 4. Pass if all MonetaryAmount objects satisfy; otherwise fail.\n"
    },
    "pass_condition": "All MonetaryAmount objects contain currency, minValue, and maxValue.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "N/A"
    },
    "fail_messages": [
      "MonetaryAmount missing one of required properties: currency, minValue, maxValue."
    ],
    "references": [
      {
        "doc_title": "Merchant Shipping Policy Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/shipping-policy",
        "section_title": "MonetaryAmount (in the context of shipping conditions)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "monetary"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Complete MonetaryAmount.",
        "snippet": "\"orderValue\": {\n  \"@type\": \"MonetaryAmount\",\n  \"currency\": \"USD\",\n  \"minValue\": 0,\n  \"maxValue\": 29.99\n}\n"
      },
      "failing": {
        "description": "MonetaryAmount missing maxValue.",
        "snippet": "\"orderValue\": {\n  \"@type\": \"MonetaryAmount\",\n  \"currency\": \"USD\",\n  \"minValue\": 0\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with all required fields",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"MonetaryAmount\",\"currency\":\"USD\",\"minValue\":0,\"maxValue\":10}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail missing maxValue",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"MonetaryAmount\",\"currency\":\"USD\",\"minValue\":0}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MONETARYAMOUNT_RATE_REQUIRED_PROPERTIES",
    "title": "MonetaryAmount used for shippingRate must include currency and either value or maxValue",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Shipping rate must specify a monetary amount; either a fixed value or an upper bound is required.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML containing JSON\u2011LD."
      }
    ],
    "preconditions": [
      "JSON\u2011LD contains a MonetaryAmount object under a shippingRate property"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Locate each MonetaryAmount within a shippingRate and verify currency plus (value or maxValue)."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD.\n# 2. For each object where parent key is \"shippingRate\" and child \"@type\" == \"MonetaryAmount\":\n#    a. Check \"currency\" exists.\n#    b. Check that either \"value\" exists OR \"maxValue\" exists.\n# 3. Pass if all such objects satisfy; otherwise fail.\n"
    },
    "pass_condition": "ShippingRate MonetaryAmount includes currency and (value or maxValue).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "N/A"
    },
    "fail_messages": [
      "ShippingRate MonetaryAmount missing currency or both value and maxValue."
    ],
    "references": [
      {
        "doc_title": "Merchant Shipping Policy Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/shipping-policy",
        "section_title": "MonetaryAmount (in the context of shipping rate)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "shipping_rate"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ShippingRate with currency and value.",
        "snippet": "\"shippingRate\": {\n  \"@type\": \"MonetaryAmount\",\n  \"currency\": \"USD\",\n  \"value\": 3.49\n}\n"
      },
      "failing": {
        "description": "ShippingRate missing value/maxValue.",
        "snippet": "\"shippingRate\": {\n  \"@type\": \"MonetaryAmount\",\n  \"currency\": \"USD\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with value",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"MonetaryAmount\",\"currency\":\"USD\",\"value\":5}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail missing value/maxValue",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"MonetaryAmount\",\"currency\":\"USD\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SHIPPINGRATESETTINGS_REQUIRED_PERCENTAGE",
    "title": "ShippingRateSettings must include orderPercentage or weightPercentage",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Percentage fields define how the rate is calculated; at least one must be present.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML with JSON\u2011LD."
      }
    ],
    "preconditions": [
      "JSON\u2011LD contains an object with \"@type\": \"ShippingRateSettings\""
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse each ShippingRateSettings object and verify presence of orderPercentage or weightPercentage."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD.\n# 2. For each object where \"@type\" == \"ShippingRateSettings\":\n#    a. Check if \"orderPercentage\" exists OR \"weightPercentage\" exists.\n# 3. Pass if condition true for all such objects; otherwise fail.\n"
    },
    "pass_condition": "ShippingRateSettings includes either orderPercentage or weightPercentage.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "N/A"
    },
    "fail_messages": [
      "ShippingRateSettings missing both orderPercentage and weightPercentage."
    ],
    "references": [
      {
        "doc_title": "Merchant Shipping Policy Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/shipping-policy",
        "section_title": "ShippingRateSettings",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "shipping_rate"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ShippingRateSettings with orderPercentage.",
        "snippet": "\"shippingRate\": {\n  \"@type\": \"ShippingRateSettings\",\n  \"orderPercentage\": 0.10\n}\n"
      },
      "failing": {
        "description": "ShippingRateSettings without any percentage.",
        "snippet": "\"shippingRate\": {\n  \"@type\": \"ShippingRateSettings\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with orderPercentage",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ShippingRateSettings\",\"orderPercentage\":0.05}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail with no percentages",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ShippingRateSettings\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUANTITATIVEVALUE_REQUIRED_VALUE_OR_MAXVALUE_WITH_UNIT",
    "title": "QuantitativeValue must include unitCode and either value or maxValue",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Unit code defines measurement; value or maxValue provides the numeric bound.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML containing JSON\u2011LD."
      }
    ],
    "preconditions": [
      "JSON\u2011LD contains an object with \"@type\": \"QuantitativeValue\""
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse each QuantitativeValue object and verify unitCode plus (value or maxValue)."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD.\n# 2. For each object where \"@type\" == \"QuantitativeValue\":\n#    a. Verify \"unitCode\" exists.\n#    b. Verify that either \"value\" exists OR \"maxValue\" exists.\n# 3. Pass if all objects satisfy; otherwise fail.\n"
    },
    "pass_condition": "QuantitativeValue includes unitCode and (value or maxValue).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "N/A"
    },
    "fail_messages": [
      "QuantitativeValue missing unitCode or both value and maxValue."
    ],
    "references": [
      {
        "doc_title": "Merchant Shipping Policy Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/shipping-policy",
        "section_title": "QuantitativeValue",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "quantitative"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "QuantitativeValue with unitCode and maxValue.",
        "snippet": "\"duration\": {\n  \"@type\": \"QuantitativeValue\",\n  \"minValue\": 1,\n  \"maxValue\": 3,\n  \"unitCode\": \"DAY\"\n}\n"
      },
      "failing": {
        "description": "QuantitativeValue missing unitCode.",
        "snippet": "\"duration\": {\n  \"@type\": \"QuantitativeValue\",\n  \"minValue\": 1,\n  \"maxValue\": 3\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with unitCode and maxValue",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"QuantitativeValue\",\"maxValue\":5,\"unitCode\":\"DAY\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail missing unitCode",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"QuantitativeValue\",\"maxValue\":5}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "OPENINGHOURSSPECIFICATION_REQUIRED_VALIDTIME",
    "title": "OpeningHoursSpecification must include at least validFrom or validThrough",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "low",
    "scope": "page",
    "rationale": "Defines the time window for seasonal overrides; at least one bound is required.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML with JSON\u2011LD."
      }
    ],
    "preconditions": [
      "JSON\u2011LD contains an object with \"@type\": \"OpeningHoursSpecification\""
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse each OpeningHoursSpecification and check for validFrom or validThrough."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD.\n# 2. For each object where \"@type\" == \"OpeningHoursSpecification\":\n#    a. Check if \"validFrom\" exists OR \"validThrough\" exists.\n# 3. Pass if condition true for all such objects; otherwise fail.\n"
    },
    "pass_condition": "Each OpeningHoursSpecification includes validFrom, validThrough, or both.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "N/A"
    },
    "fail_messages": [
      "OpeningHoursSpecification missing both validFrom and validThrough."
    ],
    "references": [
      {
        "doc_title": "Merchant Shipping Policy Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/shipping-policy",
        "section_title": "OpeningHoursSpecification",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "seasonal"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "OpeningHoursSpecification with validFrom.",
        "snippet": "\"validFrom\": \"2023-12-01\"\n"
      },
      "failing": {
        "description": "OpeningHoursSpecification without any valid time.",
        "snippet": "{}\n"
      }
    },
    "test_cases": [
      {
        "name": "Pass with validFrom",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"OpeningHoursSpecification\",\"validFrom\":\"2023-12-01\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Fail with neither field",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"OpeningHoursSpecification\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BREADCRUMBLIST_HAS_ITEMLISTELEMENT",
    "title": "BreadcrumbList must include itemListElement property",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The itemListElement property is required for a BreadcrumbList to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to extract structured data scripts and markup."
      }
    ],
    "preconditions": [
      "Presence of a BreadcrumbList markup (JSON\u2011LD, RDFa, or Microdata)."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD scripts; parse objects where @type == 'BreadcrumbList'."
      },
      {
        "type": "selector",
        "selector": "ol[itemtype='https://schema.org/BreadcrumbList']",
        "attribute": null,
        "notes": "RDFa/Microdata BreadcrumbList element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html to find all <script type=\"application/ld+json\"> blocks.\n# 2. For each block, parse JSON (may be an object or array).\n# 3. For each object where \"@type\" == \"BreadcrumbList\":\n#    a. If \"itemListElement\" key exists and is non\u2011empty, mark as pass for this object.\n#    b. Otherwise, record failure.\n# 4. Additionally, search for <ol> elements with itemtype=\"https://schema.org/BreadcrumbList\".\n#    a. If such element exists, consider it a BreadcrumbList; check that it contains at least one child with property/itemprop=\"itemListElement\".\n# 5. Overall page passes if at least one BreadcrumbList with itemListElement is found.\n"
    },
    "pass_condition": "At least one BreadcrumbList markup on the page contains a non\u2011empty itemListElement property.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "BreadcrumbList missing required property 'itemListElement'."
    ],
    "references": [
      {
        "doc_title": "Structured data type definitions",
        "url": "https://developers.google.com/search/docs/appearance/breadcrumb",
        "section_title": "BreadcrumbList required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "breadcrumb", "required_property"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD BreadcrumbList with itemListElement array.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"BreadcrumbList\",\n  \"itemListElement\": [{ \"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\",\"item\":\"https://example.com/books\"}]\n}\n</script>\n"
      },
      "failing": {
        "description": "BreadcrumbList without itemListElement.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"BreadcrumbList\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "jsonld_with_itemlistelement",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\",\"item\":\"https://example.com/books\"}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "jsonld_missing_itemlistelement",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BREADCRUMBLIST_MINIMUM_LISTITEM_COUNT",
    "title": "BreadcrumbList must contain at least two ListItem entries",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires a BreadcrumbList to have a minimum of two ListItems to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": ["BreadcrumbList markup with itemListElement present."],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD BreadcrumbList objects."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract all JSON\u2011LD scripts.\n# 2. Parse each script; for each object where \"@type\" == \"BreadcrumbList\":\n#    a. Retrieve the \"itemListElement\" array.\n#    b. Count the number of entries.\n#    c. Pass if count >= 2; otherwise record failure.\n# 3. If no BreadcrumbList found, not applicable.\n"
    },
    "pass_condition": "Each BreadcrumbList on the page has at least two ListItem objects in its itemListElement array.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 2,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["BreadcrumbList contains fewer than 2 ListItem entries."],
    "references": [
      {
        "doc_title": "Structured data type definitions",
        "url": "https://developers.google.com/search/docs/appearance/breadcrumb",
        "section_title": "BreadcrumbList required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "breadcrumb", "listitem_count"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "BreadcrumbList with three ListItems.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"BreadcrumbList\",\n  \"itemListElement\":[\n    {\"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\",\"item\":\"https://example.com/books\"},\n    {\"@type\":\"ListItem\",\"position\":2,\"name\":\"Science Fiction\",\"item\":\"https://example.com/books/sciencefiction\"},\n    {\"@type\":\"ListItem\",\"position\":3,\"name\":\"Award Winners\"}\n  ]\n}\n</script>\n"
      },
      "failing": {
        "description": "BreadcrumbList with only one ListItem.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"BreadcrumbList\",\n  \"itemListElement\":[\n    {\"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\",\"item\":\"https://example.com/books\"}\n  ]\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "breadcrumblist_three_items",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\",\"item\":\"https://example.com/books\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Science Fiction\",\"item\":\"https://example.com/books/sciencefiction\"},{\"@type\":\"ListItem\",\"position\":3,\"name\":\"Award Winners\"}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "breadcrumblist_one_item",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\",\"item\":\"https://example.com/books\"}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LISTITEM_HAS_REQUIRED_PROPERTIES",
    "title": "Each ListItem must include item, name, and position properties",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The item, name, and position properties are required for each ListItem to be valid for breadcrumb rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": ["BreadcrumbList with itemListElement present."],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD BreadcrumbList objects and their ListItem entries."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract JSON\u2011LD scripts.\n# 2. For each object where \"@type\" == \"BreadcrumbList\":\n#    a. For each entry in \"itemListElement\":\n#       i. Verify that keys \"item\", \"name\", and \"position\" exist.\n#       ii. If any key missing, record which property is absent for that ListItem.\n# 3. Pass if all ListItems contain all three required properties.\n"
    },
    "pass_condition": "Every ListItem in every BreadcrumbList on the page contains the properties item, name, and position.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["ListItem missing required property '${missing}'."],
    "references": [
      {
        "doc_title": "Structured data type definitions",
        "url": "https://developers.google.com/search/docs/appearance/breadcrumb",
        "section_title": "ListItem required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "breadcrumb", "listitem_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ListItem with all required fields.",
        "snippet": "{\n  \"@type\":\"ListItem\",\n  \"position\":1,\n  \"name\":\"Books\",\n  \"item\":\"https://example.com/books\"\n}\n"
      },
      "failing": {
        "description": "ListItem missing the 'item' property.",
        "snippet": "{\n  \"@type\":\"ListItem\",\n  \"position\":1,\n  \"name\":\"Books\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "listitem_all_properties",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\",\"item\":\"https://example.com/books\"}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "listitem_missing_item",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"BreadcrumbList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Books\"}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_ITEMLIST_ELEMENT_PRESENT",
    "title": "ItemList must contain itemListElement property",
    "category": "ItemList",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "The ItemList schema requires the itemListElement array to define the list items for carousel eligibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the JSON\u2011LD script."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML and locate <script type=\"application/ld+json\">.\n# 2. Parse the JSON content.\n# 3. If top\u2011level \"@type\" equals \"ItemList\":\n#    a. Check if key \"itemListElement\" exists.\n#    b. Set result = true if present, else false.\n"
    },
    "pass_condition": "JSON object has an \"itemListElement\" key.",
    "fail_messages": [
      "ItemList markup missing required 'itemListElement' property."
    ],
    "references": [
      {
        "doc_title": "Carousel (ItemList) Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["ItemList", "required"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ItemList with itemListElement array present.",
        "snippet": "<script type=\"application/ld+json\">\n{\"@type\":\"ItemList\",\"itemListElement\":[...]}\n</script>\n"
      },
      "failing": {
        "description": "ItemList JSON missing itemListElement.",
        "snippet": "<script type=\"application/ld+json\">\n{\"@type\":\"ItemList\"}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "itemlist_with_element",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "itemlist_without_element",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_SUMMARY_LISTITEM_PROPERTIES",
    "title": "Summary page ListItem must contain only type, position, and url",
    "category": "ListItem",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Summary pages are required to expose only minimal properties to avoid over\u2011specifying content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the summary page."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract each ListItem object."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD from script tags.\n# 2. For each object where \"@type\" == \"ListItem\":\n#    a. Collect its keys.\n#    b. Allowed keys = {\"@type\",\"position\",\"url\"}.\n#    c. If any other key present, fail.\n"
    },
    "pass_condition": "Every ListItem contains only the allowed three properties.",
    "fail_messages": [
      "ListItem on summary page includes prohibited property '${prop}'."
    ],
    "references": [
      {
        "doc_title": "Carousel (ItemList) Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "Summary pages",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["ListItem", "summary"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ListItem with only position and url.",
        "snippet": "{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/a.html\"}\n"
      },
      "failing": {
        "description": "ListItem with extra property.",
        "snippet": "{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/a.html\",\"name\":\"A\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "summary_valid",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/a.html\"}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "summary_extra_prop",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/a.html\",\"name\":\"A\"}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_ALLINONE_LISTITEM_REQUIRED_PROPERTIES",
    "title": "All\u2011in\u2011one page ListItem must include item, item.name, item.url, and position",
    "category": "ListItem",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Full\u2011page lists need complete item data for each carousel entry.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the all\u2011in\u2011one page."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract ListItem objects."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD.\n# 2. For each ListItem:\n#    a. Verify keys \"position\" and \"item\" exist.\n#    b. Within \"item\", verify \"name\" and \"url\" exist.\n#    c. If any missing, fail.\n"
    },
    "pass_condition": "Every ListItem has position, item, item.name, and item.url.",
    "fail_messages": ["ListItem missing required property '${missing}'."],
    "references": [
      {
        "doc_title": "Carousel (ItemList) Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "All-in-one pages",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["ListItem", "all-in-one"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ListItem with required fields.",
        "snippet": "{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Movie\",\"name\":\"A\",\"url\":\"https://example.com/a\"}}\n"
      },
      "failing": {
        "description": "Missing item.name.",
        "snippet": "{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Movie\",\"url\":\"https://example.com/a\"}}\n"
      }
    },
    "test_cases": [
      {
        "name": "allinone_valid",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Movie\",\"name\":\"A\",\"url\":\"https://example.com/a\"}}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "allinone_missing_name",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Movie\",\"url\":\"https://example.com/a\"}}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_UNIFORM_ITEM_TYPE",
    "title": "All items in a carousel must be of the same @type",
    "category": "Guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Mixed types prevent a coherent carousel rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full page HTML."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract each ListItem's type."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD.\n# 2. For each ListItem:\n#    a. If summary page: type = ListItem[\"@type\"] (always ListItem) -> look at target page's type is not available here.\n#    b. For all\u2011in\u2011one: item_type = ListItem[\"item\"][\"@type\"].\n# 3. Collect set of observed item types.\n# 4. Pass if set size == 1, else fail.\n"
    },
    "pass_condition": "All observed item types are identical.",
    "fail_messages": ["Carousel contains mixed item types: ${types}."],
    "references": [
      {
        "doc_title": "Carousel (ItemList) Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["consistency"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All ListItem items are Movie.",
        "snippet": "{\"item\":{\"@type\":\"Movie\",...}}\n"
      },
      "failing": {
        "description": "Mix of Movie and Recipe.",
        "snippet": "{\"item\":{\"@type\":\"Movie\",...}}, {\"item\":{\"@type\":\"Recipe\",...}}\n"
      }
    },
    "test_cases": [
      {
        "name": "uniform_type",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Movie\",\"name\":\"A\",\"url\":\"https://ex.com/a\"}},{\"@type\":\"ListItem\",\"position\":2,\"item\":{\"@type\":\"Movie\",\"name\":\"B\",\"url\":\"https://ex.com/b\"}}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "mixed_type",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Movie\",\"name\":\"A\",\"url\":\"https://ex.com/a\"}},{\"@type\":\"ListItem\",\"position\":2,\"item\":{\"@type\":\"Recipe\",\"name\":\"B\",\"url\":\"https://ex.com/b\"}}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_SUMMARY_URLS_SAME_DOMAIN_UNIQUE",
    "title": "Summary page URLs must be unique and on the same domain",
    "category": "ListItem",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Ensures each carousel entry points to a distinct page within the same site.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the summary page."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract each ListItem's url."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD.\n# 2. For each ListItem, collect url string.\n# 3. Parse domain from each url.\n# 4. Fail if any duplicate url.\n# 5. Fail if more than one distinct domain observed.\n"
    },
    "pass_condition": "All URLs are unique and share a single domain.",
    "fail_messages": [
      "Duplicate URL found: ${url}.",
      "Multiple domains detected: ${domains}."
    ],
    "references": [
      {
        "doc_title": "Carousel (ItemList) Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "Summary pages",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["url", "summary"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Three distinct URLs on example.com.",
        "snippet": "\"url\":\"https://example.com/a.html\"\n"
      },
      "failing": {
        "description": "Duplicate URL.",
        "snippet": "\"url\":\"https://example.com/a.html\", \"url\":\"https://example.com/a.html\"\n"
      }
    },
    "test_cases": [
      {
        "name": "unique_same_domain",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/a.html\"},{\"@type\":\"ListItem\",\"position\":2,\"url\":\"https://example.com/b.html\"}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "duplicate_url",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/a.html\"},{\"@type\":\"ListItem\",\"position\":2,\"url\":\"https://example.com/a.html\"}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CHECK_PAGE_NOT_BLOCKED_ROBOTS_NOINDEX",
    "title": "Page must not be blocked by robots.txt or contain a noindex meta tag",
    "category": "Accessibility",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google must be able to crawl and index the page for the carousel to appear in search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML."
      },
      {
        "name": "robots_txt",
        "required": false,
        "description": "Content of the site's robots.txt file."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Look for noindex directive."
      },
      {
        "type": "regex",
        "selector": "User-agent: \\*\\s*Disallow: (.*)",
        "attribute": null,
        "notes": "Extract disallowed paths."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML for <meta name=\"robots\" content=\"...\">.\n# 2. If content includes \"noindex\", fail.\n# 3. If robots_txt provided:\n#    a. Determine page path from URL (assume input includes url field if needed).\n#    b. If path matches any Disallow rule, fail.\n"
    },
    "pass_condition": "No noindex meta tag and path not disallowed by robots.txt.",
    "fail_messages": [
      "Page contains meta robots noindex directive.",
      "Page path '${path}' is disallowed by robots.txt."
    ],
    "references": [
      {
        "doc_title": "Carousel (ItemList) Structured Data",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "Validate and deploy structured data",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["crawlability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No robots blocking.",
        "snippet": "<meta name=\"robots\" content=\"index,follow\">\n"
      },
      "failing": {
        "description": "Contains noindex.",
        "snippet": "<meta name=\"robots\" content=\"noindex\">\n"
      }
    },
    "test_cases": [
      {
        "name": "not_blocked",
        "input_stub": {
          "html": "<meta name='robots' content='index,follow'>",
          "robots_txt": "User-agent: *\nDisallow: /private/"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "meta_noindex",
        "input_stub": {
          "html": "<meta name='robots' content='noindex'>",
          "robots_txt": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MERCHANT_RETURN_POLICY_REQUIRED_PROPERTIES",
    "title": "Required properties for MerchantReturnPolicy (Option A or B)",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Required properties must be present for the MerchantReturnPolicy markup to be eligible for rich results in Google Search.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the structured data."
      }
    ],
    "preconditions": [
      "MerchantReturnPolicy object is present in a script[type=\"application/ld+json\"] block."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract JSON and locate the MerchantReturnPolicy object (nested under Organization via hasMerchantReturnPolicy)."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse all <script type=\"application/ld+json\"> blocks from the HTML.\n# 2. For each JSON block, locate an object where \"@type\" == \"MerchantReturnPolicy\".\n# 3. If no such object, mark check as not_applicable.\n# 4. Within the MerchantReturnPolicy object, evaluate:\n#    a. has_applicableCountry = \"applicableCountry\" key exists.\n#    b. has_returnPolicyCategory = \"returnPolicyCategory\" key exists.\n#    c. has_merchantReturnLink = \"merchantReturnLink\" key exists.\n# 5. Pass if (has_applicableCountry AND has_returnPolicyCategory) OR has_merchantReturnLink.\n# 6. Otherwise, fail.\n"
    },
    "pass_condition": "Either both \"applicableCountry\" and \"returnPolicyCategory\" are present, or \"merchantReturnLink\" is present in the MerchantReturnPolicy object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required properties: ${missing_properties} in MerchantReturnPolicy."
    ],
    "references": [
      {
        "doc_title": "Merchant Return Policy Structured Data (MerchantReturnPolicy) | Google Search Central",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/merchant-return-policy",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": [
      "structured_data",
      "merchant_return_policy",
      "required_properties"
    ],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "MerchantReturnPolicy includes applicableCountry and returnPolicyCategory.",
        "snippet": "{\n  \"@type\": \"MerchantReturnPolicy\",\n  \"applicableCountry\": [\"DE\"],\n  \"returnPolicyCategory\": \"https://schema.org/MerchantReturnFiniteReturnWindow\"\n}\n"
      },
      "failing": {
        "description": "MerchantReturnPolicy missing both required sets.",
        "snippet": "{\n  \"@type\": \"MerchantReturnPolicy\",\n  \"merchantReturnDays\": 30\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "option_a_present",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"MerchantReturnPolicy\", \"applicableCountry\":[\"DE\"], \"returnPolicyCategory\":\"https://schema.org/MerchantReturnFiniteReturnWindow\" }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "option_b_present",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"MerchantReturnPolicy\", \"merchantReturnLink\":\"https://example.com/return\" }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_required",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"MerchantReturnPolicy\", \"merchantReturnDays\":30 }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MERCHANT_RETURN_POLICY_SEASONAL_OVERRIDE_REQUIRED_PROPERTIES",
    "title": "Required properties for seasonal override in MerchantReturnPolicy",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "When a seasonal override is defined, its required properties must be present for Google to interpret the override correctly.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the structured data."
      }
    ],
    "preconditions": [
      "MerchantReturnPolicy object contains a \"returnPolicySeasonalOverride\" property."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract JSON and locate the returnPolicySeasonalOverride object within MerchantReturnPolicy."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse all <script type=\"application/ld+json\"> blocks.\n# 2. Find MerchantReturnPolicy object.\n# 3. If \"returnPolicySeasonalOverride\" not present, mark check as not_applicable.\n# 4. Within the \"returnPolicySeasonalOverride\" object, verify:\n#    a. \"returnPolicyCategory\" key exists.\n#    b. (Optional) \"startDate\", \"endDate\", \"merchantReturnDays\" may be present but are not required here.\n# 5. Pass if \"returnPolicyCategory\" exists; otherwise fail.\n"
    },
    "pass_condition": "The \"returnPolicySeasonalOverride\" object includes the required property \"returnPolicyCategory\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Seasonal override missing required property 'returnPolicyCategory'."
    ],
    "references": [
      {
        "doc_title": "Merchant Return Policy Structured Data (MerchantReturnPolicy) | Google Search Central",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/merchant-return-policy",
        "section_title": "Seasonal override properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "merchant_return_policy", "seasonal_override"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Seasonal override includes required returnPolicyCategory.",
        "snippet": "\"returnPolicySeasonalOverride\": {\n  \"@type\": \"MerchantReturnPolicySeasonalOverride\",\n  \"returnPolicyCategory\": \"https://schema.org/MerchantReturnFiniteReturnWindow\",\n  \"startDate\": \"2025-12-01\",\n  \"endDate\": \"2025-01-05\",\n  \"merchantReturnDays\": 30\n}\n"
      },
      "failing": {
        "description": "Seasonal override missing returnPolicyCategory.",
        "snippet": "\"returnPolicySeasonalOverride\": {\n  \"@type\": \"MerchantReturnPolicySeasonalOverride\",\n  \"startDate\": \"2025-12-01\",\n  \"endDate\": \"2025-01-05\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "seasonal_override_complete",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"MerchantReturnPolicy\", \"returnPolicySeasonalOverride\":{ \"@type\":\"MerchantReturnPolicySeasonalOverride\", \"returnPolicyCategory\":\"https://schema.org/MerchantReturnFiniteReturnWindow\" } }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "seasonal_override_missing_category",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"MerchantReturnPolicy\", \"returnPolicySeasonalOverride\":{ \"@type\":\"MerchantReturnPolicySeasonalOverride\", \"startDate\":\"2025-12-01\" } }</script>"
        },
        "expected_outcome": "fail"
      },
      {
        "name": "no_seasonal_override",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"MerchantReturnPolicy\", \"merchantReturnDays\":60 }</script>"
        },
        "expected_outcome": "not_applicable"
      }
    ]
  },
  {
    "id": "ONE_FAQPAGE_DEFINITION",
    "title": "Exactly one FAQPage type definition per page",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires a single FAQPage markup per page for eligibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks and count occurrences of \"@type\":\"FAQPage\""
      },
      {
        "type": "selector",
        "selector": "[itemscope][itemtype*='FAQPage']",
        "attribute": null,
        "notes": "Count microdata FAQPage items"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\njson_ld_blocks = extract_all_script_tags(html, type='application/ld+json')\nfaqpage_json_count = 0\nfor block in json_ld_blocks:\n    data = parse_json(block)\n    if data.get('@type') == 'FAQPage':\n        faqpage_json_count += 1\nmicrodata_faqpage_count = count_elements(html, selector=\"[itemscope][itemtype*='FAQPage']\")\ntotal_faqpage = faqpage_json_count + microdata_faqpage_count\npass if total_faqpage == 1 else fail\n"
    },
    "pass_condition": "Exactly one FAQPage markup (JSON\u2011LD or microdata) is present.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 1,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found ${observed} FAQPage definitions; exactly one is required."
    ],
    "references": [
      {
        "doc_title": "FAQ structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/faq",
        "section_title": "FAQPage",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "faqpage"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a single JSON\u2011LD FAQPage block.",
        "snippet": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",...}</script>"
      },
      "failing": {
        "description": "Page contains two FAQPage definitions.",
        "snippet": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",...}</script><div itemscope itemtype='https://schema.org/FAQPage'></div>"
      }
    },
    "test_cases": [
      {
        "name": "Single JSON-LD FAQPage",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@type\":\"FAQPage\",\"mainEntity\":[]}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Two FAQPage definitions",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@type\":\"FAQPage\"}</script></head><body><div itemscope itemtype='https://schema.org/FAQPage'></div></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FAQPAGE_REQUIRED_PROPERTIES",
    "title": "FAQPage must include required property mainEntity",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The mainEntity array holds the list of questions; without it the FAQ cannot be rendered.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON-LD FAQPage and verify presence of \"mainEntity\""
      },
      {
        "type": "selector",
        "selector": "[itemscope][itemtype*='FAQPage']",
        "attribute": null,
        "notes": "For microdata, check that an element with itemprop='mainEntity' exists"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\njson_ld_blocks = extract_all_script_tags(html, type='application/ld+json')\nfor block in json_ld_blocks:\n    data = parse_json(block)\n    if data.get('@type') == 'FAQPage':\n        if 'mainEntity' in data:\n            pass\n        else:\n            fail\n# Microdata check\nfaq_micro = select_elements(html, \"[itemscope][itemtype*='FAQPage']\")\nfor elem in faq_micro:\n    if has_descendant(elem, \"[itemprop='mainEntity']\"):\n        pass\n    else:\n        fail\n"
    },
    "pass_condition": "The FAQPage markup contains a mainEntity property (JSON\u2011LD) or an itemprop=\"mainEntity\" (microdata).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "FAQPage markup is missing the required mainEntity property."
    ],
    "references": [
      {
        "doc_title": "FAQ structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/faq",
        "section_title": "FAQPage",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "required-property"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD FAQPage includes \"mainEntity\".",
        "snippet": "{\"@type\":\"FAQPage\",\"mainEntity\":[...]}"
      },
      "failing": {
        "description": "FAQPage without mainEntity.",
        "snippet": "{\"@type\":\"FAQPage\"}"
      }
    },
    "test_cases": [
      {
        "name": "FAQPage with mainEntity",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",\"mainEntity\":[]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "FAQPage missing mainEntity",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"FAQPage\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUESTION_REQUIRED_PROPERTIES",
    "title": "Each Question must have name and acceptedAnswer",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires both the question text and its answer to render the rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Iterate over each object in mainEntity where @type='Question'"
      },
      {
        "type": "selector",
        "selector": "[itemscope][itemtype*='Question']",
        "attribute": null,
        "notes": "Check for itemprop='name' and itemprop='acceptedAnswer' within each Question microdata block"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\njson_ld_blocks = extract_all_script_tags(html, type='application/ld+json')\nfor block in json_ld_blocks:\n    data = parse_json(block)\n    if data.get('@type') == 'FAQPage':\n        for q in data.get('mainEntity', []):\n            if q.get('@type') != 'Question':\n                continue\n            if 'name' not in q or 'acceptedAnswer' not in q:\n                fail\n# Microdata\nquestions = select_elements(html, \"[itemscope][itemtype*='Question']\")\nfor q in questions:\n    has_name = has_descendant(q, \"[itemprop='name']\")\n    has_answer = has_descendant(q, \"[itemprop='acceptedAnswer']\")\n    if not (has_name and has_answer):\n        fail\npass\n"
    },
    "pass_condition": "Every Question object includes both a name and an acceptedAnswer.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Question at index ${index} is missing ${missing_fields}."
    ],
    "references": [
      {
        "doc_title": "FAQ structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/faq",
        "section_title": "Question",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "question"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Question includes name and acceptedAnswer.",
        "snippet": "{\"@type\":\"Question\",\"name\":\"How?\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"...\"}}"
      },
      "failing": {
        "description": "Question missing acceptedAnswer.",
        "snippet": "{\"@type\":\"Question\",\"name\":\"How?\"}"
      }
    },
    "test_cases": [
      {
        "name": "Question with both fields",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",\"mainEntity\":[{\"@type\":\"Question\",\"name\":\"Q?\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"A\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Question missing answer",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",\"mainEntity\":[{\"@type\":\"Question\",\"name\":\"Q?\"}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ANSWER_REQUIRED_PROPERTIES",
    "title": "Each Answer must contain text property",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The answer text is required for the rich result to display content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Within each Question's acceptedAnswer, verify presence of \"text\""
      },
      {
        "type": "selector",
        "selector": "[itemscope][itemtype*='Answer']",
        "attribute": null,
        "notes": "Check for itemprop='text' inside each Answer microdata block"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\njson_ld_blocks = extract_all_script_tags(html, type='application/ld+json')\nfor block in json_ld_blocks:\n    data = parse_json(block)\n    if data.get('@type') == 'FAQPage':\n        for q in data.get('mainEntity', []):\n            ans = q.get('acceptedAnswer', {})\n            if ans.get('@type') != 'Answer' or 'text' not in ans:\n                fail\n# Microdata\nanswers = select_elements(html, \"[itemscope][itemtype*='Answer']\")\nfor a in answers:\n    if not has_descendant(a, \"[itemprop='text']\"):\n        fail\npass\n"
    },
    "pass_condition": "Every Answer object includes a text property (JSON\u2011LD) or itemprop=\"text\" (microdata).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Answer for question '${question}' is missing the required text property."
    ],
    "references": [
      {
        "doc_title": "FAQ structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/faq",
        "section_title": "Answer",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "answer"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Answer includes text.",
        "snippet": "{\"@type\":\"Answer\",\"text\":\"The answer.\"}"
      },
      "failing": {
        "description": "Answer missing text.",
        "snippet": "{\"@type\":\"Answer\"}"
      }
    },
    "test_cases": [
      {
        "name": "Answer with text",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",\"mainEntity\":[{\"@type\":\"Question\",\"name\":\"Q?\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"A\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Answer without text",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",\"mainEntity\":[{\"@type\":\"Question\",\"name\":\"Q?\",\"acceptedAnswer\":{\"@type\":\"Answer\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FAQ_CONTENT_VISIBILITY",
    "title": "FAQ question and answer text must be visible to users on the page",
    "category": "Content guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google only displays rich results if the content is actually visible to users.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "[itemprop='name']",
        "attribute": null,
        "notes": "Extract visible text of each Question name"
      },
      {
        "type": "selector",
        "selector": "[itemprop='text']",
        "attribute": null,
        "notes": "Extract visible text of each Answer text"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\nquestions = select_texts(html, \"[itemprop='name']\")\nanswers = select_texts(html, \"[itemprop='text']\")\n# Also extract from JSON-LD for comparison\njson_ld = extract_all_script_tags(html, type='application/ld+json')\nfor block in json_ld:\n    data = parse_json(block)\n    if data.get('@type') == 'FAQPage':\n        for q in data.get('mainEntity', []):\n            q_name = q.get('name')\n            ans_text = q.get('acceptedAnswer', {}).get('text')\n            if not q_name or not ans_text:\n                continue\n            if q_name not in questions:\n                fail\n            if strip_html(ans_text) not in answers:\n                fail\npass\n"
    },
    "pass_condition": "Every question name and answer text defined in the markup also appears in the visible HTML text.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Question '${question}' or its answer is not visible in the page content."
    ],
    "references": [
      {
        "doc_title": "FAQ structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/faq",
        "section_title": "Content guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["visibility", "content"],
    "insufficient_evidence": false,
    "notes": "Visibility is assessed by presence of the exact text strings in the rendered HTML.",
    "examples": {
      "passing": {
        "description": "Question and answer texts are present in visible HTML.",
        "snippet": "<h2 itemprop='name'>How to find an apprenticeship?</h2><div itemprop='text'>We provide...</div>"
      },
      "failing": {
        "description": "Answer text only exists inside JSON-LD, not in page body.",
        "snippet": "<script type='application/ld+json'>{...\"text\":\"We provide...\"...}</script>"
      }
    },
    "test_cases": [
      {
        "name": "Visible content",
        "input_stub": {
          "html": "<h2 itemprop='name'>How?</h2><div itemprop='text'>Answer.</div>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Hidden answer",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"FAQPage\",\"mainEntity\":[{\"@type\":\"Question\",\"name\":\"How?\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"Answer.\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGE_NOT_BLOCKED",
    "title": "Page must not be blocked by robots.txt, meta robots noindex, or X-Robots-Tag",
    "category": "Accessibility",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Google needs to crawl the page to render rich results.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the page"
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers of the page"
      },
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "Ensure HTTP 200 OK"
      },
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": "Check for 'noindex'"
      },
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Check for 'noindex'"
      },
      {
        "type": "regex",
        "selector": "robots_txt",
        "attribute": null,
        "notes": "Disallow rule matching the page path"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: url, http_headers, html, robots_txt\nif http_headers.status_code != 200:\n    fail\nx_robots = http_headers.get('X-Robots-Tag','')\nif 'noindex' in x_robots.lower():\n    fail\nmeta_robots = extract_meta_content(html, name='robots')\nif meta_robots and 'noindex' in meta_robots.lower():\n    fail\npath = extract_path(url)\ndisallow_rules = parse_robots_txt(robots_txt)\nfor rule in disallow_rules:\n    if path matches rule:\n        fail\npass\n"
    },
    "pass_condition": "The page returns 200, has no noindex directives, and is not disallowed by robots.txt.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Page is blocked: ${reason}."],
    "references": [
      {
        "doc_title": "FAQ structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/faq",
        "section_title": "Deploy and test",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["crawlability", "robots"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page returns 200 and no blocking directives.",
        "snippet": "HTTP/1.1 200 OK"
      },
      "failing": {
        "description": "robots.txt contains Disallow for the page path.",
        "snippet": "User-agent: *\nDisallow: /faq/"
      }
    },
    "test_cases": [
      {
        "name": "Accessible page",
        "input_stub": {
          "url": "https://example.com/faq",
          "http_headers": {
            "status_code": 200,
            "X-Robots-Tag": ""
          },
          "html": "<html></html>",
          "robots_txt": "User-agent: *\nDisallow: /private/",
          "sitemap_xml": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Blocked by noindex meta",
        "input_stub": {
          "url": "https://example.com/faq",
          "http_headers": {
            "status_code": 200,
            "X-Robots-Tag": ""
          },
          "html": "<meta name='robots' content='noindex'>",
          "robots_txt": "",
          "sitemap_xml": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RECIPE_REQUIRED_IMAGE",
    "title": "Recipe must include image property",
    "category": "Recipe",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Image is a required property for Recipe structured data to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the Recipe JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"image\"\\s*:\\s*\\[",
        "attribute": null,
        "notes": "Detects the presence of the image array in the Recipe JSON\u2011LD script."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks from html.\n# 2. For each block, if it contains \"\\\"@type\\\": \\\"Recipe\\\"\":\n#    a. Search for regex \"\\\"image\\\"\\\\s*:\\\\s*\\\\[\".\n#    b. If found, set has_image = true.\n# 3. If any Recipe block has_image is true, pass; else fail.\n"
    },
    "pass_condition": "At least one Recipe JSON\u2011LD block contains an image property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Recipe structured data is missing the required 'image' property."
    ],
    "references": [
      {
        "doc_title": "Recipe structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/recipe",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "recipe"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Recipe JSON\u2011LD includes an image array.",
        "snippet": "\"image\": [\"https://example.com/photo.jpg\"]\n"
      },
      "failing": {
        "description": "Recipe JSON\u2011LD lacks an image property.",
        "snippet": "// no \"image\" field present\n"
      }
    },
    "test_cases": [
      {
        "name": "Recipe with image",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\": \"Recipe\", \"image\": [\"https://example.com/photo.jpg\"] }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Recipe without image",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\": \"Recipe\" }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RECIPE_REQUIRED_NAME",
    "title": "Recipe must include name property",
    "category": "Recipe",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Name is a required property for Recipe structured data to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the Recipe JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"name\"\\s*:\\s*\"[^\"]+\"",
        "attribute": null,
        "notes": "Detects the name field in the Recipe JSON\u2011LD script."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block containing \"\\\"@type\\\": \\\"Recipe\\\"\":\n#    a. Search for regex \"\\\"name\\\"\\\\s*:\\\\s*\\\"[^\\\"]+\\\"\".\n#    b. If found, set has_name = true.\n# 3. Pass if any Recipe block has_name is true; otherwise fail.\n"
    },
    "pass_condition": "At least one Recipe JSON\u2011LD block contains a non\u2011empty name property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Recipe structured data is missing the required 'name' property."
    ],
    "references": [
      {
        "doc_title": "Recipe structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/recipe",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "recipe"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Recipe JSON\u2011LD includes a name field.",
        "snippet": "\"name\": \"Non\u2011Alcoholic Pi\u00f1a Colada\"\n"
      },
      "failing": {
        "description": "Recipe JSON\u2011LD lacks a name field.",
        "snippet": "// no \"name\" field present\n"
      }
    },
    "test_cases": [
      {
        "name": "Recipe with name",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\": \"Recipe\", \"name\": \"Sample\" }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Recipe without name",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\": \"Recipe\" }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ITEMLIST_REQUIRED_ITEMLISTELEMENT",
    "title": "ItemList must include itemListElement property",
    "category": "ItemList",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "itemListElement is required for ItemList to be eligible for host carousel rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the ItemList JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"itemListElement\"\\s*:\\s*\\[",
        "attribute": null,
        "notes": "Detects the presence of the itemListElement array in ItemList JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block containing \"\\\"@type\\\": \\\"ItemList\\\"\":\n#    a. Search for regex \"\\\"itemListElement\\\"\\\\s*:\\\\s*\\\\[\".\n#    b. If found, set has_element = true.\n# 3. Pass if any ItemList block has_element is true; otherwise fail.\n"
    },
    "pass_condition": "At least one ItemList JSON\u2011LD block contains an itemListElement array.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "ItemList structured data is missing the required 'itemListElement' property."
    ],
    "references": [
      {
        "doc_title": "ItemList structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/recipe",
        "section_title": "ItemList required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "itemlist"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ItemList JSON\u2011LD includes itemListElement.",
        "snippet": "\"itemListElement\": [{ \"@type\": \"ListItem\", \"position\": 1, \"url\": \"https://example.com/a.html\" }]\n"
      },
      "failing": {
        "description": "ItemList JSON\u2011LD lacks itemListElement.",
        "snippet": "// no \"itemListElement\" field\n"
      }
    },
    "test_cases": [
      {
        "name": "ItemList with element",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\": \"ItemList\", \"itemListElement\": [] }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "ItemList without element",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\": \"ItemList\" }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ITEMLIST_REQUIRED_LISTITEM_POSITION",
    "title": "Each ListItem must include position property",
    "category": "ItemList",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Position is required for ListItem entries in ItemList to enable proper ordering in carousel results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the ItemList JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"position\"\\s*:\\s*\\d+",
        "attribute": null,
        "notes": "Detects a numeric position field within ListItem objects."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block with \"\\\"@type\\\": \\\"ItemList\\\"\":\n#    a. Find all occurrences of \"\\\"@type\\\": \\\"ListItem\\\"\".\n#    b. For each ListItem, verify regex \"\\\"position\\\"\\\\s*:\\\\s*\\\\d+\" exists.\n#    c. If any ListItem lacks position, set fail = true.\n# 3. Pass if no failures; otherwise fail.\n"
    },
    "pass_condition": "Every ListItem in ItemList JSON\u2011LD contains a numeric position property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "One or more ListItem entries are missing the required 'position' property."
    ],
    "references": [
      {
        "doc_title": "ItemList structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/recipe",
        "section_title": "ListItem.position required",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "itemlist"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All ListItem objects have position.",
        "snippet": "{\"@type\":\"ListItem\",\"position\":1,\"url\":\"...\"}\n"
      },
      "failing": {
        "description": "A ListItem lacks position.",
        "snippet": "{\"@type\":\"ListItem\",\"url\":\"...\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "All ListItems have position",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"url\":\"a\"},{\"@type\":\"ListItem\",\"position\":2,\"url\":\"b\"}] }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing position",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"url\":\"a\"}] }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ITEMLIST_REQUIRED_LISTITEM_URL",
    "title": "Each ListItem must include url property",
    "category": "ItemList",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "URL is required for ListItem entries to link to the individual recipe pages in carousel results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the ItemList JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"url\"\\s*:\\s*\"https?://[^\"]+\"",
        "attribute": null,
        "notes": "Detects a URL field within ListItem objects."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block with \"\\\"@type\\\": \\\"ItemList\\\"\":\n#    a. Locate each \"\\\"@type\\\": \\\"ListItem\\\"\".\n#    b. Verify each ListItem contains a \\\"url\\\" field matching an absolute URL.\n#    c. If any ListItem lacks such a url, set fail = true.\n# 3. Pass if no failures; otherwise fail.\n"
    },
    "pass_condition": "Every ListItem in ItemList JSON\u2011LD contains a valid absolute URL in the url property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "One or more ListItem entries are missing the required 'url' property."
    ],
    "references": [
      {
        "doc_title": "ItemList structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/recipe",
        "section_title": "ListItem.url required",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "itemlist"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All ListItem objects have a URL.",
        "snippet": "{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/recipe.html\"}\n"
      },
      "failing": {
        "description": "A ListItem lacks a URL.",
        "snippet": "{\"@type\":\"ListItem\",\"position\":1}\n"
      }
    },
    "test_cases": [
      {
        "name": "All ListItems have url",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"url\":\"https://example.com/a\"}] }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing url",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1}] }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RECIPE_RECOMMENDED_AGGREGATE_RATING",
    "title": "Recipe may include aggregateRating property",
    "category": "Recipe",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "page",
    "rationale": "Providing aggregateRating can enhance the rich result appearance but is not mandatory.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the Recipe JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"aggregateRating\"\\s*:\\s*\\{",
        "attribute": null,
        "notes": "Detects the presence of an aggregateRating object."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block with \"\\\"@type\\\": \\\"Recipe\\\"\":\n#    a. Search for regex \"\\\"aggregateRating\\\"\\\\s*:\\\\s*\\\\{\". \n#    b. If found, set has_rating = true.\n# 3. Pass if any Recipe block has_rating is true; otherwise not_applicable.\n"
    },
    "pass_condition": "At least one Recipe JSON\u2011LD block contains an aggregateRating object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Recipe structured data does not include an aggregateRating property."
    ],
    "references": [
      {
        "doc_title": "Recipe structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/recipe",
        "section_title": "Recommended properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "recipe"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Recipe includes aggregateRating.",
        "snippet": "\"aggregateRating\": { \"@type\":\"AggregateRating\",\"ratingValue\":5,\"ratingCount\":10 }\n"
      },
      "failing": {
        "description": "Recipe lacks aggregateRating.",
        "snippet": "// no aggregateRating field\n"
      }
    },
    "test_cases": [
      {
        "name": "With aggregateRating",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"Recipe\",\"aggregateRating\":{ \"@type\":\"AggregateRating\" } }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Without aggregateRating",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"Recipe\" }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RECIPE_RECOMMENDED_NUTRITION_CALORIES",
    "title": "Recipe may include nutrition.calories property",
    "category": "Recipe",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "page",
    "rationale": "Including calories improves user experience and may enhance rich result display.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the Recipe JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"nutrition\"\\s*:\\s*\\{[^}]*\"calories\"\\s*:\\s*\"[^\"]+\"",
        "attribute": null,
        "notes": "Detects calories field inside a nutrition object."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block with \"\\\"@type\\\": \\\"Recipe\\\"\":\n#    a. Search for regex \"\\\"nutrition\\\"\\\\s*:\\\\s*\\\\{[^}]*\\\"calories\\\"\\\\s*:\\\\s*\\\"[^\\\"]+\\\"\".\n#    b. If found, set has_calories = true.\n# 3. Pass if any Recipe block has_calories is true; otherwise not_applicable.\n"
    },
    "pass_condition": "At least one Recipe JSON\u2011LD block contains a nutrition object with a calories field.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Recipe structured data does not include nutrition.calories."
    ],
    "references": [
      {
        "doc_title": "Recipe structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/recipe",
        "section_title": "Recommended properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "recipe"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Recipe includes nutrition.calories.",
        "snippet": "\"nutrition\": { \"@type\":\"NutritionInformation\",\"calories\":\"120 calories\" }\n"
      },
      "failing": {
        "description": "Recipe lacks nutrition.calories.",
        "snippet": "// no calories field\n"
      }
    },
    "test_cases": [
      {
        "name": "With calories",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"Recipe\",\"nutrition\":{ \"@type\":\"NutritionInformation\",\"calories\":\"120 calories\" } }</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Without calories",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\":\"Recipe\" }</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MEMBERPROGRAM_REQUIRED_PROPERTIES_PRESENT",
    "title": "MemberProgram required properties present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Required properties (description, hasTiers, name) must be included for MemberProgram markup to be eligible for Google Search results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the JSON\u2011LD script."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and locate all <script type=\"application/ld+json\"> elements.\n# 2. For each script, parse its JSON content.\n# 3. Find an object where \"@type\" == \"MemberProgram\" (or where the object is nested under an Organization object).\n# 4. Verify that the object contains keys \"description\", \"hasTiers\", and \"name\".\n# 5. If any required key is missing, record which ones.\n# 6. If at least one MemberProgram object satisfies all required keys, the check passes.\n"
    },
    "pass_condition": "All required MemberProgram properties (description, hasTiers, name) are present in the markup.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "MemberProgram markup is missing required property '${missing_property}'."
    ],
    "references": [
      {
        "doc_title": "Loyalty Program Structured Data (MemberProgram)",
        "url": "https://developers.google.com/search/docs/structured-data/member-program",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "member_program", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All required properties are present.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"MemberProgram\",\n  \"name\": \"Membership Plus\",\n  \"description\": \"Top\u2011rated loyalty program\",\n  \"hasTiers\": [ { \"@type\": \"MemberProgramTier\", \"name\": \"silver\", \"hasTierBenefit\": [\"https://schema.org/TierBenefitLoyaltyPoints\"] } ]\n}\n</script>\n"
      },
      "failing": {
        "description": "Missing the \"description\" property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"MemberProgram\",\n  \"name\": \"Membership Plus\",\n  \"hasTiers\": []\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "All required properties present",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"MemberProgram\",\"name\":\"Membership Plus\",\"description\":\"desc\",\"hasTiers\":[]}</script></head></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing description",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"MemberProgram\",\"name\":\"Membership Plus\",\"hasTiers\":[]}</script></head></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MEMBERPROGRAMTIER_REQUIRED_PROPERTIES_PRESENT",
    "title": "MemberProgramTier required properties present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Each MemberProgramTier must include the required properties (hasTierBenefit, name) for the tier to be recognized by Google Search.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the JSON\u2011LD script."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and locate all <script type=\"application/ld+json\"> elements.\n# 2. For each script, parse its JSON content.\n# 3. Find the MemberProgram object (as in previous check) and retrieve its \"hasTiers\" array.\n# 4. For each tier object where \"@type\" == \"MemberProgramTier\":\n#    a. Verify that it contains keys \"hasTierBenefit\" and \"name\".\n#    b. Record any missing keys per tier.\n# 5. If every tier includes both required keys, the check passes.\n"
    },
    "pass_condition": "Every MemberProgramTier includes both required properties (hasTierBenefit and name).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "MemberProgramTier '${tier_id}' is missing required property '${missing_property}'."
    ],
    "references": [
      {
        "doc_title": "Loyalty Program Structured Data (MemberProgram)",
        "url": "https://developers.google.com/search/docs/structured-data/member-program",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "member_program_tier", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Tier includes both required properties.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"MemberProgram\",\n  \"name\": \"Membership Plus\",\n  \"description\": \"desc\",\n  \"hasTiers\": [\n    {\n      \"@type\": \"MemberProgramTier\",\n      \"name\": \"silver\",\n      \"hasTierBenefit\": [\"https://schema.org/TierBenefitLoyaltyPoints\"]\n    }\n  ]\n}\n</script>\n"
      },
      "failing": {
        "description": "Tier missing \"hasTierBenefit\".",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"MemberProgram\",\n  \"name\": \"Membership Plus\",\n  \"description\": \"desc\",\n  \"hasTiers\": [\n    {\n      \"@type\": \"MemberProgramTier\",\n      \"name\": \"silver\"\n    }\n  ]\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Tier with all required properties",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"MemberProgram\",\"name\":\"Membership Plus\",\"description\":\"desc\",\"hasTiers\":[{\"@type\":\"MemberProgramTier\",\"name\":\"silver\",\"hasTierBenefit\":[\"https://schema.org/TierBenefitLoyaltyPoints\"]}]}</script></head></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Tier missing hasTierBenefit",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"MemberProgram\",\"name\":\"Membership Plus\",\"description\":\"desc\",\"hasTiers\":[{\"@type\":\"MemberProgramTier\",\"name\":\"silver\"}]}</script></head></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AT_LEAST_THREE_COURSES",
    "title": "Minimum number of Course items",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "site",
    "rationale": "The guidelines require at least three Course entities to be marked up for eligibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page(s) to be inspected."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks and parse objects where \"@type\" == \"Course\"."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and extract all <script type=\"application/ld+json\"> contents.\n# 2. For each extracted block, parse JSON.\n# 3. Collect all objects (including nested) where \"@type\" == \"Course\".\n# 4. Count the total number of Course objects across the site.\n# 5. If count >= 3, pass; else fail.\n"
    },
    "pass_condition": "At least three Course objects are found in the site's structured data.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 3,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found ${observed} Course items; at least 3 are required."
    ],
    "references": [
      {
        "doc_title": "Course list (`Course`) structured data",
        "url": "https://developers.google.com/search/docs/appearance/course-list",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["technical", "content"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains three or more Course JSON\u2011LD blocks.",
        "snippet": "<script type=\"application/ld+json\">{ \"@type\": \"Course\", \"name\": \"A\", \"description\": \"...\" }</script> ..."
      },
      "failing": {
        "description": "Only two Course items are present.",
        "snippet": "<script type=\"application/ld+json\">{ \"@type\": \"Course\", \"name\": \"A\", \"description\": \"...\" }</script>"
      }
    },
    "test_cases": [
      {
        "name": "three_courses_present",
        "input_stub": {
          "html": "<html>... three Course JSON\u2011LD blocks ...</html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "two_courses_present",
        "input_stub": {
          "html": "<html>... two Course JSON\u2011LD blocks ...</html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "COURSE_REQUIRED_PROPERTIES",
    "title": "Required Course properties present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Each Course must include the required properties `name` and `description`.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the page containing Course markup."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON-LD and locate objects with \"@type\": \"Course\"."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all JSON-LD blocks.\n# 2. Parse each block; for each object where \"@type\" == \"Course\":\n#    a. Verify the presence of \"name\" and \"description\" keys.\n#    b. If any required key is missing or empty, record as failure.\n# 3. If all Course objects have both keys, pass; otherwise fail.\n"
    },
    "pass_condition": "Every Course object includes non\u2011empty `name` and `description` fields.",
    "threshold": null,
    "fail_messages": ["Course item missing required property ${missing}."],
    "references": [
      {
        "doc_title": "Course list (`Course`) structured data",
        "url": "https://developers.google.com/search/docs/appearance/course-list",
        "section_title": "`Course` required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["technical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Course JSON\u2011LD contains both name and description.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"Course\", \"name\":\"Intro\", \"description\":\"Learn basics.\" }\n</script>\n"
      },
      "failing": {
        "description": "Course JSON\u2011LD missing description.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"Course\", \"name\":\"Intro\" }\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "course_with_all_required",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Course\",\"name\":\"A\",\"description\":\"B\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "course_missing_description",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Course\",\"name\":\"A\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "COURSE_PROVIDER_PROPERTY",
    "title": "Course provider property present and valid",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Guidelines state each Course must have a valid `provider` property.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML containing Course structured data."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Locate Course objects and inspect their provider field."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract JSON-LD blocks.\n# 2. For each object where \"@type\" == \"Course\":\n#    a. Verify a \"provider\" object exists.\n#    b. Within provider, verify a non\u2011empty \"name\" field.\n# 3. If any Course lacks a valid provider.name, fail; otherwise pass.\n"
    },
    "pass_condition": "All Course objects contain a provider object with a non\u2011empty name.",
    "threshold": null,
    "fail_messages": ["Course item missing valid provider.name."],
    "references": [
      {
        "doc_title": "Course list (`Course`) structured data",
        "url": "https://developers.google.com/search/docs/appearance/course-list",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["technical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Course includes provider with name.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"Course\", \"name\":\"Intro\", \"description\":\"...\", \"provider\":{\"@type\":\"Organization\",\"name\":\"University\"} }\n</script>\n"
      },
      "failing": {
        "description": "Course missing provider name.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"Course\", \"name\":\"Intro\", \"description\":\"...\", \"provider\":{\"@type\":\"Organization\"} }\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "course_with_provider_name",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Course\",\"name\":\"A\",\"description\":\"B\",\"provider\":{\"@type\":\"Organization\",\"name\":\"U\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "course_missing_provider_name",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Course\",\"name\":\"A\",\"description\":\"B\",\"provider\":{\"@type\":\"Organization\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ITEMLIST_REQUIRED_PROPERTIES",
    "title": "Required ItemList properties present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "ItemList must include `itemListElement` and each ListItem must have `position` and `url`.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML containing ItemList structured data."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Find objects where \"@type\" == \"ItemList\"."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract JSON-LD blocks.\n# 2. Locate the object with \"@type\" == \"ItemList\".\n# 3. Verify it has an \"itemListElement\" array.\n# 4. For each element in the array:\n#    a. Ensure \"@type\" == \"ListItem\".\n#    b. Verify \"position\" exists and is a positive integer.\n#    c. Verify \"item\" exists and contains a \"url\" field.\n# 5. If any check fails, the check fails; otherwise it passes.\n"
    },
    "pass_condition": "ItemList includes itemListElement and every ListItem has position and item.url.",
    "threshold": null,
    "fail_messages": [
      "ItemList missing required property ${missing}.",
      "ListItem at index ${index} missing ${missing}."
    ],
    "references": [
      {
        "doc_title": "Course list (`Course`) structured data",
        "url": "https://developers.google.com/search/docs/appearance/course-list",
        "section_title": "`ItemList` required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["technical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ItemList with proper ListItem entries.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"ItemList\",\"itemListElement\":[\n  {\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Course\",\"url\":\"https://example.com/1\"}},\n  {\"@type\":\"ListItem\",\"position\":2,\"item\":{\"@type\":\"Course\",\"url\":\"https://example.com/2\"}}\n]}\n</script>\n"
      },
      "failing": {
        "description": "ListItem missing position.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"ItemList\",\"itemListElement\":[\n  {\"@type\":\"ListItem\",\"item\":{\"@type\":\"Course\",\"url\":\"https://example.com/1\"}}\n]}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "valid_itemlist",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"@type\":\"Course\",\"url\":\"https://example.com/1\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_position",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"item\":{\"@type\":\"Course\",\"url\":\"https://example.com/1\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CAROUSEL_MARKUP_PRESENT",
    "title": "Carousel markup presence on summary or all\u2011in\u2011one page",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Carousel markup (ItemList) must be added to either a summary page or an all\u2011in\u2011one page.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the page to evaluate."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Detect presence of an ItemList object."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all JSON-LD blocks.\n# 2. If any block contains \"@type\":\"ItemList\", pass.\n# 3. Otherwise, fail.\n"
    },
    "pass_condition": "At least one ItemList JSON\u2011LD block is found on the page.",
    "threshold": null,
    "fail_messages": ["No ItemList (carousel) markup detected on the page."],
    "references": [
      {
        "doc_title": "Course list (`Course`) structured data",
        "url": "https://developers.google.com/search/docs/appearance/course-list",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["technical"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes ItemList markup.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"ItemList\", \"itemListElement\":[ ... ] }\n</script>\n"
      },
      "failing": {
        "description": "Page lacks ItemList markup.",
        "snippet": "<!-- no structured data -->"
      }
    },
    "test_cases": [
      {
        "name": "page_with_itemlist",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "page_without_itemlist",
        "input_stub": {
          "html": "<html><head></head><body>No structured data.</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "JOBPOSTING_REQUIRED_PROPERTIES",
    "title": "Required JobPosting properties must be present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Required properties are needed for a JobPosting to be eligible for Google Search job results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML of the page containing the JobPosting JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract the JSON\u2011LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the HTML and locate all <script type=\"application/ld+json\"> tags.\n# 2. For each script, parse its JSON content.\n# 3. Identify objects where \"@type\" == \"JobPosting\".\n# 4. For each JobPosting object, verify that the following keys exist and are non\u2011empty:\n#    - datePosted\n#    - description\n#    - hiringOrganization\n#    - jobLocation\n#    - title\n# 5. Record any missing or empty keys.\n"
    },
    "pass_condition": "All required properties (datePosted, description, hiringOrganization, jobLocation, title) are present and non\u2011empty in the JobPosting markup.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property ${property} in JobPosting markup."
    ],
    "references": [
      {
        "doc_title": "Job posting (JobPosting) structured data for Job Search",
        "url": "https://developers.google.com/search/docs/appearance/job-posting",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "A page with a JobPosting JSON\u2011LD that includes all required properties.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org/\",\n  \"@type\":\"JobPosting\",\n  \"title\":\"Software Engineer\",\n  \"description\":\"<p>Great job...</p>\",\n  \"datePosted\":\"2024-01-18\",\n  \"hiringOrganization\":{\"@type\":\"Organization\",\"name\":\"Google\"},\n  \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"US\"}}\n}\n</script>\n"
      },
      "failing": {
        "description": "A page where the JobPosting JSON\u2011LD is missing the \"title\" property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org/\",\n  \"@type\":\"JobPosting\",\n  \"description\":\"<p>Great job...</p>\",\n  \"datePosted\":\"2024-01-18\",\n  \"hiringOrganization\":{\"@type\":\"Organization\",\"name\":\"Google\"},\n  \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"US\"}}\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "All required properties present",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@context\":\"https://schema.org/\", \"@type\":\"JobPosting\", \"title\":\"Engineer\", \"description\":\"<p>...</p>\", \"datePosted\":\"2024-01-18\", \"hiringOrganization\":{\"@type\":\"Organization\",\"name\":\"Acme\"}, \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"US\"}} }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing title property",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@context\":\"https://schema.org/\", \"@type\":\"JobPosting\", \"description\":\"<p>...</p>\", \"datePosted\":\"2024-01-18\", \"hiringOrganization\":{\"@type\":\"Organization\",\"name\":\"Acme\"}, \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"US\"}} }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "JOBPOSTING_ADDRESS_COUNTRY",
    "title": "addressCountry must be specified when jobLocation is used",
    "category": "Mark up work from home jobs",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires addressCountry to resolve the physical location of a job when jobLocation is provided.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The page HTML containing JobPosting JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract JSON\u2011LD content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML and locate all JSON\u2011LD scripts.\n# 2. Parse each script as JSON.\n# 3. For each object with \"@type\" == \"JobPosting\":\n#    a. If \"jobLocation\" exists:\n#       i. Navigate to jobLocation.address.addressCountry.\n#       ii. Verify the field exists and is a non\u2011empty string.\n# 4. Record any missing addressCountry.\n"
    },
    "pass_condition": "Whenever a JobPosting includes a jobLocation, the nested addressCountry property is present and non\u2011empty.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "jobLocation is present but addressCountry is missing or empty."
    ],
    "references": [
      {
        "doc_title": "Job posting (JobPosting) structured data for Job Search",
        "url": "https://developers.google.com/search/docs/appearance/job-posting",
        "section_title": "Mark up work from home jobs",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "location"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "jobLocation includes addressCountry.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\":\"JobPosting\",\n  \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"US\"}}\n}\n</script>\n"
      },
      "failing": {
        "description": "jobLocation missing addressCountry.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\":\"JobPosting\",\n  \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"streetAddress\":\"123 Main\"}}\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "addressCountry present",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@type\":\"JobPosting\", \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"US\"}} }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "addressCountry missing",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@type\":\"JobPosting\", \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"streetAddress\":\"123 Main\"}} }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "WORK_FROM_HOME_APPLICANT_LOCATION_COUNTRY",
    "title": "applicantLocationRequirements must include at least one country for remote jobs",
    "category": "Mark up work from home jobs",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google needs at least one country to understand where remote applicants may reside.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML of the page containing JobPosting JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML, find JSON\u2011LD scripts.\n# 2. Parse each script as JSON.\n# 3. For each JobPosting object:\n#    a. If \"applicantLocationRequirements\" exists:\n#       i. If it is an array, ensure at least one element has \"@type\":\"Country\" and a non\u2011empty \"name\".\n#       ii. If it is an object, ensure \"@type\":\"Country\" and non\u2011empty \"name\".\n#    b. If the property is absent, no violation (only applies to remote jobs that include the property).\n# 4. Record violation if the check in (a) fails.\n"
    },
    "pass_condition": "When applicantLocationRequirements is present, it contains at least one Country entry with a non\u2011empty name.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "applicantLocationRequirements is present but does not contain a valid Country entry."
    ],
    "references": [
      {
        "doc_title": "Job posting (JobPosting) structured data for Job Search",
        "url": "https://developers.google.com/search/docs/appearance/job-posting",
        "section_title": "Mark up work from home jobs",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "remote"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "applicantLocationRequirements includes a Country.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\":\"JobPosting\",\n  \"applicantLocationRequirements\":{\"@type\":\"Country\",\"name\":\"USA\"}\n}\n</script>\n"
      },
      "failing": {
        "description": "applicantLocationRequirements missing country name.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\":\"JobPosting\",\n  \"applicantLocationRequirements\":{\"@type\":\"Country\"}\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid country entry",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@type\":\"JobPosting\", \"applicantLocationRequirements\":{\"@type\":\"Country\",\"name\":\"USA\"} }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing country name",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@type\":\"JobPosting\", \"applicantLocationRequirements\":{\"@type\":\"Country\"} }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SINGLE_JOBPOSTING_PER_PAGE",
    "title": "Only one JobPosting markup allowed per page",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "JobPosting markup is only permitted on pages that contain a single job posting.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Collect all JSON\u2011LD scripts."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML and locate every <script type=\"application/ld+json\">.\n# 2. For each script, parse JSON.\n# 3. Count objects where \"@type\" == \"JobPosting\".\n# 4. If count != 1, record a violation.\n"
    },
    "pass_condition": "Exactly one JobPosting object is present in the page's JSON\u2011LD.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found ${count} JobPosting objects; exactly one is required."
    ],
    "references": [
      {
        "doc_title": "Job posting (JobPosting) structured data for Job Search",
        "url": "https://developers.google.com/search/docs/appearance/job-posting",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "single_job"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a single JobPosting object.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\":\"JobPosting\", \"title\":\"Engineer\", \"description\":\"...\", \"datePosted\":\"2024-01-18\", \"hiringOrganization\":{\"@type\":\"Organization\",\"name\":\"Acme\"}, \"jobLocation\":{\"@type\":\"Place\",\"address\":{\"@type\":\"PostalAddress\",\"addressCountry\":\"US\"}} }\n</script>\n"
      },
      "failing": {
        "description": "Page contains two JobPosting objects.",
        "snippet": "<script type=\"application/ld+json\">\n[{ \"@type\":\"JobPosting\", \"title\":\"Engineer\" }, { \"@type\":\"JobPosting\", \"title\":\"Designer\" }]\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Single JobPosting",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@type\":\"JobPosting\", \"title\":\"Engineer\" }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Multiple JobPosting objects",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">[ { \"@type\":\"JobPosting\", \"title\":\"Engineer\" }, { \"@type\":\"JobPosting\", \"title\":\"Designer\" } ]</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "STRUCTURED_DATA_FORMAT_SUPPORTED",
    "title": "Use a supported structured data format",
    "category": "Format",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Structured data must be expressed using one of the three supported formats (JSON\u2011LD, Microdata, RDFa) to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Detect JSON\u2011LD blocks."
      },
      {
        "type": "selector",
        "selector": "[itemscope]",
        "attribute": null,
        "notes": "Detect Microdata items."
      },
      {
        "type": "selector",
        "selector": "[typeof]",
        "attribute": null,
        "notes": "Detect RDFa items."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into a DOM.\n# 2. Search for any element matching selector \"script[type='application/ld+json']\".\n# 3. If none found, search for any element with attribute \"itemscope\".\n# 4. If none found, search for any element with attribute \"typeof\".\n# 5. If any of the above searches return at least one element, PASS.\n# 6. Otherwise, FAIL.\n"
    },
    "pass_condition": "At least one supported structured\u2011data format (JSON\u2011LD, Microdata, or RDFa) is present on the page.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No supported structured\u2011data format detected on the page."
    ],
    "references": [
      {
        "doc_title": "General structured data guidelines",
        "url": "https://developers.google.com/search/docs/guides/general-structured-data",
        "section_title": "Format",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "format"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a JSON\u2011LD script block.",
        "snippet": "<script type=\"application/ld+json\">{...}</script>"
      },
      "failing": {
        "description": "Page has no structured\u2011data markup.",
        "snippet": "<html><head></head><body>No markup here.</body></html>"
      }
    },
    "test_cases": [
      {
        "name": "JSON-LD present",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@type\":\"Article\"}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "No markup",
        "input_stub": {
          "html": "<html><head></head><body>Plain text.</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "STRUCTURED_DATA_NOT_BLOCKED",
    "title": "Structured data pages must not be blocked from Googlebot",
    "category": "Access",
    "requirement": "UNSPECIFIED",
    "severity": "critical",
    "scope": "site",
    "rationale": "Blocking pages via robots.txt, noindex meta tags, or X\u2011Robots\u2011Tag headers prevents Google from accessing the structured data, making the page ineligible for rich results.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Contents of the site's robots.txt file."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the page."
      },
      {
        "name": "html",
        "required": false,
        "description": "The page HTML (used to detect meta robots tags)."
      },
      {
        "name": "url",
        "required": true,
        "description": "The canonical URL of the page being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "Disallow:\\s*(.*)",
        "attribute": null,
        "notes": "Capture Disallow paths from robots.txt."
      },
      {
        "type": "header",
        "selector": "x-robots-tag",
        "attribute": null,
        "notes": "Check for noindex directive."
      },
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Detect meta noindex."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: robots_txt, http_headers, html, url\n# 1. Parse robots_txt for lines matching /^Disallow:\\s*(.*)$/i.\n# 2. For each Disallow path, resolve it against the site's base URL.\n# 3. If the resolved path matches the page url, set blocked = true.\n# 4. Examine http_headers for header \"x-robots-tag\". If its value contains \"noindex\", set blocked = true.\n# 5. If html is provided, parse DOM and locate <meta name=\"robots\">. If its content includes \"noindex\", set blocked = true.\n# 6. If blocked is true, FAIL; otherwise PASS.\n"
    },
    "pass_condition": "The page URL is not disallowed in robots.txt and no noindex directives are present in HTTP headers or meta tags.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page is blocked by robots.txt or a noindex directive, preventing Googlebot from accessing structured data."
    ],
    "references": [
      {
        "doc_title": "General structured data guidelines",
        "url": "https://developers.google.com/search/docs/guides/general-structured-data",
        "section_title": "Access",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["access", "robots"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page is allowed in robots.txt and has no noindex tags.",
        "snippet": "robots.txt:\nUser-agent: *\nDisallow: /private/\n"
      },
      "failing": {
        "description": "Page is blocked via robots.txt Disallow rule.",
        "snippet": "robots.txt:\nUser-agent: *\nDisallow: /blocked-page.html\n"
      }
    },
    "test_cases": [
      {
        "name": "Allowed page",
        "input_stub": {
          "html": null,
          "http_headers": {
            "x-robots-tag": "index, follow"
          },
          "robots_txt": "User-agent: *\nDisallow: /private/",
          "sitemap_xml": null,
          "url": "https://example.com/public-page.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Disallowed page",
        "input_stub": {
          "html": null,
          "http_headers": {},
          "robots_txt": "User-agent: *\nDisallow: /public-page.html",
          "sitemap_xml": null,
          "url": "https://example.com/public-page.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CONTENT_VISIBLE_IN_HTML",
    "title": "Structured data must describe content visible to users",
    "category": "Content",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Markup that references entities not present in the visible page content can be considered misleading and may lead to manual actions.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD blocks."
      },
      {
        "type": "selector",
        "selector": "body",
        "attribute": null,
        "notes": "Collect visible text."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into DOM.\n# 2. Extract text content of <body> as visible_text (strip HTML tags, normalize whitespace).\n# 3. Locate all <script type='application/ld+json'> elements and parse their JSON.\n# 4. For each JSON\u2011LD object, collect values of properties named \"name\", \"title\", or \"headline\".\n# 5. For each collected value, perform a case\u2011insensitive substring search in visible_text.\n# 6. If any value is not found in visible_text, FAIL.\n# 7. If all values are found, PASS.\n"
    },
    "pass_condition": "Every 'name', 'title', or 'headline' value in JSON\u2011LD appears in the page's visible body text.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Structured\u2011data property '${observed}' does not appear in visible page content."
    ],
    "references": [
      {
        "doc_title": "General structured data guidelines",
        "url": "https://developers.google.com/search/docs/guides/general-structured-data",
        "section_title": "Content",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["content", "visibility"],
    "insufficient_evidence": false,
    "notes": "This check only evaluates simple string presence and may not capture nuanced visibility issues.",
    "examples": {
      "passing": {
        "description": "JSON\u2011LD name matches visible heading.",
        "snippet": "<script type=\"application/ld+json\">{\"@type\":\"Person\",\"name\":\"Jane Doe\"}</script>\n<h1>Jane Doe</h1>\n"
      },
      "failing": {
        "description": "JSON\u2011LD name not present in visible text.",
        "snippet": "<script type=\"application/ld+json\">{\"@type\":\"Person\",\"name\":\"John Smith\"}</script>\n<p>Welcome to our site.</p>\n"
      }
    },
    "test_cases": [
      {
        "name": "Name visible",
        "input_stub": {
          "html": "<html><head></head><body><h1>Jane Doe</h1><script type='application/ld+json'>{\"@type\":\"Person\",\"name\":\"Jane Doe\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Name missing",
        "input_stub": {
          "html": "<html><head></head><body><p>Welcome.</p><script type='application/ld+json'>{\"@type\":\"Person\",\"name\":\"John Smith\"}</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_CONTAINSPLACE_PRESENT",
    "title": "Presence of required property `containsPlace`",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "`containsPlace` is listed as a required property for VacationRental structured data; without it the markup is ineligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the JSON\u2011LD script."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract the JSON\u2011LD block and parse it as JSON."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the HTML and locate the first <script type=\"application/ld+json\"> element.\n# 2. Parse its text content as JSON into variable `data`.\n# 3. If `data[\"@type\"]` is not \"VacationRental\", exit with not_applicable.\n# 4. Check if the key \"containsPlace\" exists in `data`.\n# 5. If present, set result = pass; else result = fail.\n"
    },
    "pass_condition": "`containsPlace` key exists in the VacationRental JSON\u2011LD.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property `containsPlace` in VacationRental markup."
    ],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD includes a `containsPlace` object.",
        "snippet": "{\n  \"@type\": \"VacationRental\",\n  \"containsPlace\": { \"@type\": \"Accommodation\" }\n}\n"
      },
      "failing": {
        "description": "JSON\u2011LD lacks the `containsPlace` key.",
        "snippet": "{\n  \"@type\": \"VacationRental\",\n  \"name\": \"My Rental\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "ContainsPlace present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"containsPlace\":{}}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "ContainsPlace missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"name\":\"Test\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_OCCUPANCY_PRESENT",
    "title": "Presence of required nested property `containsPlace.occupancy`",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "`containsPlace.occupancy` is required for VacationRental markup; its absence makes the markup ineligible.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD as in previous check.\n# 2. Verify `data[\"@type\"]` == \"VacationRental\".\n# 3. Verify `data[\"containsPlace\"]` exists and is an object.\n# 4. Verify `data[\"containsPlace\"][\"occupancy\"]` exists.\n# 5. Pass if present; otherwise fail.\n"
    },
    "pass_condition": "`occupancy` key exists inside `containsPlace`.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing required property `containsPlace.occupancy`."],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "`occupancy` object is present.",
        "snippet": "{\n  \"@type\":\"VacationRental\",\n  \"containsPlace\":{\"occupancy\":{\"value\":2}}\n}\n"
      },
      "failing": {
        "description": "`occupancy` missing.",
        "snippet": "{\n  \"@type\":\"VacationRental\",\n  \"containsPlace\":{}\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Occupancy present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"containsPlace\":{\"occupancy\":{}}}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Occupancy missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"containsPlace\":{}}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_OCCUPANCY_VALUE_PRESENT",
    "title": "Presence of required property `containsPlace.occupancy.value`",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "`containsPlace.occupancy.value` must be provided to indicate the number of guests; without it the markup is invalid.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD.\n# 2. Ensure VacationRental type.\n# 3. Navigate to data[\"containsPlace\"][\"occupancy\"][\"value\"].\n# 4. Pass if the key exists (value may be any number); otherwise fail.\n"
    },
    "pass_condition": "`value` key exists inside `containsPlace.occupancy`.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property `containsPlace.occupancy.value`."
    ],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "`value` is present.",
        "snippet": "{\n  \"@type\":\"VacationRental\",\n  \"containsPlace\":{\"occupancy\":{\"value\":2}}\n}\n"
      },
      "failing": {
        "description": "`value` missing.",
        "snippet": "{\n  \"@type\":\"VacationRental\",\n  \"containsPlace\":{\"occupancy\":{}}\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "Occupancy value present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"containsPlace\":{\"occupancy\":{\"value\":2}}}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Occupancy value missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"containsPlace\":{\"occupancy\":{}}}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_IDENTIFIER_PRESENT",
    "title": "Presence of required property `identifier`",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "`identifier` uniquely identifies the rental; it is required for eligibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD.\n# 2. Verify VacationRental type.\n# 3. Check if key \"identifier\" exists at top level.\n# 4. Pass if present; else fail.\n"
    },
    "pass_condition": "`identifier` key exists in the top\u2011level VacationRental object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing required property `identifier`."],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "`identifier` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"identifier\":\"abc123\"}\n"
      },
      "failing": {
        "description": "`identifier` missing.",
        "snippet": "{\"@type\":\"VacationRental\",\"name\":\"Test\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "Identifier present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"identifier\":\"abc123\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Identifier missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"name\":\"Test\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_IMAGE_PRESENT",
    "title": "Presence of required property `image`",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "`image` provides visual content for rich results; it is required.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD.\n# 2. Verify VacationRental type.\n# 3. Check for key \"image\" at top level.\n# 4. Pass if present and non\u2011empty; else fail.\n"
    },
    "pass_condition": "`image` key exists and contains at least one URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing required property `image`."],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "`image` array with URLs.",
        "snippet": "{\"@type\":\"VacationRental\",\"image\":[\"https://example.com/img1.jpg\"]}\n"
      },
      "failing": {
        "description": "`image` missing.",
        "snippet": "{\"@type\":\"VacationRental\",\"name\":\"Test\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "Image present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"image\":[\"https://example.com/img.jpg\"]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Image missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"name\":\"Test\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_LATITUDE_PRESENT",
    "title": "Presence of required property `latitude` (or `geo.latitude`)",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Geographic coordinates are required; either `latitude` or `geo.latitude` must be provided.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD.\n# 2. Verify VacationRental type.\n# 3. If key \"latitude\" exists, pass.\n# 4. Else if key \"geo\" exists and \"geo.latitude\" exists, pass.\n# 5. Otherwise fail.\n"
    },
    "pass_condition": "`latitude` key exists at top level, or `geo.latitude` exists within a `geo` object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required geographic coordinate `latitude` (or `geo.latitude`)."
    ],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "`latitude` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"latitude\":\"42.12345\"}\n"
      },
      "passing_geo": {
        "description": "`geo.latitude` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"geo\":{\"latitude\":\"42.12345\"}}\n"
      },
      "failing": {
        "description": "Neither `latitude` nor `geo.latitude` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"name\":\"Test\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "Latitude present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"latitude\":\"42.12345\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Geo latitude present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"geo\":{\"latitude\":\"42.12345\"}}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Latitude missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"name\":\"Test\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_LONGITUDE_PRESENT",
    "title": "Presence of required property `longitude` (or `geo.longitude`)",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Geographic coordinates are required; either `longitude` or `geo.longitude` must be provided.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD.\n# 2. Verify VacationRental type.\n# 3. If key \"longitude\" exists, pass.\n# 4. Else if key \"geo\" exists and \"geo.longitude\" exists, pass.\n# 5. Otherwise fail.\n"
    },
    "pass_condition": "`longitude` key exists at top level, or `geo.longitude` exists within a `geo` object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required geographic coordinate `longitude` (or `geo.longitude`)."
    ],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "`longitude` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"longitude\":\"101.12345\"}\n"
      },
      "passing_geo": {
        "description": "`geo.longitude` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"geo\":{\"longitude\":\"101.12345\"}}\n"
      },
      "failing": {
        "description": "Neither `longitude` nor `geo.longitude` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"name\":\"Test\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "Longitude present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"longitude\":\"101.12345\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Geo longitude present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"geo\":{\"longitude\":\"101.12345\"}}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Longitude missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"name\":\"Test\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VACATION_RENTAL_NAME_PRESENT",
    "title": "Presence of required property `name`",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "`name` identifies the rental and is required for eligibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD.\n# 2. Verify VacationRental type.\n# 3. Check for top\u2011level key \"name\".\n# 4. Pass if present; else fail.\n"
    },
    "pass_condition": "`name` key exists in the top\u2011level VacationRental object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing required property `name`."],
    "references": [
      {
        "doc_title": "Vacation Rental Schema Markup",
        "url": "https://developers.google.com/search/docs/structured-data/vacation-rental",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "vacation_rental"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "`name` present.",
        "snippet": "{\"@type\":\"VacationRental\",\"name\":\"My Beautiful Vacation Rental\"}\n"
      },
      "failing": {
        "description": "`name` missing.",
        "snippet": "{\"@type\":\"VacationRental\",\"identifier\":\"abc123\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "Name present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"name\":\"My Rental\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Name missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"VacationRental\",\"identifier\":\"abc123\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "EMPLOYER_AGGREGATE_RATING_REQUIRED_PROPERTIES",
    "title": "Required properties for EmployerAggregateRating",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires these properties for the rating to be eligible for rich results in the job search experience.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML of the page to be inspected."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract the JSON-LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and locate all <script type=\"application/ld+json\"> elements.\n# 2. For each script, parse its content as JSON.\n# 3. Identify the JSON object where \"@type\" == \"EmployerAggregateRating\".\n# 4. If no such object exists, set result = not_applicable.\n# 5. Verify that the object contains the keys:\n#    - \"itemReviewed\"\n#    - \"ratingCount\"\n#    - \"ratingValue\"\n#    - \"reviewCount\"\n# 6. If all keys are present, set result = pass; else result = fail.\n"
    },
    "pass_condition": "All required properties (itemReviewed, ratingCount, ratingValue, reviewCount) are present in the EmployerAggregateRating JSON\u2011LD.",
    "threshold": null,
    "fail_messages": [
      "Missing required property ${missing_property} in EmployerAggregateRating JSON\u2011LD."
    ],
    "references": [
      {
        "doc_title": "Employer Rating (EmployerAggregateRating) Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/employer-aggregate-rating",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": [
      "structured_data",
      "employer_aggregate_rating",
      "required_properties"
    ],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Example from documentation containing all required properties.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org/\",\n  \"@type\": \"EmployerAggregateRating\",\n  \"itemReviewed\": {\n    \"@type\": \"Organization\",\n    \"name\": \"World's Best Coffee Shop\",\n    \"sameAs\": \"https://example.com\"\n  },\n  \"ratingValue\": 91,\n  \"bestRating\": 100,\n  \"worstRating\": 1,\n  \"ratingCount\": \"10561\",\n  \"reviewCount\": \"10561\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Missing the required property ratingCount.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org/\",\n  \"@type\": \"EmployerAggregateRating\",\n  \"itemReviewed\": {\n    \"@type\": \"Organization\",\n    \"name\": \"World's Best Coffee Shop\",\n    \"sameAs\": \"https://example.com\"\n  },\n  \"ratingValue\": 91,\n  \"bestRating\": 100,\n  \"worstRating\": 1,\n  \"reviewCount\": \"10561\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "All required properties present",
        "input_stub": {
          "html": "<html><head>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org/\",\n  \"@type\": \"EmployerAggregateRating\",\n  \"itemReviewed\": {\"@type\":\"Organization\",\"name\":\"Test Co\"},\n  \"ratingValue\": 85,\n  \"ratingCount\": \"200\",\n  \"reviewCount\": \"200\"\n}\n</script>\n</head><body></body></html>\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing ratingCount property",
        "input_stub": {
          "html": "<html><head>\n<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org/\",\n  \"@type\": \"EmployerAggregateRating\",\n  \"itemReviewed\": {\"@type\":\"Organization\",\"name\":\"Test Co\"},\n  \"ratingValue\": 85,\n  \"reviewCount\": \"200\"\n}\n</script>\n</head><body></body></html>\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LOCALBUSINESS_REQUIRED_ADDRESS",
    "title": "Required address property for LocalBusiness",
    "category": "LocalBusiness",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The documentation lists `address` as a required property for LocalBusiness structured data.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract the JSON\u2011LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the HTML and locate all <script type=\"application/ld+json\"> elements.\n# 2. For each script, parse its JSON content.\n# 3. Identify objects where \"@type\" is \"LocalBusiness\" or a subtype of LocalBusiness.\n# 4. If any such object contains the key \"address\", mark as pass.\n# 5. If none contain \"address\", mark as fail.\n"
    },
    "pass_condition": "At least one LocalBusiness JSON\u2011LD object includes the \"address\" property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required 'address' property in LocalBusiness structured data."
    ],
    "references": [
      {
        "doc_title": "Local Business Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/local-business",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required_property", "LocalBusiness"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD includes an address object.",
        "snippet": "{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Restaurant\",\n  \"name\": \"Example\",\n  \"address\": {\n    \"@type\": \"PostalAddress\",\n    \"streetAddress\": \"123 Main St\"\n  }\n}\n"
      },
      "failing": {
        "description": "JSON\u2011LD lacks the address property.",
        "snippet": "{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Restaurant\",\n  \"name\": \"Example\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "address present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\",\"address\":{}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "address missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LOCALBUSINESS_REQUIRED_NAME",
    "title": "Required name property for LocalBusiness",
    "category": "LocalBusiness",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The documentation lists `name` as a required property for LocalBusiness structured data.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract the JSON\u2011LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Locate all JSON\u2011LD scripts in the HTML.\n# 2. Parse each script as JSON.\n# 3. Find objects where \"@type\" is \"LocalBusiness\" or a subtype.\n# 4. If any such object contains the key \"name\", pass.\n# 5. Otherwise, fail.\n"
    },
    "pass_condition": "At least one LocalBusiness JSON\u2011LD object includes the \"name\" property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required 'name' property in LocalBusiness structured data."
    ],
    "references": [
      {
        "doc_title": "Local Business Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/local-business",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required_property", "LocalBusiness"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD includes a name field.",
        "snippet": "{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Restaurant\",\n  \"name\": \"Example Restaurant\"\n}\n"
      },
      "failing": {
        "description": "JSON\u2011LD lacks the name property.",
        "snippet": "{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Restaurant\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "name present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\",\"name\":\"Test\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "name missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RESTAURANT_CAROUSEL_REQUIRED_IMAGE",
    "title": "Required image property for Restaurant carousel",
    "category": "Restaurant carousel",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The carousel guidelines list `image` as a required property for the Carousel object.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content containing the Carousel JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract the JSON\u2011LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract all JSON\u2011LD scripts.\n# 2. Parse each as JSON.\n# 3. Identify objects that represent a Carousel for restaurants (e.g., contain \"@type\":\"Restaurant\" and are used in a carousel context).\n# 4. Verify the presence of the \"image\" key.\n# 5. Pass if present; otherwise fail.\n"
    },
    "pass_condition": "The Carousel JSON\u2011LD includes an \"image\" property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required 'image' property in Restaurant carousel structured data."
    ],
    "references": [
      {
        "doc_title": "Local Business Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/local-business",
        "section_title": "Restaurant carousel (limited access)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required_property", "RestaurantCarousel"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Carousel JSON\u2011LD includes an image array.",
        "snippet": "{\n  \"@type\": \"Restaurant\",\n  \"name\": \"Example\",\n  \"image\": [\"https://example.com/photo.jpg\"]\n}\n"
      },
      "failing": {
        "description": "Carousel JSON\u2011LD lacks the image property.",
        "snippet": "{\n  \"@type\": \"Restaurant\",\n  \"name\": \"Example\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "image present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\",\"name\":\"Test\",\"image\":[\"https://example.com/img.jpg\"]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "image missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\",\"name\":\"Test\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RESTAURANT_CAROUSEL_REQUIRED_NAME",
    "title": "Required name property for Restaurant carousel",
    "category": "Restaurant carousel",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The carousel guidelines list `name` as a required property for the Carousel object.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content containing the Carousel JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract the JSON\u2011LD script content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract all JSON\u2011LD scripts from the page.\n# 2. Parse each script as JSON.\n# 3. Locate objects representing a Restaurant carousel.\n# 4. Check for the presence of the \"name\" key.\n# 5. Pass if present; otherwise fail.\n"
    },
    "pass_condition": "The Carousel JSON\u2011LD includes a \"name\" property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required 'name' property in Restaurant carousel structured data."
    ],
    "references": [
      {
        "doc_title": "Local Business Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/local-business",
        "section_title": "Restaurant carousel (limited access)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required_property", "RestaurantCarousel"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Carousel JSON\u2011LD includes a name field.",
        "snippet": "{\n  \"@type\": \"Restaurant\",\n  \"name\": \"Example\",\n  \"image\": [\"https://example.com/photo.jpg\"]\n}\n"
      },
      "failing": {
        "description": "Carousel JSON\u2011LD lacks the name property.",
        "snippet": "{\n  \"@type\": \"Restaurant\",\n  \"image\": [\"https://example.com/photo.jpg\"]\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "name present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\",\"name\":\"Test\",\"image\":[\"https://example.com/img.jpg\"]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "name missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Restaurant\",\"image\":[\"https://example.com/img.jpg\"]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SPEAKABLE_REQUIRED_LOCATOR_PRESENT",
    "title": "Required locator property present in Speakable markup",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The documentation lists `cssSelector` and `xPath` as required properties for Speakable markup.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing potential JSON\u2011LD Speakable markup."
      }
    ],
    "preconditions": [
      "Speakable markup exists in a JSON\u2011LD script block."
    ],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "<script[^>]*type=[\"']application/ld\\+json[\"'][^>]*>([\\s\\S]*?)</script>",
        "attribute": null,
        "notes": "Capture JSON\u2011LD content from script tags."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract all <script type=\"application/ld+json\"> blocks from html.\njson_blocks = regex_all(html, \"<script[^>]*type=[\\\"']application/ld\\\\+json[\\\"'][^>]*>([\\\\s\\\\S]*?)</script>\")\n# 2. For each block, parse JSON.\nfor block in json_blocks:\n    data = parse_json(block)\n    # 3. If the block defines a SpeakableSpecification directly:\n    if data.get(\"@type\") == \"SpeakableSpecification\":\n        if \"cssSelector\" in data or \"xPath\" in data:\n            return PASS\n    # 4. If the block contains a top\u2011level object with a \"speakable\" property:\n    if \"speakable\" in data:\n        speakable = data[\"speakable\"]\n        if isinstance(speakable, dict):\n            if \"cssSelector\" in speakable or \"xPath\" in speakable:\n                return PASS\n        elif isinstance(speakable, list):\n            for item in speakable:\n                if isinstance(item, dict) and (\"cssSelector\" in item or \"xPath\" in item):\n                    return PASS\n# 5. No required locator found.\nreturn FAIL\n"
    },
    "pass_condition": "At least one of `cssSelector` or `xPath` is present in any SpeakableSpecification or in the `speakable` property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Speakable markup missing required locator property; observed keys: ${observed_keys}."
    ],
    "references": [
      {
        "doc_title": "Speakable structured data documentation",
        "url": "https://developers.google.com/search/docs/appearance/speakable",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["speakable", "structured-data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD includes an `xPath` array.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"WebPage\",\n  \"speakable\":{\n    \"@type\":\"SpeakableSpecification\",\n    \"xPath\":[\"/html/head/title\"]\n  }\n}\n</script>\n"
      },
      "failing": {
        "description": "JSON\u2011LD lacks both `cssSelector` and `xPath`.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"WebPage\",\n  \"speakable\":{\n    \"@type\":\"SpeakableSpecification\"\n  }\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid xPath present",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@context\":\"https://schema.org\", \"@type\":\"WebPage\", \"speakable\":{ \"@type\":\"SpeakableSpecification\", \"xPath\":[\"/html/head/title\"] } }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing locator properties",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@context\":\"https://schema.org\", \"@type\":\"WebPage\", \"speakable\":{ \"@type\":\"SpeakableSpecification\" } }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SPEAKABLE_PARENT_TYPE_VALID",
    "title": "Speakable markup attached to Article or WebPage type",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Speakable must be used with `Article` or `WebPage` objects according to the documentation.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing JSON\u2011LD Speakable markup."
      }
    ],
    "preconditions": [
      "Speakable markup exists in a JSON\u2011LD script block."
    ],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "<script[^>]*type=[\"']application/ld\\+json[\"'][^>]*>([\\s\\S]*?)</script>",
        "attribute": null,
        "notes": "Capture JSON\u2011LD content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD script blocks.\njson_blocks = regex_all(html, \"<script[^>]*type=[\\\"']application/ld\\\\+json[\\\"'][^>]*>([\\\\s\\\\S]*?)</script>\")\n# 2. For each block, parse JSON.\nfor block in json_blocks:\n    data = parse_json(block)\n    # 3. If the object itself has a \"speakable\" property, check its @type.\n    if \"speakable\" in data:\n        parent_type = data.get(\"@type\")\n        if parent_type in [\"Article\", \"WebPage\"]:\n            return PASS\n    # 4. If the block defines a SpeakableSpecification directly, look for its container.\n    #    Search sibling objects in the same JSON block for @type.\n    if isinstance(data, dict):\n        for key, value in data.items():\n            if isinstance(value, dict) and \"speakable\" in value:\n                container_type = value.get(\"@type\") or data.get(\"@type\")\n                if container_type in [\"Article\", \"WebPage\"]:\n                    return PASS\n# 5. No valid parent type found.\nreturn FAIL\n"
    },
    "pass_condition": "The JSON\u2011LD object that contains a `speakable` property has an `@type` of `Article` or `WebPage`.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Speakable markup attached to unsupported type `${parent_type}`; must be Article or WebPage."
    ],
    "references": [
      {
        "doc_title": "Speakable structured data documentation",
        "url": "https://developers.google.com/search/docs/appearance/speakable",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["speakable", "structured-data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Speakable within a WebPage object.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"WebPage\",\n  \"speakable\":{\"@type\":\"SpeakableSpecification\",\"xPath\":[\"/html/head/title\"]}\n}\n</script>\n"
      },
      "failing": {
        "description": "Speakable within an unsupported type.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"BlogPosting\",\n  \"speakable\":{\"@type\":\"SpeakableSpecification\",\"xPath\":[\"/html/head/title\"]}\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid parent type WebPage",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@context\":\"https://schema.org\", \"@type\":\"WebPage\", \"speakable\":{ \"@type\":\"SpeakableSpecification\", \"xPath\":[\"/html/head/title\"] } }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Invalid parent type BlogPosting",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">{ \"@context\":\"https://schema.org\", \"@type\":\"BlogPosting\", \"speakable\":{ \"@type\":\"SpeakableSpecification\", \"xPath\":[\"/html/head/title\"] } }</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RICH_RESULTS_TEST_ELIGIBILITY",
    "title": "Verify Rich Results Test eligibility",
    "category": "Test your implementation",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "page",
    "rationale": "Ensures Google Search can process the structured data by confirming the page is eligible for rich results.",
    "input_fields": [
      {
        "name": "rich_results_test_status",
        "required": true,
        "description": "Result status returned by the Rich Results Test tool for the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "metric",
        "selector": "rich_results_test_status",
        "attribute": null,
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: rich_results_test_status (string)\n# Steps:\n1. If rich_results_test_status is null or empty, set outcome to not_applicable.\n2. If rich_results_test_status equals \"eligible\", set outcome to pass.\n3. Otherwise, set outcome to fail.\n"
    },
    "pass_condition": "Rich Results Test reports the page as eligible for rich results.",
    "threshold": {
      "type": "string",
      "operator": "==",
      "value": "eligible",
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Rich Results Test did not report eligibility (observed: ${observed})."
    ],
    "references": [
      {
        "doc_title": "Generate structured data with JavaScript",
        "url": "https://developers.google.com/search/docs/guides/generate-structured-data-javascript",
        "section_title": "Test your implementation",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["rich_results", "testing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page passes Rich Results Test and shows eligibility.",
        "snippet": "rich_results_test_status: eligible"
      },
      "failing": {
        "description": "Page fails Rich Results Test or shows errors.",
        "snippet": "rich_results_test_status: ineligible"
      }
    },
    "test_cases": [
      {
        "name": "Eligible page",
        "input_stub": {
          "rich_results_test_status": "eligible",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Ineligible page",
        "input_stub": {
          "rich_results_test_status": "ineligible",
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SINGLE_CLAIMREVIEW_PER_PAGE",
    "title": "Ensure only one ClaimReview element per page",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "A page with multiple ClaimReview elements is ineligible for the single fact check rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract each JSON-LD block and parse for @type == 'ClaimReview'"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the HTML and extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block, parse the JSON.\n# 3. Count objects where \"@type\" == \"ClaimReview\".\n# 4. If count == 1, pass; otherwise fail.\n"
    },
    "pass_condition": "Exactly one ClaimReview element is present on the page.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 1,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found ${observed} ClaimReview elements; exactly one is required."
    ],
    "references": [
      {
        "doc_title": "Fact check (ClaimReview) structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/fact-check",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "claimreview", "eligibility"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page with a single ClaimReview JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@context\":\"https://schema.org\", \"@type\":\"ClaimReview\", \"claimReviewed\":\"...\", \"reviewRating\":{...}, \"url\":\"...\" }\n</script>\n"
      },
      "failing": {
        "description": "Page containing two ClaimReview JSON\u2011LD blocks.",
        "snippet": "<script type=\"application/ld+json\">{ \"@type\":\"ClaimReview\", ... }</script>\n<script type=\"application/ld+json\">{ \"@type\":\"ClaimReview\", ... }</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Single ClaimReview",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@type\":\"ClaimReview\",\"claimReviewed\":\"X\",\"reviewRating\":{},\"url\":\"https://example.com\"}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Multiple ClaimReview",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@type\":\"ClaimReview\"}</script><script type='application/ld+json'>{\"@type\":\"ClaimReview\"}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CLAIMREVIEW_REQUIRED_PROPERTIES",
    "title": "Verify required ClaimReview properties are present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "ClaimReview objects must include claimReviewed, reviewRating, and url to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content containing ClaimReview JSON\u2011LD"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON and locate the object with \"@type\": \"ClaimReview\""
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract all JSON\u2011LD script blocks.\n# 2. Parse each block as JSON.\n# 3. Find the object where \"@type\" == \"ClaimReview\".\n# 4. Check that the keys \"claimReviewed\", \"reviewRating\", and \"url\" exist.\n# 5. If all three are present, pass; otherwise fail and list missing keys.\n"
    },
    "pass_condition": "claimReviewed, reviewRating, and url properties are all present in the ClaimReview object.",
    "threshold": null,
    "fail_messages": ["Missing required property '${missing}' in ClaimReview."],
    "references": [
      {
        "doc_title": "Fact check (ClaimReview) structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/fact-check",
        "section_title": "`ClaimReview` required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "claimreview", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ClaimReview JSON\u2011LD includes all required fields.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"ClaimReview\",\n  \"claimReviewed\":\"The world is flat\",\n  \"reviewRating\":{\"@type\":\"Rating\",\"alternateName\":\"False\"},\n  \"url\":\"https://example.com/fact-check\"\n}\n</script>\n"
      },
      "failing": {
        "description": "ClaimReview JSON\u2011LD missing the reviewRating property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"ClaimReview\",\n  \"claimReviewed\":\"The world is flat\",\n  \"url\":\"https://example.com/fact-check\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "All required properties present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ClaimReview\",\"claimReviewed\":\"X\",\"reviewRating\":{},\"url\":\"https://example.com\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing reviewRating",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ClaimReview\",\"claimReviewed\":\"X\",\"url\":\"https://example.com\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RATING_ALTERNATE_NAME_REQUIRED",
    "title": "Verify Rating alternateName property is present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The Rating type requires the alternateName property for eligibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content containing ClaimReview JSON\u2011LD with Rating object"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON and locate the Rating object (\"@type\": \"Rating\")"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract JSON\u2011LD script blocks.\n# 2. Parse each block.\n# 3. Within the ClaimReview object, find the nested object where \"@type\" == \"Rating\".\n# 4. Verify that the key \"alternateName\" exists.\n# 5. Pass if present; otherwise fail.\n"
    },
    "pass_condition": "The Rating object includes the alternateName property.",
    "threshold": null,
    "fail_messages": [
      "Rating object is missing required property 'alternateName'."
    ],
    "references": [
      {
        "doc_title": "Fact check (ClaimReview) structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/fact-check",
        "section_title": "`Rating` required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "rating", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Rating includes alternateName.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\":\"Rating\",\n  \"alternateName\":\"False\",\n  \"ratingValue\":1\n}\n</script>\n"
      },
      "failing": {
        "description": "Rating missing alternateName.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\":\"Rating\",\n  \"ratingValue\":1\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Rating with alternateName",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Rating\",\"alternateName\":\"False\",\"ratingValue\":1}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Rating without alternateName",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Rating\",\"ratingValue\":1}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUIZ_HASPART_PRESENT",
    "title": "Quiz must include hasPart property with at least one Question",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The Quiz type requires the hasPart property; without it the page is ineligible for the education Q&A rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks and parse them as JSON"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse all <script type=\"application/ld+json\"> blocks from html.\n# 2. For each JSON object, if \"@type\" == \"Quiz\":\n#    a. Check if \"hasPart\" key exists.\n#    b. Verify \"hasPart\" is an array with length >= 1.\n# 3. If such a Quiz object is found, condition passes; otherwise fails.\n"
    },
    "pass_condition": "Quiz object has a non\u2011empty hasPart array.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": null,
      "notes": "Number of Question items in hasPart"
    },
    "fail_messages": ["Quiz missing hasPart property or hasPart is empty."],
    "references": [
      {
        "doc_title": "Education Q&A Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/education-qa",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "quiz", "required"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Quiz with two flashcard questions.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Quiz\",\n  \"hasPart\": [\n    { \"@type\": \"Question\", \"eduQuestionType\": \"Flashcard\", \"text\": \"Q1\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"A1\" } },\n    { \"@type\": \"Question\", \"eduQuestionType\": \"Flashcard\", \"text\": \"Q2\", \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"A2\" } }\n  ]\n}\n</script>\n"
      },
      "failing": {
        "description": "Quiz without hasPart.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\": \"Quiz\" }\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Quiz with hasPart",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@type\":\"Quiz\",\"hasPart\":[{\"@type\":\"Question\",\"eduQuestionType\":\"Flashcard\",\"text\":\"Q\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"A\"}}]}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Quiz missing hasPart",
        "input_stub": {
          "html": "<html><head><script type='application/ld+json'>{\"@type\":\"Quiz\"}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUESTION_REQUIRED_PROPERTIES",
    "title": "Each Question must include acceptedAnswer, eduQuestionType, and text",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Question objects are required to have acceptedAnswer, eduQuestionType, and text for eligibility.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": ["Quiz object with non\u2011empty hasPart exists"],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks and parse them as JSON"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON-LD blocks from html.\n# 2. Locate the Quiz object with hasPart array.\n# 3. For each item in hasPart where \"@type\" == \"Question\":\n#    a. Verify keys \"acceptedAnswer\", \"eduQuestionType\", and \"text\" exist.\n#    b. If any key is missing, record the missing property.\n# 4. Pass if no missing properties are found for any Question.\n"
    },
    "pass_condition": "All Question items contain acceptedAnswer, eduQuestionType, and text.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Question missing required property '${missing_property}'."
    ],
    "references": [
      {
        "doc_title": "Education Q&A Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/education-qa",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "question", "required"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Question with all required fields.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Question\",\n  \"eduQuestionType\": \"Flashcard\",\n  \"text\": \"What is photosynthesis?\",\n  \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Process by which...\" }\n}\n</script>\n"
      },
      "failing": {
        "description": "Question missing acceptedAnswer.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Question\",\n  \"eduQuestionType\": \"Flashcard\",\n  \"text\": \"What is photosynthesis?\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Question with all required properties",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Quiz\",\"hasPart\":[{\"@type\":\"Question\",\"eduQuestionType\":\"Flashcard\",\"text\":\"Q\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"A\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Question missing acceptedAnswer",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Quiz\",\"hasPart\":[{\"@type\":\"Question\",\"eduQuestionType\":\"Flashcard\",\"text\":\"Q\"}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUESTION_EDUQUESTIONTYPE_FLASHCARD",
    "title": "eduQuestionType must be Flashcard for all Questions",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Only Flashcard\u2011type questions are eligible for the education Q&A carousel.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": ["Quiz object with non\u2011empty hasPart exists"],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD blocks and parse them as JSON"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON-LD from html.\n# 2. Find Quiz object and iterate over its hasPart array.\n# 3. For each item where \"@type\" == \"Question\":\n#    a. Retrieve the value of \"eduQuestionType\".\n#    b. If the value is not exactly \"Flashcard\", record a failure.\n# 4. Pass if every Question's eduQuestionType equals \"Flashcard\".\n"
    },
    "pass_condition": "All Question items have eduQuestionType equal to \"Flashcard\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Question eduQuestionType is '${observed}' but must be 'Flashcard'."
    ],
    "references": [
      {
        "doc_title": "Education Q&A Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/education-qa",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "question", "eduQuestionType"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Question with eduQuestionType set to Flashcard.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Question\",\n  \"eduQuestionType\": \"Flashcard\",\n  \"text\": \"Sample?\",\n  \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Answer\" }\n}\n</script>\n"
      },
      "failing": {
        "description": "Question with a non\u2011Flashcard eduQuestionType.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Question\",\n  \"eduQuestionType\": \"MultipleChoice\",\n  \"text\": \"Sample?\",\n  \"acceptedAnswer\": { \"@type\": \"Answer\", \"text\": \"Answer\" }\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "All questions Flashcard",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Quiz\",\"hasPart\":[{\"@type\":\"Question\",\"eduQuestionType\":\"Flashcard\",\"text\":\"Q\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"A\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Non\u2011Flashcard eduQuestionType",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Quiz\",\"hasPart\":[{\"@type\":\"Question\",\"eduQuestionType\":\"MultipleChoice\",\"text\":\"Q\",\"acceptedAnswer\":{\"@type\":\"Answer\",\"text\":\"A\"}}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QAPAGE_SINGLE_DEFINITION",
    "title": "Single QAPage definition per page",
    "category": "QAPage",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires exactly one QAPage type definition per page for eligibility as a rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"QAPage\"",
        "attribute": null,
        "notes": "Count occurrences of the QAPage type in JSON\u2011LD or microdata scripts"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\nmatches = regex_find_all(html, \"\\\"@type\\\"\\\\s*:\\\\s*\\\"QAPage\\\"\")\ncount = length(matches)\n"
    },
    "pass_condition": "Exactly one QAPage type is present",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 1,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found ${observed} QAPage definitions; exactly one is required."
    ],
    "references": [
      {
        "doc_title": "QAPage",
        "url": "https://developers.google.com/search/docs/structured-data/qapage",
        "section_title": "QAPage",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "rich_results"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a single JSON\u2011LD block with \"@type\":\"QAPage\"",
        "snippet": "<script type=\"application/ld+json\">\n{\"@type\":\"QAPage\",\"mainEntity\":{...}}\n</script>\n"
      },
      "failing": {
        "description": "Page contains two QAPage definitions",
        "snippet": "<script type=\"application/ld+json\">{\"@type\":\"QAPage\",...}</script>\n<script type=\"application/ld+json\">{\"@type\":\"QAPage\",...}</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "single_qapage",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"QAPage\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "multiple_qapage",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"QAPage\"}</script><script type=\"application/ld+json\">{\"@type\":\"QAPage\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QAPAGE_MAINENTITY_PRESENT",
    "title": "QAPage must include mainEntity property",
    "category": "QAPage",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The mainEntity property links the QAPage to the Question object, which is required for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"mainEntity\"\\s*:",
        "attribute": null,
        "notes": "Presence of the mainEntity key in JSON\u2011LD"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\nif regex_search(html, \"\\\"mainEntity\\\"\\\\s*:\"):\n    present = true\nelse:\n    present = false\n"
    },
    "pass_condition": "mainEntity property is present",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "QAPage definition is missing the required mainEntity property."
    ],
    "references": [
      {
        "doc_title": "QAPage",
        "url": "https://developers.google.com/search/docs/structured-data/qapage",
        "section_title": "QAPage",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "mainEntity key exists in the JSON\u2011LD block",
        "snippet": "{\"@type\":\"QAPage\",\"mainEntity\":{\"@type\":\"Question\",...}}\n"
      },
      "failing": {
        "description": "mainEntity key is omitted",
        "snippet": "{\"@type\":\"QAPage\",\"name\":\"Example\"}\n"
      }
    },
    "test_cases": [
      {
        "name": "mainentity_present",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"QAPage\",\"mainEntity\":{}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "mainentity_missing",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"QAPage\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUESTION_SINGLE_DEFINITION",
    "title": "Exactly one Question object per QAPage",
    "category": "Question",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google expects a single Question nested under the QAPage's mainEntity.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": ["QAPage mainEntity property is present"],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"Question\"",
        "attribute": null,
        "notes": "Count occurrences of Question type within the mainEntity block"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\nmatches = regex_find_all(html, \"\\\"@type\\\"\\\\s*:\\\\s*\\\"Question\\\"\")\ncount = length(matches)\n"
    },
    "pass_condition": "Exactly one Question type is present",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 1,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found ${observed} Question definitions; exactly one is required."
    ],
    "references": [
      {
        "doc_title": "Question",
        "url": "https://developers.google.com/search/docs/structured-data/qapage#question",
        "section_title": "Question",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "One Question object inside mainEntity",
        "snippet": "{\"@type\":\"QAPage\",\"mainEntity\":{\"@type\":\"Question\",\"name\":\"...\"}}\n"
      },
      "failing": {
        "description": "Two Question objects inside mainEntity",
        "snippet": "{\"@type\":\"QAPage\",\"mainEntity\":[{\"@type\":\"Question\",\"name\":\"...\"},\n                                  {\"@type\":\"Question\",\"name\":\"...\"}]}\n"
      }
    },
    "test_cases": [
      {
        "name": "single_question",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"QAPage\",\"mainEntity\":{\"@type\":\"Question\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "multiple_questions",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"QAPage\",\"mainEntity\":[{\"@type\":\"Question\"},{\"@type\":\"Question\"}]}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "QUESTION_REQUIRED_PROPERTIES",
    "title": "Required properties on Question object",
    "category": "Question",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Google\u2019s QAPage guidelines list answerCount, name, and at least one of acceptedAnswer or suggestedAnswer as required for a Question.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": ["Exactly one Question object is present"],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"Question\"[^{]*\\{([^}]*?)\\}",
        "attribute": null,
        "notes": "Capture the JSON object of the Question to inspect its fields"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\nquestion_json = extract_json_object(html, \"\\\"@type\\\"\\\\s*:\\\\s*\\\"Question\\\"\")\nhas_name = \"name\" in question_json\nhas_answerCount = \"answerCount\" in question_json\nhas_accepted = \"acceptedAnswer\" in question_json\nhas_suggested = \"suggestedAnswer\" in question_json\npasses = has_name and has_answerCount and (has_accepted or has_suggested)\n"
    },
    "pass_condition": "Question includes name, answerCount, and at least one of acceptedAnswer or suggestedAnswer",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing required Question fields: ${missing_fields}"],
    "references": [
      {
        "doc_title": "Question",
        "url": "https://developers.google.com/search/docs/structured-data/qapage#question",
        "section_title": "Question",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Question has name, answerCount, and acceptedAnswer",
        "snippet": "{\"@type\":\"Question\",\"name\":\"...\",\"answerCount\":3,\"acceptedAnswer\":{...}}\n"
      },
      "failing": {
        "description": "Question missing answerCount",
        "snippet": "{\"@type\":\"Question\",\"name\":\"...\",\"acceptedAnswer\":{...}}\n"
      }
    },
    "test_cases": [
      {
        "name": "question_all_required",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Question\",\"name\":\"Q\",\"answerCount\":2,\"acceptedAnswer\":{}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "question_missing_answerCount",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Question\",\"name\":\"Q\",\"acceptedAnswer\":{}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ANSWER_TEXT_REQUIRED",
    "title": "Answer objects must include text property",
    "category": "Answer",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "The text property is required for every Answer to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": ["Question object is present"],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"Answer\"[^{]*\\{([^}]*?)\\}",
        "attribute": null,
        "notes": "Extract each Answer JSON object"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\nanswer_objects = regex_find_all_objects(html, \"\\\"@type\\\"\\\\s*:\\\\s*\\\"Answer\\\"\")\nfor ans in answer_objects:\n    if \"text\" not in ans:\n        fail = true\n        record_missing(ans)\npass = not fail\n"
    },
    "pass_condition": "Every Answer object contains a text field",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Answer object missing required text property."],
    "references": [
      {
        "doc_title": "Answer",
        "url": "https://developers.google.com/search/docs/structured-data/qapage#answer",
        "section_title": "Answer",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Answer includes text",
        "snippet": "{\"@type\":\"Answer\",\"text\":\"16 ounces\",\"upvoteCount\":10}\n"
      },
      "failing": {
        "description": "Answer missing text",
        "snippet": "{\"@type\":\"Answer\",\"upvoteCount\":5}\n"
      }
    },
    "test_cases": [
      {
        "name": "answer_with_text",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Answer\",\"text\":\"Yes\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "answer_missing_text",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Answer\",\"upvoteCount\":3}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "COMMENT_TEXT_REQUIRED",
    "title": "Comment objects must include text property",
    "category": "Comment",
    "requirement": "MUST",
    "severity": "low",
    "scope": "page",
    "rationale": "The text property is required for Comment objects used within Question or Answer.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source of the page"
      }
    ],
    "preconditions": ["Question or Answer objects are present"],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"Comment\"[^{]*\\{([^}]*?)\\}",
        "attribute": null,
        "notes": "Extract each Comment JSON object"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\ncomment_objects = regex_find_all_objects(html, \"\\\"@type\\\"\\\\s*:\\\\s*\\\"Comment\\\"\")\nfor com in comment_objects:\n    if \"text\" not in com:\n        fail = true\npass = not fail\n"
    },
    "pass_condition": "Every Comment object contains a text field",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Comment object missing required text property."],
    "references": [
      {
        "doc_title": "Comment",
        "url": "https://developers.google.com/search/docs/structured-data/qapage#comment",
        "section_title": "Comment",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Comment includes text",
        "snippet": "{\"@type\":\"Comment\",\"text\":\"I agree\"}\n"
      },
      "failing": {
        "description": "Comment missing text",
        "snippet": "{\"@type\":\"Comment\",\"author\":{\"@type\":\"Person\",\"name\":\"John\"}}\n"
      }
    },
    "test_cases": [
      {
        "name": "comment_with_text",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Comment\",\"text\":\"Nice\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "comment_missing_text",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{\"@type\":\"Comment\",\"author\":{\"@type\":\"Person\",\"name\":\"John\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MATHSOLVER_JSONLD_PRESENT",
    "title": "MathSolver structured data present on home page",
    "category": "Technical Guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Structured data is required for math solver rich results and must be added to the home page.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page to be inspected."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract JSON-LD script blocks from the page."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse html and locate all <script type=\"application/ld+json\"> elements.\n# 2. For each script, parse its JSON content.\n# 3. If any JSON object has \"@type\" that includes \"MathSolver\", set found = true.\n# 4. If found is true, PASS; else FAIL.\n"
    },
    "pass_condition": "At least one JSON\u2011LD script contains \"@type\" with value \"MathSolver\".",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["MathSolver structured data not found on the page."],
    "references": [
      {
        "doc_title": "Math Solver Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/math-solver",
        "section_title": "Technical Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "math_solver"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a MathSolver JSON\u2011LD block.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": [\"MathSolver\",\"LearningResource\"],\n  \"url\": \"https://example.com/\",\n  \"usageInfo\": \"https://example.com/privacy\",\n  \"potentialAction\": [{\n    \"@type\": \"SolveMathAction\",\n    \"target\": \"https://example.com/solve?q={math_expression_string}\",\n    \"mathExpression-input\": \"required name=math_expression_string\"\n  }]\n}\n</script>\n"
      },
      "failing": {
        "description": "Page lacks any MathSolver JSON\u2011LD.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@context\": \"https://schema.org\", \"@type\": \"Article\", \"name\": \"Example\" }\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "MathSolver JSON\u2011LD present",
        "input_stub": {
          "html": "<html><head></head><body><script type=\"application/ld+json\">{ \"@type\": [\"MathSolver\"] }</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "MathSolver JSON\u2011LD absent",
        "input_stub": {
          "html": "<html><head></head><body><script type=\"application/ld+json\">{ \"@type\": \"Article\" }</script></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MATHSOLVER_REQUIRED_PROPERTIES",
    "title": "Required MathSolver properties present in JSON\u2011LD",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "All required MathSolver properties must be provided for eligibility as a rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content containing the MathSolver JSON\u2011LD."
      }
    ],
    "preconditions": ["MathSolver JSON\u2011LD block is present on the page."],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Extract JSON\u2011LD to inspect its fields."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Locate MathSolver JSON\u2011LD as in previous check.\n# 2. Parse the JSON object where \"@type\" includes \"MathSolver\".\n# 3. Verify existence of top\u2011level keys: \"potentialAction\", \"url\", \"usageInfo\".\n# 4. For each object in \"potentialAction\":\n#    a. Verify \"mathExpression-input\" exists.\n#    b. Verify \"target\" exists.\n# 5. If all required keys are present, PASS; otherwise FAIL and list missing keys.\n"
    },
    "pass_condition": "All required properties (potentialAction, potentialAction.mathExpression-input, url, usageInfo, potentialAction.target) are present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property ${missing_property} in MathSolver JSON\u2011LD."
    ],
    "references": [
      {
        "doc_title": "Math Solver Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/math-solver",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD includes all required fields.",
        "snippet": "{\n  \"@context\": \"https://schema.org\",\n  \"@type\": [\"MathSolver\",\"LearningResource\"],\n  \"url\": \"https://example.com/\",\n  \"usageInfo\": \"https://example.com/privacy\",\n  \"potentialAction\": [{\n    \"@type\": \"SolveMathAction\",\n    \"target\": \"https://example.com/solve?q={math_expression_string}\",\n    \"mathExpression-input\": \"required name=math_expression_string\"\n  }]\n}\n"
      },
      "failing": {
        "description": "Missing the \"usageInfo\" field.",
        "snippet": "{\n  \"@context\": \"https://schema.org\",\n  \"@type\": [\"MathSolver\"],\n  \"url\": \"https://example.com/\",\n  \"potentialAction\": [{\n    \"@type\": \"SolveMathAction\",\n    \"target\": \"https://example.com/solve?q={math_expression_string}\",\n    \"mathExpression-input\": \"required name=math_expression_string\"\n  }]\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "All required properties present",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":[\"MathSolver\"],\n  \"url\":\"https://example.com/\",\n  \"usageInfo\":\"https://example.com/privacy\",\n  \"potentialAction\":[{\n    \"@type\":\"SolveMathAction\",\n    \"target\":\"https://example.com/solve?q={math_expression_string}\",\n    \"mathExpression-input\":\"required name=math_expression_string\"\n  }]\n}\n</script>\n",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing usageInfo",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":[\"MathSolver\"],\n  \"url\":\"https://example.com/\",\n  \"potentialAction\":[{\n    \"@type\":\"SolveMathAction\",\n    \"target\":\"https://example.com/solve?q={math_expression_string}\",\n    \"mathExpression-input\":\"required name=math_expression_string\"\n  }]\n}\n</script>\n",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGE_ACCESSIBLE_NOINDEX",
    "title": "Page not blocked by robots.txt or noindex meta tag",
    "category": "Technical Guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google must be able to crawl and index the page for the rich result to appear.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Contents of the site's robots.txt file."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name=\"robots\"]",
        "attribute": "content",
        "notes": "Check for presence of noindex directive."
      },
      {
        "type": "header",
        "selector": "robots_txt",
        "attribute": null,
        "notes": "Inspect Disallow rules for the page URL."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html, robots_txt, url (page URL)\n# 1. Parse html for <meta name=\"robots\" content=\"...\">.\n# 2. If content contains \"noindex\" (case\u2011insensitive), FAIL.\n# 3. Parse robots_txt lines.\n# 4. For each \"Disallow: <path>\" line, if the page URL path matches the disallowed path, FAIL.\n# 5. If neither condition triggers, PASS.\n"
    },
    "pass_condition": "No noindex meta tag is present and the page URL is not disallowed by robots.txt.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page is blocked by robots.txt (Disallow rule).",
      "Page contains a noindex meta tag."
    ],
    "references": [
      {
        "doc_title": "Math Solver Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/math-solver",
        "section_title": "Technical Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["crawlability", "robots"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page is crawlable and has no noindex tag.",
        "snippet": "<html><head></head><body>...</body></html>\n# robots.txt\nUser-agent: *\nDisallow:\n"
      },
      "failing": {
        "description": "Page includes a noindex meta tag.",
        "snippet": "<meta name=\"robots\" content=\"noindex, nofollow\">\n"
      }
    },
    "test_cases": [
      {
        "name": "Crawlable page without noindex",
        "input_stub": {
          "html": "<html><head></head><body>Content</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow:",
          "sitemap_xml": null,
          "url": "https://example.com/"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Page blocked by robots.txt",
        "input_stub": {
          "html": "<html><head></head><body>Content</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow: /",
          "sitemap_xml": null,
          "url": "https://example.com/secret"
        },
        "expected_outcome": "fail"
      },
      {
        "name": "Page contains noindex meta",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex\"></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow:",
          "sitemap_xml": null,
          "url": "https://example.com/"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAYWALL_REQUIRED_PROPERTY_ISACCESSIBLEFORFREE",
    "title": "Presence of required isAccessibleForFree property in structured data",
    "category": "Required properties",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google requires the isAccessibleForFree property so it can understand that the article contains paywalled content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML source of the page to be inspected."
      }
    ],
    "preconditions": [
      "HTML contains a <script type=\"application/ld+json\"> element with @type equal to CreativeWork or a supported subclass."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract the JSON-LD block for parsing."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and extract all <script type=\"application/ld+json\"> blocks.\n# 2. For each block, parse JSON content.\n# 3. For each JSON object (or each object in @graph if present):\n#    a. If \"@type\" is \"CreativeWork\" or one of the supported sub\u2011types\n#       (Article, NewsArticle, Blog, Comment, Course, HowTo, Message, Review, WebPage):\n#          i. Check if the key \"isAccessibleForFree\" exists.\n#          ii. Record missing instances.\n# 4. If any required object is missing the property, mark as fail.\n"
    },
    "pass_condition": "All CreativeWork (or supported subclass) JSON\u2011LD objects contain the isAccessibleForFree property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Structured data object of type ${type} is missing required property isAccessibleForFree."
    ],
    "references": [
      {
        "doc_title": "Structured data for subscription and paywalled content (CreativeWork)",
        "url": "https://developers.google.com/search/docs/structured-data/paywalled-content",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["paywall", "structured-data", "required"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD includes the required isAccessibleForFree property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"NewsArticle\",\n  \"isAccessibleForFree\": false,\n  \"hasPart\": {\n    \"@type\": \"WebPageElement\",\n    \"isAccessibleForFree\": false,\n    \"cssSelector\": \".paywall\"\n  }\n}\n</script>\n"
      },
      "failing": {
        "description": "JSON\u2011LD missing the required isAccessibleForFree property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"NewsArticle\",\n  \"hasPart\": {\n    \"@type\": \"WebPageElement\",\n    \"cssSelector\": \".paywall\"\n  }\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Paywalled article with required property",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">\n{\"@context\":\"https://schema.org\",\"@type\":\"NewsArticle\",\"isAccessibleForFree\":false}\n</script></head><body></body></html>\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Paywalled article missing required property",
        "input_stub": {
          "html": "<html><head><script type=\"application/ld+json\">\n{\"@context\":\"https://schema.org\",\"@type\":\"NewsArticle\"}\n</script></head><body></body></html>\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ITEMLIST_STRUCTURE_MUST",
    "title": "ItemList structured data must be present with required properties",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Required for carousel eligibility; the documentation lists required ItemList properties.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing JSON\u2011LD script tags."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML and locate all <script type=\"application/ld+json\"> tags.\n# 2. For each script, parse its JSON content.\n# 3. If a JSON object has \"@type\" == \"ItemList\":\n#    a. Verify presence of keys: \"itemListElement\".\n#    b. For each element in \"itemListElement\", verify it contains \"item\" and \"position\".\n# 4. If such an ItemList is found, PASS; otherwise FAIL.\n"
    },
    "pass_condition": "An ItemList object with required keys (itemListElement, item, position) is found.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "ItemList structured data missing or required properties not present."
    ],
    "references": [
      {
        "doc_title": "Structured data type definitions",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "ItemList",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "itemlist"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a valid ItemList JSON\u2011LD with required fields.",
        "snippet": "<script type=\"application/ld+json\">\n{\"@context\":\"https://schema.org\",\"@type\":\"ItemList\",\"itemListElement\":[...]}\n</script>\n"
      },
      "failing": {
        "description": "No ItemList JSON\u2011LD or missing required keys.",
        "snippet": "<script type=\"application/ld+json\">{\"@type\":\"Article\",...}</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid ItemList present",
        "input_stub": {
          "html": "<html>...ItemList JSON...</html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing ItemList",
        "input_stub": {
          "html": "<html><head></head><body></body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ITEMLIST_ELEMENT_REQUIRED_PROPERTIES",
    "title": "Each ListItem must include required properties image, name, and url",
    "category": "Common list item properties",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The documentation lists image, name, and url as required for all carousel items.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD from script tags.\n# 2. Locate the ItemList object.\n# 3. For each element in ItemList.itemListElement:\n#    a. Ensure element[\"@type\"] == \"ListItem\".\n#    b. Ensure element contains \"item\".\n#    c. Within element[\"item\"], verify keys \"image\", \"name\", \"url\" exist.\n# 4. If all items satisfy, PASS; otherwise FAIL and list offending items.\n"
    },
    "pass_condition": "Every ListItem's item object contains image, name, and url.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "ListItem at position ${position} missing required property ${missing_property}."
    ],
    "references": [
      {
        "doc_title": "Common list item properties",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "required-properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All ListItem entries include image, name, and url.",
        "snippet": "\"item\": {\"@type\":\"Restaurant\",\"name\":\"Trattoria\",\"image\":[\"...\"],\"url\":\"https://...\"}\n"
      },
      "failing": {
        "description": "A ListItem lacks the url field.",
        "snippet": "\"item\": {\"@type\":\"Restaurant\",\"name\":\"Trattoria\",\"image\":[\"...\"]}\n"
      }
    },
    "test_cases": [
      {
        "name": "All required properties present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"name\":\"A\",\"image\":[\"x\"],\"url\":\"https://a.com\"}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing url",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"name\":\"A\",\"image\":[\"x\"]}}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ITEMLIST_ELEMENT_UNIQUE_URLS_SAME_DOMAIN",
    "title": "URLs of list items must be distinct and on the same domain as the page",
    "category": "ItemList",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Documentation states all URLs must point to different pages on the same domain.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML containing JSON\u2011LD."
      },
      {
        "name": "url",
        "required": true,
        "description": "Canonical URL of the page being evaluated."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD and locate ItemList.\n# 2. Collect all item URLs: for each element in itemListElement, extract element[\"item\"][\"url\"].\n# 3. Verify that the set of URLs has the same size as the list (no duplicates).\n# 4. Parse the domain of the page URL (input url) and each item URL.\n# 5. Ensure every item URL's domain equals the page domain.\n# 6. PASS if both conditions hold; otherwise FAIL.\n"
    },
    "pass_condition": "All item URLs are unique and share the page's domain.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Duplicate URL found: ${url}.",
      "Item URL ${url} is on a different domain than page domain ${page_domain}."
    ],
    "references": [
      {
        "doc_title": "ItemList definition",
        "url": "https://schema.org/ItemList",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["url", "domain-consistency"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Three distinct URLs all on example.com.",
        "snippet": "\"url\":\"https://example.com/hotel1\"\n"
      },
      "failing": {
        "description": "Two items share the same URL or point to another domain.",
        "snippet": "\"url\":\"https://example.com/hotel1\", \"url\":\"https://other.com/hotel2\"\n"
      }
    },
    "test_cases": [
      {
        "name": "Unique same\u2011domain URLs",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"url\":\"https://example.com/a\"}},{\"@type\":\"ListItem\",\"position\":2,\"item\":{\"url\":\"https://example.com/b\"}}]}</script>",
          "url": "https://example.com/page"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Duplicate URL",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"item\":{\"url\":\"https://example.com/a\"}},{\"@type\":\"ListItem\",\"position\":2,\"item\":{\"url\":\"https://example.com/a\"}}]}</script>",
          "url": "https://example.com/page"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SUMMARY_PAGE_MIN_ITEMS",
    "title": "Summary page must contain at least three carousel items",
    "category": "Guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Documentation requires the summary/category page to list at least three entities.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Page HTML with JSON\u2011LD."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON\u2011LD and locate the ItemList object.\n# 2. Count the number of entries in ItemList.itemListElement.\n# 3. PASS if count >= 3; otherwise FAIL.\n"
    },
    "pass_condition": "ItemList contains three or more items.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 3,
      "unit": "items",
      "notes": null
    },
    "fail_messages": [
      "ItemList contains only ${count} items; at least 3 are required."
    ],
    "references": [
      {
        "doc_title": "Guidelines",
        "url": "https://developers.google.com/search/docs/structured-data/carousels",
        "section_title": "Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["count", "summary-page"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "ItemList with 4 ListItem entries.",
        "snippet": "\"itemListElement\":[{...},{...},{...},{...}]\n"
      },
      "failing": {
        "description": "Only two ListItem entries.",
        "snippet": "\"itemListElement\":[{...},{...}]\n"
      }
    },
    "test_cases": [
      {
        "name": "Sufficient items",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{}, {}, {}, {}]}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Insufficient items",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{}, {}]}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGE_ACCESSIBLE_NO_ROBOTS_NOINDEX",
    "title": "Page must not be blocked by robots.txt, meta robots noindex, or X-Robots-Tag",
    "category": "Guidelines",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "Documentation states the page must be accessible to Google and not blocked by robots.txt, noindex tag, or login.",
    "input_fields": [
      {
        "name": "url",
        "required": true,
        "description": "Canonical URL of the page."
      },
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers of the page."
      },
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": "Check for noindex directive."
      },
      {
        "type": "regex",
        "selector": "<meta[^>]+name=[\"']robots[\"'][^>]*content=[\"']([^\"']*)[\"']",
        "attribute": null,
        "notes": "Capture meta robots content."
      },
      {
        "type": "regex",
        "selector": "Disallow:\\s*${path}",
        "attribute": null,
        "notes": "Check robots.txt for disallow of the page path."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. From http_headers, read X-Robots-Tag header (if any). If it contains \"noindex\", FAIL.\n# 2. Search html for <meta name=\"robots\" ...>. If content includes \"noindex\", FAIL.\n# 3. Parse robots_txt: extract Disallow rules. If the page path matches any Disallow pattern, FAIL.\n# 4. If none of the above block the page, PASS.\n"
    },
    "pass_condition": "No noindex directives in headers, meta tags, or robots.txt for the page URL.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page is blocked by X-Robots-Tag: ${directive}.",
      "Meta robots tag contains noindex.",
      "Robots.txt disallows path ${path}."
    ],
    "references": [
      {
        "doc_title": "Guidelines",
        "url": "https://developers.google.com/search/docs/structured-data/carousels",
        "section_title": "Guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["accessibility", "robots"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No blocking directives found.",
        "snippet": "<meta name=\"robots\" content=\"index,follow\">\n"
      },
      "failing": {
        "description": "X-Robots-Tag header includes noindex.",
        "snippet": "X-Robots-Tag: noindex\n"
      }
    },
    "test_cases": [
      {
        "name": "Accessible page",
        "input_stub": {
          "url": "https://example.com/page",
          "http_headers": {},
          "html": "<html><head></head><body></body></html>",
          "robots_txt": "User-agent: *\nDisallow:"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Blocked by meta noindex",
        "input_stub": {
          "url": "https://example.com/page",
          "http_headers": {},
          "html": "<meta name=\"robots\" content=\"noindex,follow\">",
          "robots_txt": "User-agent: *\nDisallow:"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MOVIE_REQUIRED_PROPERTIES_PRESENT",
    "title": "Required properties for Movie structured data",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "page",
    "rationale": "The documentation states that `image` and `name` are required properties for a Movie object to be eligible for the movie carousel rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML of the page to be inspected for JSON\u2011LD script blocks."
      }
    ],
    "preconditions": [
      "The page contains at least one `<script type=\"application/ld+json\">` block."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract the JSON\u2011LD content for parsing."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and extract all <script type=\"application/ld+json\"> contents.\n# 2. For each extracted JSON block:\n#    a. Parse JSON.\n#    b. If \"@type\" == \"Movie\" or an object within \"@type\":\"ItemList\" has \"item\" with \"@type\":\"Movie\":\n#         i. Check that the \"image\" property exists and is a non\u2011empty string.\n#        ii. Check that the \"name\" property exists and is a non\u2011empty string.\n# 3. Record any Movie objects missing either property.\n# 4. If no missing properties are found, the check passes.\n"
    },
    "pass_condition": "All Movie objects in the page\u2019s JSON\u2011LD contain non\u2011empty `image` and `name` properties.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Movie object missing required property: ${missing_property}."
    ],
    "references": [
      {
        "doc_title": "Mark Up Movies with Structured Data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/movie",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured_data", "movie", "required_properties"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Movie object includes both required properties.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Movie\",\n  \"name\": \"A Star Is Born\",\n  \"image\": \"https://example.com/photo.jpg\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Movie object missing the `image` property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Movie\",\n  \"name\": \"A Star Is Born\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Passing case with required properties",
        "input_stub": {
          "html": "<html><head>\n<script type=\"application/ld+json\">\n{\"@type\":\"Movie\",\"name\":\"A Star Is Born\",\"image\":\"https://example.com/photo.jpg\"}\n</script>\n</head><body></body></html>\n"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Failing case missing image",
        "input_stub": {
          "html": "<html><head>\n<script type=\"application/ld+json\">\n{\"@type\":\"Movie\",\"name\":\"A Star Is Born\"}\n</script>\n</head><body></body></html>\n"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SOFTWAREAPP_REQUIRED_NAME",
    "title": "Required property name present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The name property is required for a SoftwareApplication to be eligible for a rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to extract structured data."
      }
    ],
    "preconditions": [
      "Page contains structured data of type SoftwareApplication"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON-LD and locate objects where @type includes 'SoftwareApplication'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse the HTML and extract all JSON-LD scripts, RDFa blocks, and Microdata items.\n# 2. For each extracted structured data entity:\n#    a. If entity @type is \"SoftwareApplication\" or includes it, store as app_entity.\n# 3. If no app_entity found, mark check as not_applicable.\n# 4. For the first app_entity, check if property \"name\" exists and is a non\u2011empty string.\n# 5. If present, outcome = pass; else outcome = fail.\n"
    },
    "pass_condition": "The SoftwareApplication entity includes a non\u2011empty \"name\" property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property 'name' in SoftwareApplication structured data."
    ],
    "references": [
      {
        "doc_title": "Software app (SoftwareApplication) structured data",
        "url": "https://developers.google.com/search/docs/structured-data/software-app",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required", "structured_data", "name"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "JSON\u2011LD with a name property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"SoftwareApplication\",\n  \"name\": \"Angry Birds\",\n  \"offers\": { \"price\": 1.00, \"priceCurrency\": \"USD\" }\n}\n</script>\n"
      },
      "failing": {
        "description": "JSON\u2011LD missing the name property.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"SoftwareApplication\",\n  \"offers\": { \"price\": 1.00, \"priceCurrency\": \"USD\" }\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Name present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"Angry Birds\",\"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Name missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SOFTWAREAPP_REQUIRED_OFFERS_PRICE",
    "title": "Required property offers.price present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The offers.price property is required for a SoftwareApplication to be eligible for a rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to extract structured data."
      }
    ],
    "preconditions": [
      "Page contains structured data of type SoftwareApplication"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON-LD and locate objects where @type includes 'SoftwareApplication'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract structured data entities of type SoftwareApplication.\n# 2. For each entity, locate the \"offers\" object.\n# 3. Verify that \"offers\" contains a \"price\" property with a numeric value.\n# 4. If such a price exists, outcome = pass; otherwise fail.\n"
    },
    "pass_condition": "The SoftwareApplication entity includes an offers object with a numeric \"price\" property.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property 'offers.price' in SoftwareApplication structured data."
    ],
    "references": [
      {
        "doc_title": "Software app (SoftwareApplication) structured data",
        "url": "https://developers.google.com/search/docs/structured-data/software-app",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required", "structured_data", "offers_price"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "offers object includes price.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"SoftwareApplication\",\n  \"name\": \"Angry Birds\",\n  \"offers\": { \"price\": 1.00, \"priceCurrency\": \"USD\" }\n}\n</script>\n"
      },
      "failing": {
        "description": "offers object missing price.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"SoftwareApplication\",\n  \"name\": \"Angry Birds\",\n  \"offers\": { \"priceCurrency\": \"USD\" }\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Price present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"Angry Birds\",\"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Price missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"Angry Birds\",\"offers\":{\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SOFTWAREAPP_REQUIRED_AGGREGATE_RATING",
    "title": "Required property aggregateRating present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The aggregateRating property is required for a SoftwareApplication to be eligible for a rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to extract structured data."
      }
    ],
    "preconditions": [
      "Page contains structured data of type SoftwareApplication"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON-LD and locate objects where @type includes 'SoftwareApplication'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract SoftwareApplication entities.\n# 2. Check if an \"aggregateRating\" property exists.\n# 3. Verify that aggregateRating contains both \"ratingValue\" and \"ratingCount\".\n# 4. If present, outcome = pass; else fail.\n"
    },
    "pass_condition": "The SoftwareApplication entity includes an aggregateRating with ratingValue and ratingCount.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property 'aggregateRating' in SoftwareApplication structured data."
    ],
    "references": [
      {
        "doc_title": "Software app (SoftwareApplication) structured data",
        "url": "https://developers.google.com/search/docs/structured-data/software-app",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required", "structured_data", "aggregateRating"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "aggregateRating with required subproperties.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"SoftwareApplication\",\n  \"name\":\"Angry Birds\",\n  \"aggregateRating\":{\"@type\":\"AggregateRating\",\"ratingValue\":4.6,\"ratingCount\":8864},\n  \"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}\n}\n</script>\n"
      },
      "failing": {
        "description": "aggregateRating missing.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"SoftwareApplication\",\n  \"name\":\"Angry Birds\",\n  \"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "AggregateRating present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"Angry Birds\",\"aggregateRating\":{\"@type\":\"AggregateRating\",\"ratingValue\":4.6,\"ratingCount\":8864},\"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "AggregateRating missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"Angry Birds\",\"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SOFTWAREAPP_REQUIRED_REVIEW",
    "title": "Required property review present",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The review property is required for a SoftwareApplication to be eligible for a rich result.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page to extract structured data."
      }
    ],
    "preconditions": [
      "Page contains structured data of type SoftwareApplication"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON-LD and locate objects where @type includes 'SoftwareApplication'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Extract SoftwareApplication entities.\n# 2. Verify that a \"review\" property exists.\n# 3. The review property must be an object or array containing at least one review item.\n# 4. If such a review exists, outcome = pass; else fail.\n"
    },
    "pass_condition": "The SoftwareApplication entity includes at least one review.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property 'review' in SoftwareApplication structured data."
    ],
    "references": [
      {
        "doc_title": "Software app (SoftwareApplication) structured data",
        "url": "https://developers.google.com/search/docs/structured-data/software-app",
        "section_title": "Structured data type definitions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required", "structured_data", "review"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "review property present.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"SoftwareApplication\",\n  \"name\":\"Angry Birds\",\n  \"review\":{\"@type\":\"Review\",\"author\":{\"@type\":\"Person\",\"name\":\"John\"},\"reviewRating\":{\"@type\":\"Rating\",\"ratingValue\":\"5\"}},\n  \"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}\n}\n</script>\n"
      },
      "failing": {
        "description": "review property missing.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@context\":\"https://schema.org\",\n  \"@type\":\"SoftwareApplication\",\n  \"name\":\"Angry Birds\",\n  \"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Review present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"Angry Birds\",\"review\":{\"@type\":\"Review\",\"author\":{\"@type\":\"Person\",\"name\":\"John\"},\"reviewRating\":{\"@type\":\"Rating\",\"ratingValue\":\"5\"}},\"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Review missing",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@context\":\"https://schema.org\",\"@type\":\"SoftwareApplication\",\"name\":\"Angry Birds\",\"offers\":{\"price\":1.00,\"priceCurrency\":\"USD\"}}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DFP_REQUIRED_PROPERTIES",
    "title": "Required properties for DiscussionForumPosting",
    "category": "DiscussionForumPosting required properties",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Required properties must be present for a DiscussionForumPosting to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML of the page containing the structured data."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD block(s) and parse as JSON."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse all JSON-LD scripts from html.\n# 2. For each object where \"@type\" == \"DiscussionForumPosting\":\n#    a. Verify presence of \"author\" object.\n#    b. Verify \"author.name\" exists.\n#    c. Verify \"datePublished\" exists.\n#    d. Verify at least one of \"text\", \"image\", or \"video\" exists.\n# 3. If any required field missing, mark as fail.\n"
    },
    "pass_condition": "All required properties (author, author.name, datePublished, and at least one of text/image/video) are present in the DiscussionForumPosting markup.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required property ${missing_property} in DiscussionForumPosting."
    ],
    "references": [
      {
        "doc_title": "Discussion forum structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/discussion-forum",
        "section_title": "DiscussionForumPosting (or SocialMediaPosting)",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required", "structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "DiscussionForumPosting with all required fields.",
        "snippet": "{\n  \"@type\": \"DiscussionForumPosting\",\n  \"author\": {\"@type\":\"Person\",\"name\":\"Alice\"},\n  \"datePublished\":\"2024-01-01T00:00:00Z\",\n  \"text\":\"Sample post\"\n}\n"
      },
      "failing": {
        "description": "Missing author.name.",
        "snippet": "{\n  \"@type\": \"DiscussionForumPosting\",\n  \"author\": {\"@type\":\"Person\"},\n  \"datePublished\":\"2024-01-01T00:00:00Z\",\n  \"text\":\"Sample post\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "all_required_present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"DiscussionForumPosting\",\"author\":{\"@type\":\"Person\",\"name\":\"Alice\"},\"datePublished\":\"2024-01-01T00:00:00Z\",\"text\":\"Sample\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_author_name",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"DiscussionForumPosting\",\"author\":{\"@type\":\"Person\"},\"datePublished\":\"2024-01-01T00:00:00Z\",\"text\":\"Sample\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "COMMENT_REQUIRED_PROPERTIES",
    "title": "Required properties for Comment",
    "category": "Comment required properties",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Each Comment must contain required fields to be valid for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML of the page containing the structured data."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD block(s) and parse as JSON."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON-LD scripts from html.\n# 2. For each object where \"@type\" == \"Comment\":\n#    a. Verify presence of \"author\" object.\n#    b. Verify \"datePublished\" exists.\n#    c. Verify at least one of \"text\", \"image\", or \"video\" exists.\n# 3. If any required field missing, mark as fail.\n"
    },
    "pass_condition": "All required properties (author, datePublished, and at least one of text/image/video) are present in each Comment markup.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Comment missing required property ${missing_property}."],
    "references": [
      {
        "doc_title": "Discussion forum structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/discussion-forum",
        "section_title": "Comment",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required", "structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Comment with required fields.",
        "snippet": "{\n  \"@type\":\"Comment\",\n  \"author\":{\"@type\":\"Person\",\"name\":\"Bob\"},\n  \"datePublished\":\"2024-01-02T00:00:00Z\",\n  \"text\":\"Nice post!\"\n}\n"
      },
      "failing": {
        "description": "Comment missing text and image/video.",
        "snippet": "{\n  \"@type\":\"Comment\",\n  \"author\":{\"@type\":\"Person\",\"name\":\"Bob\"},\n  \"datePublished\":\"2024-01-02T00:00:00Z\"\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "comment_all_present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Comment\",\"author\":{\"@type\":\"Person\",\"name\":\"Bob\"},\"datePublished\":\"2024-01-02T00:00:00Z\",\"text\":\"Nice\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "comment_missing_content",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Comment\",\"author\":{\"@type\":\"Person\",\"name\":\"Bob\"},\"datePublished\":\"2024-01-02T00:00:00Z\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "INTERACTIONCOUNTER_REQUIRED_PROPERTIES",
    "title": "Required properties for InteractionCounter",
    "category": "InteractionCounter required properties",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "InteractionCounter objects must include both count and type to be interpreted correctly.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "The full HTML of the page containing the structured data."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD block(s) and parse as JSON."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse JSON-LD scripts from html.\n# 2. For each object where \"@type\" == \"InteractionCounter\":\n#    a. Verify \"userInteractionCount\" exists.\n#    b. Verify \"interactionType\" exists.\n# 3. If any required field missing, mark as fail.\n"
    },
    "pass_condition": "Both userInteractionCount and interactionType are present in every InteractionCounter object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "InteractionCounter missing required property ${missing_property}."
    ],
    "references": [
      {
        "doc_title": "Discussion forum structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/discussion-forum",
        "section_title": "InteractionCounter",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["required", "structured_data"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "InteractionCounter with required fields.",
        "snippet": "{\n  \"@type\":\"InteractionCounter\",\n  \"userInteractionCount\":27,\n  \"interactionType\":\"https://schema.org/LikeAction\"\n}\n"
      },
      "failing": {
        "description": "Missing interactionType.",
        "snippet": "{\n  \"@type\":\"InteractionCounter\",\n  \"userInteractionCount\":27\n}\n"
      }
    },
    "test_cases": [
      {
        "name": "interactioncounter_complete",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"InteractionCounter\",\"userInteractionCount\":27,\"interactionType\":\"https://schema.org/LikeAction\"}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "interactioncounter_missing_type",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"InteractionCounter\",\"userInteractionCount\":27}</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FEED_FILE_SIZE_LIMIT",
    "title": "Feed file size must be less than 1\u202fGB",
    "category": "Create your feed",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "Google rejects feeds larger than 1\u202fGB, preventing processing.",
    "input_fields": [
      {
        "name": "file_size_bytes",
        "required": true,
        "description": "Size of the feed file in bytes."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "file",
        "attribute": "size",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: file_size_bytes\n# 1. If file_size_bytes < 1_073_741_824 then pass.\n# 2. Else fail.\n"
    },
    "pass_condition": "file size is less than 1\u202fGB.",
    "threshold": {
      "type": "number",
      "operator": "<",
      "value": 1073741824,
      "unit": "bytes",
      "notes": null
    },
    "fail_messages": [
      "Feed file size ${observed} exceeds the 1\u202fGB limit."
    ],
    "references": [
      {
        "doc_title": "Create your feed",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "Feed file size requirements",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["feed", "size"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Feed file of 500\u202fMB.",
        "snippet": "file_size_bytes: 524288000"
      },
      "failing": {
        "description": "Feed file of 2\u202fGB.",
        "snippet": "file_size_bytes: 2147483648"
      }
    },
    "test_cases": [
      {
        "name": "size_under_limit",
        "input_stub": {
          "file_size_bytes": 500000000
        },
        "expected_outcome": "pass"
      },
      {
        "name": "size_over_limit",
        "input_stub": {
          "file_size_bytes": 2000000000
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FEED_FILE_EXTENSION_JSON",
    "title": "Single feed files must have a .json filename extension",
    "category": "Create your feed",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Google expects JSON feeds; other extensions are not processed.",
    "input_fields": [
      {
        "name": "filename",
        "required": true,
        "description": "Name of the feed file."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "filename",
        "attribute": "extension",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: filename\n# 1. Extract extension after last dot.\n# 2. If extension equals \"json\" (case\u2011insensitive) then pass.\n# 3. Else fail.\n"
    },
    "pass_condition": "filename ends with \".json\".",
    "threshold": {
      "type": "string",
      "operator": "==",
      "value": "json",
      "unit": null,
      "notes": "case\u2011insensitive"
    },
    "fail_messages": ["Feed filename ${observed} does not end with .json."],
    "references": [
      {
        "doc_title": "Create your feed",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "Single feed files must have the .json filename extension",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["feed", "filename"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "books_feed.json",
        "snippet": "filename: books_feed.json"
      },
      "failing": {
        "description": "books_feed.txt",
        "snippet": "filename: books_feed.txt"
      }
    },
    "test_cases": [
      {
        "name": "json_extension",
        "input_stub": {
          "filename": "books_feed.json"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "wrong_extension",
        "input_stub": {
          "filename": "books_feed.txt"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FEED_NO_STALE_ENTITIES",
    "title": "Feed must not contain stale entities (availabilityEnds in the past)",
    "category": "Create your feed",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "Stale entities cannot be matched and will not be displayed in Search.",
    "input_fields": [
      {
        "name": "feed_json",
        "required": true,
        "description": "Parsed JSON of the feed."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "json_path",
        "selector": "$..availabilityEnds",
        "attribute": null,
        "notes": "ISO\u20118601 timestamps"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: feed_json, current_timestamp\n# 1. For each entity with availabilityEnds:\n#    a. Parse the timestamp.\n#    b. If timestamp < current_timestamp then fail.\n# 2. If no such timestamps are in the past, pass.\n"
    },
    "pass_condition": "No availabilityEnds dates are earlier than now.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "compare against current time"
    },
    "fail_messages": [
      "Entity with @id ${entity_id} has stale availabilityEnds ${observed}."
    ],
    "references": [
      {
        "doc_title": "Create your feed",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "Feed mustn't contain stale entities",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["feed", "freshness"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All availabilityEnds dates are future dates.",
        "snippet": "\"availabilityEnds\": \"2050-06-30T23:59:00-04:00\"\n"
      },
      "failing": {
        "description": "An entity has past availabilityEnds.",
        "snippet": "\"availabilityEnds\": \"2020-01-01T00:00:00Z\"\n"
      }
    },
    "test_cases": [
      {
        "name": "future_dates",
        "input_stub": {
          "feed_json": {
            "entities": [
              {
                "@id": "book1",
                "availabilityEnds": "2050-01-01T00:00:00Z"
              }
            ]
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "past_dates",
        "input_stub": {
          "feed_json": {
            "entities": [
              {
                "@id": "book2",
                "availabilityEnds": "2020-01-01T00:00:00Z"
              }
            ]
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "FEED_URLS_PRODUCTION",
    "title": "All URLs in the feed must be production URLs (no QA, dev, or non\u2011production URLs)",
    "category": "Create your feed",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "Non\u2011production URLs cannot be accessed by users and will be rejected.",
    "input_fields": [
      {
        "name": "feed_json",
        "required": true,
        "description": "Parsed JSON of the feed."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "json_path",
        "selector": "$..url",
        "attribute": null,
        "notes": "full URL strings"
      },
      {
        "type": "json_path",
        "selector": "$..urlTemplate",
        "attribute": null,
        "notes": "deep link templates"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: feed_json\n# 1. Define a list of prohibited host patterns (e.g., \"localhost\", \"dev.\", \"staging.\", \"qa.\").\n# 2. For each url or urlTemplate in the feed:\n#    a. Parse hostname.\n#    b. If hostname matches any prohibited pattern then fail.\n# 3. If none match, pass.\n"
    },
    "pass_condition": "No URL or urlTemplate points to a non\u2011production host.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "hostname must not contain prohibited substrings"
    },
    "fail_messages": [
      "URL ${observed} appears to be a non\u2011production address."
    ],
    "references": [
      {
        "doc_title": "Create your feed",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "All URLs must be production URLs",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["feed", "url"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL points to example.com.",
        "snippet": "\"url\": \"https://example.com/book/123\"\n"
      },
      "failing": {
        "description": "URL points to dev.example.com.",
        "snippet": "\"url\": \"https://dev.example.com/book/123\"\n"
      }
    },
    "test_cases": [
      {
        "name": "production_url",
        "input_stub": {
          "feed_json": {
            "urls": ["https://example.com/book/123"]
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "dev_url",
        "input_stub": {
          "feed_json": {
            "urls": ["https://dev.example.com/book/123"]
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ENTITY_UNIQUE_IDENTIFIERS",
    "title": "Each entity must have a unique @id, url, and urlTemplate",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "Duplicated identifiers cause ambiguity and may prevent correct indexing.",
    "input_fields": [
      {
        "name": "feed_json",
        "required": true,
        "description": "Parsed JSON of the feed."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "json_path",
        "selector": "$..@id",
        "attribute": null,
        "notes": "entity identifiers"
      },
      {
        "type": "json_path",
        "selector": "$..url",
        "attribute": null,
        "notes": "entity URLs"
      },
      {
        "type": "json_path",
        "selector": "$..urlTemplate",
        "attribute": null,
        "notes": "deep link templates"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: feed_json\n# 1. Collect all @id values into set ids.\n# 2. If size(ids) != number of entities then fail.\n# 3. Collect all url values into set urls; check duplicates similarly.\n# 4. Collect all urlTemplate values into set templates; check duplicates.\n# 5. If any duplicates found, fail; else pass.\n"
    },
    "pass_condition": "No duplicate @id, url, or urlTemplate values exist.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "uniqueness across the feed"
    },
    "fail_messages": ["Duplicate ${field} found: ${observed}."],
    "references": [
      {
        "doc_title": "Structured data type definitions",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "Required properties for each entity",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["identifiers", "uniqueness"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All identifiers are unique.",
        "snippet": "\"@id\": \"https://example.com/book/1\"\n\"url\": \"https://example.com/book/1\"\n\"urlTemplate\": \"https://example.com/purchase/1\"\n"
      },
      "failing": {
        "description": "Two entities share the same @id.",
        "snippet": "\"@id\": \"https://example.com/book/1\"\n\"@id\": \"https://example.com/book/1\"\n"
      }
    },
    "test_cases": [
      {
        "name": "unique_ids",
        "input_stub": {
          "feed_json": {
            "entities": [
              {
                "@id": "https://example.com/book/1",
                "url": "https://example.com/book/1",
                "urlTemplate": "https://example.com/purchase/1"
              },
              {
                "@id": "https://example.com/book/2",
                "url": "https://example.com/book/2",
                "urlTemplate": "https://example.com/purchase/2"
              }
            ]
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "duplicate_id",
        "input_stub": {
          "feed_json": {
            "entities": [
              {
                "@id": "https://example.com/book/1",
                "url": "https://example.com/book/1",
                "urlTemplate": "https://example.com/purchase/1"
              },
              {
                "@id": "https://example.com/book/1",
                "url": "https://example.com/book/2",
                "urlTemplate": "https://example.com/purchase/2"
              }
            ]
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DATAFEED_REQUIRED_PROPERTIES",
    "title": "DataFeed entity must contain required properties",
    "category": "Structured data type definitions",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "resource",
    "rationale": "Missing required DataFeed fields prevent the feed from being parsed.",
    "input_fields": [
      {
        "name": "feed_json",
        "required": true,
        "description": "Parsed JSON of the feed."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "json_path",
        "selector": "$.@context",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.dataFeedElement",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.dateModified",
        "attribute": null,
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: feed_json\n# 1. Verify presence of @context, @type, dataFeedElement, dateModified at the root.\n# 2. If any missing, fail.\n# 3. Else pass.\n"
    },
    "pass_condition": "All four required root properties are present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "presence check"
    },
    "fail_messages": [
      "Missing required DataFeed property: ${missing_property}."
    ],
    "references": [
      {
        "doc_title": "Structured data type definitions",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "DataFeed entity required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["datafeed", "required"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Feed includes all required root fields.",
        "snippet": "\"@context\": \"https://schema.org\",\n\"@type\": \"DataFeed\",\n\"dataFeedElement\": [...],\n\"dateModified\": \"2023-01-01T00:00:00Z\"\n"
      },
      "failing": {
        "description": "Feed missing @type.",
        "snippet": "\"@context\": \"https://schema.org\",\n\"dataFeedElement\": [...],\n\"dateModified\": \"2023-01-01T00:00:00Z\"\n"
      }
    },
    "test_cases": [
      {
        "name": "all_present",
        "input_stub": {
          "feed_json": {
            "@context": "https://schema.org",
            "@type": "DataFeed",
            "dataFeedElement": [],
            "dateModified": "2023-01-01T00:00:00Z"
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_type",
        "input_stub": {
          "feed_json": {
            "@context": "https://schema.org",
            "dataFeedElement": [],
            "dateModified": "2023-01-01T00:00:00Z"
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "READACTION_REQUIRED_PROPERTIES",
    "title": "ReadAction must contain all required properties",
    "category": "ReadAction",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "resource",
    "rationale": "Incomplete ReadAction prevents users from purchasing the book.",
    "input_fields": [
      {
        "name": "action_json",
        "required": true,
        "description": "JSON object representing a ReadAction."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "json_path",
        "selector": "$.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.expectsAcceptanceOf",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.expectsAcceptanceOf.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.expectsAcceptanceOf.category",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.expectsAcceptanceOf.eligibleRegion",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.expectsAcceptanceOf.eligibleRegion.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.expectsAcceptanceOf.eligibleRegion.name",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target.actionPlatform",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target.urlTemplate",
        "attribute": null,
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: action_json\n# 1. Define list of required JSON paths (as above).\n# 2. For each path, check existence.\n# 3. If any missing, fail with missing_property.\n# 4. Else pass.\n"
    },
    "pass_condition": "All listed JSON paths exist in the ReadAction object.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "presence of each required field"
    },
    "fail_messages": [
      "ReadAction missing required field: ${missing_property}."
    ],
    "references": [
      {
        "doc_title": "ReadAction",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "ReadAction required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["readaction", "required"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Complete ReadAction example.",
        "snippet": "\"@type\": \"ReadAction\",\n\"target\": {\n  \"@type\": \"EntryPoint\",\n  \"urlTemplate\": \"https://example.com/purchase?bookId=170\",\n  \"actionPlatform\": [\"https://schema.org/DesktopWebPlatform\"]\n},\n\"expectsAcceptanceOf\": {\n  \"@type\": \"Offer\",\n  \"category\": \"purchase\",\n  \"eligibleRegion\": {\"@type\": \"Country\", \"name\": \"US\"}\n}\n"
      },
      "failing": {
        "description": "Missing target.urlTemplate.",
        "snippet": "\"@type\": \"ReadAction\",\n\"target\": {\"@type\": \"EntryPoint\", \"actionPlatform\": []},\n\"expectsAcceptanceOf\": {...}\n"
      }
    },
    "test_cases": [
      {
        "name": "complete_readaction",
        "input_stub": {
          "action_json": {
            "@type": "ReadAction",
            "target": {
              "@type": "EntryPoint",
              "urlTemplate": "https://example.com/purchase?bookId=170",
              "actionPlatform": ["https://schema.org/DesktopWebPlatform"]
            },
            "expectsAcceptanceOf": {
              "@type": "Offer",
              "category": "purchase",
              "eligibleRegion": {
                "@type": "Country",
                "name": "US"
              }
            }
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_urlTemplate",
        "input_stub": {
          "action_json": {
            "@type": "ReadAction",
            "target": {
              "@type": "EntryPoint",
              "actionPlatform": ["https://schema.org/DesktopWebPlatform"]
            },
            "expectsAcceptanceOf": {
              "@type": "Offer",
              "category": "purchase",
              "eligibleRegion": {
                "@type": "Country",
                "name": "US"
              }
            }
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "BORROWACTION_REQUIRED_PROPERTIES",
    "title": "BorrowAction must contain all required properties",
    "category": "BorrowAction",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "resource",
    "rationale": "Missing required fields prevent users from borrowing the book.",
    "input_fields": [
      {
        "name": "action_json",
        "required": true,
        "description": "JSON object representing a BorrowAction."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "json_path",
        "selector": "$.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.lender",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.lender.@id",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.lender.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target.@type",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target.actionPlatform",
        "attribute": null,
        "notes": null
      },
      {
        "type": "json_path",
        "selector": "$.target.urlTemplate",
        "attribute": null,
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: action_json\n# 1. Verify existence of each required JSON path listed above.\n# 2. If any missing, fail with missing_property.\n# 3. Else pass.\n"
    },
    "pass_condition": "All required BorrowAction fields are present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "presence check"
    },
    "fail_messages": [
      "BorrowAction missing required field: ${missing_property}."
    ],
    "references": [
      {
        "doc_title": "BorrowAction",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "BorrowAction required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["borrowaction", "required"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Complete BorrowAction example.",
        "snippet": "\"@type\": \"BorrowAction\",\n\"lender\": {\"@type\": \"LibrarySystem\", \"@id\": \"https://example.com/librarySystem/100\"},\n\"target\": {\"@type\": \"EntryPoint\", \"urlTemplate\": \"https://example.com/borrow?bookId=170\", \"actionPlatform\": [\"https://schema.org/DesktopWebPlatform\"]}\n"
      },
      "failing": {
        "description": "Missing lender.@id.",
        "snippet": "\"@type\": \"BorrowAction\",\n\"lender\": {\"@type\": \"LibrarySystem\"},\n\"target\": {...}\n"
      }
    },
    "test_cases": [
      {
        "name": "complete_borrowaction",
        "input_stub": {
          "action_json": {
            "@type": "BorrowAction",
            "lender": {
              "@type": "LibrarySystem",
              "@id": "https://example.com/librarySystem/100"
            },
            "target": {
              "@type": "EntryPoint",
              "urlTemplate": "https://example.com/borrow?bookId=170",
              "actionPlatform": ["https://schema.org/DesktopWebPlatform"]
            }
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_lender_id",
        "input_stub": {
          "action_json": {
            "@type": "BorrowAction",
            "lender": {
              "@type": "LibrarySystem"
            },
            "target": {
              "@type": "EntryPoint",
              "urlTemplate": "https://example.com/borrow?bookId=170",
              "actionPlatform": ["https://schema.org/DesktopWebPlatform"]
            }
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LINK_CANONICAL_URL",
    "title": "Links must use the canonical URL containing the book title and information",
    "category": "Links",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Canonical URLs avoid duplicate content and ensure correct indexing.",
    "input_fields": [
      {
        "name": "link_url",
        "required": true,
        "description": "URL used in a ReadAction or BorrowAction."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "link_url",
        "attribute": null,
        "notes": "URL string"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: link_url\n# 1. Verify that link_url contains the book title (case\u2011insensitive) or other book metadata.\n#    (Assume title is available via a separate input; for deterministic check we only verify presence of a non\u2011empty path segment.)\n# 2. Verify that the URL is marked as canonical (e.g., matches the rel=canonical of the target page). This requires fetching the page and checking its <link rel=\"canonical\"> href.\n# 3. If both conditions satisfied, pass; else fail.\n"
    },
    "pass_condition": "URL is the page\u2019s canonical URL and includes book\u2011specific path.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "requires page fetch and rel=canonical comparison"
    },
    "fail_messages": [
      "Link URL ${observed} is not the canonical URL or lacks book\u2011specific information."
    ],
    "references": [
      {
        "doc_title": "Links",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "Links guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["link", "canonical"],
    "insufficient_evidence": false,
    "notes": "Requires HTTP fetch of the target page.",
    "examples": {
      "passing": {
        "description": "URL matches rel=canonical and contains book title.",
        "snippet": "\"link_url\": \"https://example.com/book/the-catcher-in-the-rye/purchase\"\n"
      },
      "failing": {
        "description": "URL points to a generic search page.",
        "snippet": "\"link_url\": \"https://example.com/search?q=the+catcher+in+the+rye\"\n"
      }
    },
    "test_cases": [
      {
        "name": "canonical_with_title",
        "input_stub": {
          "link_url": "https://example.com/book/the-catcher-in-the-rye/purchase"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "non_canonical",
        "input_stub": {
          "link_url": "https://example.com/search?q=the+catcher+in+the+rye"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LINK_DIRECT_PURCHASE",
    "title": "Action links must lead directly to a purchase or borrowing page, not intermediate pages",
    "category": "Links",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Users should not need extra clicks to complete the action; improves experience and compliance.",
    "input_fields": [
      {
        "name": "target_url",
        "required": true,
        "description": "URL from the action\u2019s EntryPoint."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "target_url",
        "attribute": null,
        "notes": "Fetch the page and analyze its content."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: target_url\n# 1. Fetch target_url.\n# 2. Analyze the page content for indicators of a final purchase/borrow page (e.g., presence of a buy button, form with action \"purchase\", or library checkout widget).\n# 3. If the page appears to be a search results or product summary page (e.g., contains a list of multiple items), fail.\n# 4. Otherwise, pass.\n"
    },
    "pass_condition": "Fetched page is a final purchase/borrow page, not an intermediate list or search page.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": "content analysis required"
    },
    "fail_messages": [
      "Target URL ${observed} does not lead directly to a purchase/borrow page."
    ],
    "references": [
      {
        "doc_title": "Links",
        "url": "https://developers.google.com/search/docs/data-feeds/book-actions",
        "section_title": "Links guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["link", "user_experience"],
    "insufficient_evidence": false,
    "notes": "Requires page content inspection.",
    "examples": {
      "passing": {
        "description": "URL points to a checkout page.",
        "snippet": "\"target_url\": \"https://example.com/checkout?bookId=123\"\n"
      },
      "failing": {
        "description": "URL points to a search results page.",
        "snippet": "\"target_url\": \"https://example.com/search?query=book+123\"\n"
      }
    },
    "test_cases": [
      {
        "name": "direct_checkout",
        "input_stub": {
          "target_url": "https://example.com/checkout?bookId=123"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "intermediate_search",
        "input_stub": {
          "target_url": "https://example.com/search?query=book+123"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PRODUCT_NAME_REQUIRED",
    "title": "Product must include name property",
    "category": "Product",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The Product structured data definition lists 'name' as a required property for eligibility as a product snippet.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing the structured data."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD and verify that an object with \"@type\": \"Product\" contains a non\u2011empty \"name\" field."
      },
      {
        "type": "attribute",
        "selector": "[itemscope][itemtype*='Product']",
        "attribute": "itemprop='name'",
        "notes": "Check Microdata for a name property within a Product item."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all JSON\u2011LD script blocks.\n# 2. For each block, parse JSON and locate objects where \"@type\" == \"Product\".\n# 3. If such an object has a \"name\" field with a non\u2011empty string, mark as pass.\n# 4. If not found, search the HTML for elements with itemscope and itemtype containing \"Product\" and attribute itemprop=\"name\".\n# 5. If a non\u2011empty name attribute is found, pass; otherwise fail.\n"
    },
    "pass_condition": "At least one Product markup instance contains a non\u2011empty name property.",
    "threshold": null,
    "fail_messages": [
      "Missing required 'name' property in Product structured data."
    ],
    "references": [
      {
        "doc_title": "Product",
        "url": "https://developers.google.com/search/docs/structured-data/product",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product", "structured_data"],
    "insufficient_evidence": false,
    "examples": {
      "passing": {
        "description": "Product JSON\u2011LD with name.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Product\",\n  \"name\": \"Executive Anvil\"\n}\n</script>\n"
      },
      "failing": {
        "description": "Product JSON\u2011LD without name.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Product\",\n  \"description\": \"A fine anvil.\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Product name present",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Product\",\"name\":\"Executive Anvil\"}</script>"
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "PRODUCT_REVIEW_OR_AGGREGATE_RATING_OR_OFFERS_REQUIRED",
    "title": "Product must include at least one of review, aggregateRating, or offers",
    "category": "Product",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Product snippets are eligible only when the Product markup contains either a review, an aggregateRating, or an offers property.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Parse JSON\u2011LD Product objects and check for presence of 'review', 'aggregateRating', or 'offers'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract JSON\u2011LD scripts.\n# 2. For each Product object, set flag = false.\n# 3. If object contains a non\u2011empty \"review\" field, flag = true.\n# 4. Else if it contains a non\u2011empty \"aggregateRating\" field, flag = true.\n# 5. Else if it contains a non\u2011empty \"offers\" field, flag = true.\n# 6. If flag is true for any Product object, pass; otherwise fail.\n"
    },
    "pass_condition": "Product markup includes at least one of review, aggregateRating, or offers.",
    "threshold": null,
    "fail_messages": [
      "Product markup lacks review, aggregateRating, and offers properties."
    ],
    "references": [
      {
        "doc_title": "Product",
        "url": "https://developers.google.com/search/docs/structured-data/product",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product", "structured_data"],
    "insufficient_evidence": false,
    "examples": {
      "passing": {
        "description": "Product with an offers object.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Product\",\n  \"offers\": { \"price\": \"19.99\", \"priceCurrency\": \"USD\" }\n}\n</script>\n"
      },
      "failing": {
        "description": "Product without review, aggregateRating, or offers.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Product\",\n  \"name\": \"Widget\"\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Product with offers",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Product\",\"offers\":{\"price\":\"19.99\",\"priceCurrency\":\"USD\"}}</script>"
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "REVIEW_PROS_CONS_STATEMENTS_REQUIRED",
    "title": "Editorial review must provide at least two pros/cons statements",
    "category": "Review",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Pros and cons appearance requires an editorial review to contain two statements about the product via positiveNotes or negativeNotes.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [
      "Page is an editorial product review that intends to display pros and cons."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Locate Review objects and count items in positiveNotes.itemListElement and negativeNotes.itemListElement."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract JSON\u2011LD scripts.\n# 2. Find Review objects within Product markup.\n# 3. Initialize count = 0.\n# 4. If Review has positiveNotes with itemListElement array, add its length to count.\n# 5. If Review has negativeNotes with itemListElement array, add its length to count.\n# 6. If count >= 2, pass; else fail.\n"
    },
    "pass_condition": "The review provides at least two ListItem statements across positiveNotes and/or negativeNotes.",
    "threshold": null,
    "fail_messages": [
      "Insufficient pros/cons statements; fewer than two ListItem entries found."
    ],
    "references": [
      {
        "doc_title": "Review",
        "url": "https://developers.google.com/search/docs/structured-data/review-snippet",
        "section_title": "Pros and cons",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["review", "pros_cons"],
    "insufficient_evidence": false,
    "examples": {
      "passing": {
        "description": "Review with two positive notes.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Review\",\n  \"positiveNotes\": {\n    \"@type\": \"ItemList\",\n    \"itemListElement\": [\n      { \"@type\": \"ListItem\", \"position\": 1, \"name\": \"Sharp\" },\n      { \"@type\": \"ListItem\", \"position\": 2, \"name\": \"Durable\" }\n    ]\n  }\n}\n</script>\n"
      },
      "failing": {
        "description": "Review with only one note.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"Review\",\n  \"positiveNotes\": {\n    \"@type\": \"ItemList\",\n    \"itemListElement\": [\n      { \"@type\": \"ListItem\", \"position\": 1, \"name\": \"Sharp\" }\n    ]\n  }\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Two pros statements",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Review\",\"positiveNotes\":{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Sharp\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Durable\"}]}}</script>"
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "OFFER_PRICE_REQUIRED",
    "title": "Offer must include price or priceSpecification.price",
    "category": "Offer",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The Offer type requires a price (or a priceSpecification with a price) to be valid for product snippets.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Find Offer objects and verify presence of 'price' or 'priceSpecification' containing 'price'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract JSON\u2011LD.\n# 2. Locate objects where \"@type\" == \"Offer\".\n# 3. If object has a non\u2011empty \"price\" field, pass.\n# 4. Else if object has \"priceSpecification\" object with a non\u2011empty \"price\" field, pass.\n# 5. Otherwise, fail.\n"
    },
    "pass_condition": "Offer markup contains a price value directly or via priceSpecification.",
    "threshold": null,
    "fail_messages": ["Offer missing required price information."],
    "references": [
      {
        "doc_title": "Offer",
        "url": "https://developers.google.com/search/docs/structured-data/offer",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["offer", "structured_data"],
    "insufficient_evidence": false,
    "examples": {
      "passing": {
        "description": "Offer with price.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\": \"Offer\", \"price\": \"29.99\", \"priceCurrency\": \"USD\" }\n</script>\n"
      },
      "failing": {
        "description": "Offer without price.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\": \"Offer\", \"availability\": \"InStock\" }\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Offer with price",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"Offer\",\"price\":\"29.99\",\"priceCurrency\":\"USD\"}</script>"
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "AGGREGATE_OFFER_REQUIRED_PROPERTIES",
    "title": "AggregateOffer must include lowPrice and priceCurrency",
    "category": "AggregateOffer",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "AggregateOffer requires lowPrice and priceCurrency as mandatory fields for product snippets.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Locate AggregateOffer objects and verify presence of 'lowPrice' and 'priceCurrency'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract JSON\u2011LD.\n# 2. Find objects where \"@type\" == \"AggregateOffer\".\n# 3. Check that both \"lowPrice\" and \"priceCurrency\" fields exist and are non\u2011empty.\n# 4. If both present, pass; otherwise fail.\n"
    },
    "pass_condition": "AggregateOffer includes both lowPrice and priceCurrency.",
    "threshold": null,
    "fail_messages": ["AggregateOffer missing lowPrice or priceCurrency."],
    "references": [
      {
        "doc_title": "AggregateOffer",
        "url": "https://developers.google.com/search/docs/structured-data/aggregate-offer",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["aggregate_offer", "structured_data"],
    "insufficient_evidence": false,
    "examples": {
      "passing": {
        "description": "Valid AggregateOffer.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\": \"AggregateOffer\", \"lowPrice\": \"119.99\", \"priceCurrency\": \"USD\" }\n</script>\n"
      },
      "failing": {
        "description": "AggregateOffer missing priceCurrency.",
        "snippet": "<script type=\"application/ld+json\">\n{ \"@type\": \"AggregateOffer\", \"lowPrice\": \"119.99\" }\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "AggregateOffer with required fields",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"AggregateOffer\",\"lowPrice\":\"119.99\",\"priceCurrency\":\"USD\"}</script>"
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "ITEMLIST_REQUIRED_PROPERTIES",
    "title": "ItemList must include itemListElement with name",
    "category": "ItemList",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "ItemList used for pros and cons requires itemListElement entries each having a name.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Find ItemList objects and ensure each itemListElement has a non\u2011empty 'name' field."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract JSON\u2011LD.\n# 2. Locate objects where \"@type\" == \"ItemList\".\n# 3. For each item in \"itemListElement\" array, verify that \"name\" exists and is non\u2011empty.\n# 4. If all items satisfy the condition, pass; otherwise fail.\n"
    },
    "pass_condition": "All ItemList entries contain a name property.",
    "threshold": null,
    "fail_messages": ["ItemList entry missing required name field."],
    "references": [
      {
        "doc_title": "ItemList",
        "url": "https://developers.google.com/search/docs/structured-data/itemlist",
        "section_title": "Required properties",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["itemlist", "pros_cons"],
    "insufficient_evidence": false,
    "examples": {
      "passing": {
        "description": "ItemList with named elements.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"ItemList\",\n  \"itemListElement\": [\n    { \"@type\": \"ListItem\", \"position\": 1, \"name\": \"Sharp\" },\n    { \"@type\": \"ListItem\", \"position\": 2, \"name\": \"Durable\" }\n  ]\n}\n</script>\n"
      },
      "failing": {
        "description": "ItemList with missing name.",
        "snippet": "<script type=\"application/ld+json\">\n{\n  \"@type\": \"ItemList\",\n  \"itemListElement\": [\n    { \"@type\": \"ListItem\", \"position\": 1 }\n  ]\n}\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "ItemList with names",
        "input_stub": {
          "html": "<script type='application/ld+json'>{\"@type\":\"ItemList\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Sharp\"}]}</script>"
        },
        "expected_outcome": "pass"
      }
    ]
  },
  {
    "id": "PRODUCTGROUP_NAME_REQUIRED",
    "title": "ProductGroup must include a name property",
    "category": "ProductGroup",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "The name property is required for a ProductGroup to be eligible for rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing the JSON\u2011LD script."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"ProductGroup\"[\\s\\S]*?\"name\"\\s*:\\s*\"([^\"]+)\"",
        "attribute": null,
        "notes": "Captures the value of the name property inside a ProductGroup object."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract all JSON\u2011LD script blocks of type application/ld+json.\n# 2. For each block, parse as JSON.\n# 3. For each object where \"@type\" == \"ProductGroup\":\n#    a. If \"name\" property is missing or empty \u2192 record failure.\n# 4. If any failures recorded \u2192 overall fail, else pass.\n"
    },
    "pass_condition": "All ProductGroup objects contain a non\u2011empty name property.",
    "fail_messages": ["ProductGroup missing name property."],
    "references": [
      {
        "doc_title": "Product variant structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/product-variant",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product-variant", "structured-data"],
    "insufficient_evidence": false
  },
  {
    "id": "VARIANT_UNIQUE_ID",
    "title": "Each Product variant must have a unique identifier (sku or gtin14)",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Unique identifiers enable Google to distinguish individual variants.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing the JSON\u2011LD script."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"Product\"[\\s\\S]*?\"(sku|gtin14)\"\\s*:\\s*\"([^\"]+)\"",
        "attribute": null,
        "notes": "Captures sku or gtin14 values for each Product variant."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract all JSON\u2011LD script blocks.\n# 2. Parse each block as JSON.\n# 3. For each object where \"@type\" == \"Product\":\n#    a. Record the value of \"sku\" if present, else \"gtin14\" if present.\n#    b. If neither is present \u2192 record missing\u2011id failure.\n# 4. Check that all recorded identifiers are unique.\n# 5. If any missing\u2011id or duplicate identifiers \u2192 fail, else pass.\n"
    },
    "pass_condition": "Every Product has a sku or gtin14 and all identifiers are unique on the page.",
    "fail_messages": [
      "Variant missing identifier (sku or gtin14) or duplicate identifier found: ${observed}"
    ],
    "references": [
      {
        "doc_title": "Product variant structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/product-variant",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product-variant", "structured-data"],
    "insufficient_evidence": false
  },
  {
    "id": "PRODUCTGROUP_UNIQUE_ID",
    "title": "ProductGroup must have a non\u2011empty productGroupID",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "productGroupID links variants to their parent group.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page containing the JSON\u2011LD script."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"ProductGroup\"[\\s\\S]*?\"productGroupID\"\\s*:\\s*\"([^\"]+)\"",
        "attribute": null,
        "notes": "Captures the productGroupID value."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract JSON\u2011LD scripts.\n# 2. Parse JSON.\n# 3. For each object where \"@type\" == \"ProductGroup\":\n#    a. Verify \"productGroupID\" exists and is non\u2011empty.\n# 4. If any ProductGroup lacks this property \u2192 fail, else pass.\n"
    },
    "pass_condition": "All ProductGroup objects contain a non\u2011empty productGroupID.",
    "fail_messages": ["ProductGroup missing productGroupID."],
    "references": [
      {
        "doc_title": "Product variant structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/product-variant",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product-variant", "structured-data"],
    "insufficient_evidence": false
  },
  {
    "id": "SINGLE_PAGE_CANONICAL_URL",
    "title": "Single\u2011page sites must have a single canonical URL without query parameters for the ProductGroup",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "A single canonical URL identifies the overall product group for all variants.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"canonical\"]",
        "attribute": "href",
        "notes": "Extracts the href attribute of the canonical link element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse HTML.\n# 2. Find all <link rel=\"canonical\"> elements.\n# 3. If count != 1 \u2192 fail.\n# 4. Extract href; if href contains \"?\" \u2192 fail.\n# 5. Otherwise pass.\n"
    },
    "pass_condition": "Exactly one canonical link is present and its href does not contain query parameters.",
    "fail_messages": [
      "Canonical URL missing, multiple canonical URLs found, or canonical URL contains query parameters."
    ],
    "references": [
      {
        "doc_title": "Product variant structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/product-variant",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product-variant", "canonical"],
    "insufficient_evidence": false
  },
  {
    "id": "VARIANT_URL_QUERY_PARAMS",
    "title": "Each variant's offer URL must include query parameters for preselection",
    "category": "Technical guidelines",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Query parameters allow Google to crawl each variant directly.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content containing JSON\u2011LD."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "\"@type\"\\s*:\\s*\"Product\"[\\s\\S]*?\"offers\"[\\s\\S]*?\"url\"\\s*:\\s*\"([^\"]+)\"",
        "attribute": null,
        "notes": "Captures the URL of each Product's offer."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract JSON\u2011LD scripts and parse.\n# 2. For each object where \"@type\" == \"Product\":\n#    a. Locate the nested offers.url.\n#    b. If the URL does not contain \"?\" \u2192 record failure.\n# 3. If any failures recorded \u2192 fail, else pass.\n"
    },
    "pass_condition": "All offers URLs contain a '?' character indicating query parameters.",
    "fail_messages": [
      "Offer URL missing query parameters for variant: ${observed}"
    ],
    "references": [
      {
        "doc_title": "Product variant structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/product-variant",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product-variant", "url"],
    "insufficient_evidence": false
  },
  {
    "id": "PRODUCT_STRUCTURED_DATA_PRESENT",
    "title": "Product structured data should be included with required properties",
    "category": "Technical guidelines",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "page",
    "rationale": "Product markup is required for eligibility of product listings.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type=\"application/ld+json\"]",
        "attribute": null,
        "notes": "Retrieves JSON\u2011LD blocks to inspect for Product objects."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Extract all <script type=\"application/ld+json\"> blocks.\n# 2. Parse each block as JSON.\n# 3. If any object has \"@type\" == \"Product\" \u2192 pass.\n# 4. Otherwise \u2192 fail.\n"
    },
    "pass_condition": "At least one Product object is present in the page's structured data.",
    "fail_messages": ["No Product structured data found on the page."],
    "references": [
      {
        "doc_title": "Product variant structured data",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/product-variant",
        "section_title": "Technical guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["product-variant", "structured-data"],
    "insufficient_evidence": false
  },
  {
    "id": "VIDEOOBJECT_REQUIRED_PROPERTIES",
    "title": "VideoObject must include required properties",
    "category": "VideoObject",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Required properties (name, thumbnailUrl, uploadDate) are mandatory for eligibility in Google Search.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the VideoObject markup."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON-LD and parse for @type == 'VideoObject'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse HTML and locate <script type=\"application/ld+json\"> blocks.\n# 2. For each block, parse JSON.\n# 3. If JSON[\"@type\"] == \"VideoObject\":\n#    a. Check presence of keys \"name\", \"thumbnailUrl\", \"uploadDate\".\n#    b. Record missing keys.\n# 4. If any VideoObject missing a required key -> fail.\n"
    },
    "pass_condition": "All VideoObject instances contain name, thumbnailUrl, and uploadDate.",
    "fail_messages": [
      "Missing required VideoObject property: ${missing_property}"
    ],
    "references": [
      {
        "doc_title": "Video (VideoObject, Clip, BroadcastEvent) Schema Markup",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/video",
        "section_title": "VideoObject",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video", "structured-data"],
    "insufficient_evidence": false
  },
  {
    "id": "VIDEOOBJECT_DURATION_MINIMUM",
    "title": "Video duration must be at least 30 seconds",
    "category": "Clip and SeekToAction guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Minimum duration of 30\u202fseconds is required for Clip and SeekToAction features.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the VideoObject markup."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract ISO\u202f8601 duration string from VideoObject.duration."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Locate VideoObject JSON-LD as in previous check.\n# 2. Extract the \"duration\" value (e.g., \"PT1M54S\").\n# 3. Convert ISO\u202f8601 duration to total seconds.\n# 4. If total_seconds < 30 -> fail.\n"
    },
    "pass_condition": "VideoObject.duration represents 30 seconds or more.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 30,
      "unit": "seconds",
      "notes": null
    },
    "fail_messages": [
      "Video duration ${observed_seconds}s is less than the required 30 seconds."
    ],
    "references": [
      {
        "doc_title": "Video (VideoObject, Clip, BroadcastEvent) Schema Markup",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/video",
        "section_title": "Clip and SeekToAction guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video", "duration"],
    "insufficient_evidence": false
  },
  {
    "id": "VIDEOOBJECT_DEEP_LINK_ABILITY",
    "title": "Video must support deep linking via URL parameters",
    "category": "Clip and SeekToAction guidelines",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "page",
    "rationale": "Deep linking enables Clip and SeekToAction features to direct users to specific timestamps.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the VideoObject markup."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Search for Clip.url containing '?t=' or SeekToAction.target containing '{seek_to_second_number}'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse VideoObject JSON-LD.\n# 2. If any Clip object exists:\n#    a. Verify its \"url\" contains \"?t=\" (case\u2011insensitive).\n# 3. If a SeekToAction object exists:\n#    a. Verify its \"target\" contains the placeholder \"{seek_to_second_number}\".\n# 4. If neither condition is true -> fail.\n"
    },
    "pass_condition": "At least one Clip URL with \"?t=\" or a SeekToAction target with placeholder is present.",
    "fail_messages": [
      "No deep\u2011link URL found in Clip or SeekToAction markup."
    ],
    "references": [
      {
        "doc_title": "Video (VideoObject, Clip, BroadcastEvent) Schema Markup",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/video",
        "section_title": "Clip and SeekToAction guidelines",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video", "deeplink"],
    "insufficient_evidence": false
  },
  {
    "id": "BROADCASTEVENT_REQUIRED_PROPERTIES",
    "title": "BroadcastEvent must include required properties for LIVE badge",
    "category": "BroadcastEvent",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Required BroadcastEvent fields (publication, startDate, endDate, isLiveBroadcast) are needed to display the LIVE badge.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the VideoObject and BroadcastEvent markup."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Locate objects where @type == 'BroadcastEvent' inside VideoObject.publication."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse VideoObject JSON-LD.\n# 2. For each item in \"publication\" array where \"@type\" == \"BroadcastEvent\":\n#    a. Verify presence of \"startDate\", \"endDate\", \"isLiveBroadcast\".\n# 3. If any required field missing -> fail.\n"
    },
    "pass_condition": "Every BroadcastEvent in publication includes startDate, endDate, and isLiveBroadcast.",
    "fail_messages": [
      "BroadcastEvent missing required field: ${missing_field}"
    ],
    "references": [
      {
        "doc_title": "Video (VideoObject, Clip, BroadcastEvent) Schema Markup",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/video",
        "section_title": "BroadcastEvent",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video", "livestream"],
    "insufficient_evidence": false
  },
  {
    "id": "CLIP_REQUIRED_PROPERTIES",
    "title": "Clip must include required properties",
    "category": "Clip",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Name, startOffset, and URL are mandatory for Clip markup to be used for key moments.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the VideoObject with Clip markup."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Find objects where @type == 'Clip' inside VideoObject.hasPart."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse VideoObject JSON-LD.\n# 2. For each object in \"hasPart\" where \"@type\" == \"Clip\":\n#    a. Verify presence of \"name\", \"startOffset\", \"url\".\n# 3. If any required field missing -> fail.\n"
    },
    "pass_condition": "All Clip objects contain name, startOffset, and url.",
    "fail_messages": ["Clip missing required property: ${missing_property}"],
    "references": [
      {
        "doc_title": "Video (VideoObject, Clip, BroadcastEvent) Schema Markup",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/video",
        "section_title": "Clip",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video", "clip"],
    "insufficient_evidence": false
  },
  {
    "id": "SEEKTOACTION_REQUIRED_PROPERTIES",
    "title": "SeekToAction must include required properties",
    "category": "SeekToAction",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "potentialAction, startOffset-input, and target are required for SeekToAction to enable automatic key moments.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing the VideoObject with SeekToAction markup."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Locate object where potentialAction.@type == 'SeekToAction'."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse VideoObject JSON-LD.\n# 2. If \"potentialAction\" exists and its \"@type\" == \"SeekToAction\":\n#    a. Verify presence of \"target\" and \"startOffset-input\".\n# 3. If any required field missing -> fail.\n"
    },
    "pass_condition": "SeekToAction object includes target and startOffset-input.",
    "fail_messages": [
      "SeekToAction missing required property: ${missing_property}"
    ],
    "references": [
      {
        "doc_title": "Video (VideoObject, Clip, BroadcastEvent) Schema Markup",
        "url": "https://developers.google.com/search/docs/appearance/structured-data/video",
        "section_title": "SeekToAction",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video", "seektoaction"],
    "insufficient_evidence": false
  },
  {
    "id": "REL_AMPHTML_LINK_REMOVED",
    "title": "Remove rel=\"amphtml\" link from canonical page",
    "category": "Remove only AMP pages",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "The rel=\"amphtml\" link signals the AMP version; removing it prevents Google from associating the AMP page with the canonical page.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the canonical non-AMP page"
      }
    ],
    "preconditions": [
      "Removing only AMP pages while preserving the canonical non-AMP page"
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='amphtml']",
        "attribute": null,
        "notes": "Presence of a link element with rel=\"amphtml\""
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Search for any <link> element where rel attribute equals \"amphtml\".\n# 3. If such an element exists, set result = fail; else result = pass.\n"
    },
    "pass_condition": "No <link rel=\"amphtml\"> element is present in the HTML.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Found rel=\"amphtml\" link in canonical page."],
    "references": [
      {
        "doc_title": "How To Remove your AMP Pages From Search",
        "url": "https://developers.google.com/search/docs/advanced/amp/remove-amp",
        "section_title": "Remove only AMP pages, while preserving the canonical non-AMP pages",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["AMP", "canonical", "link"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Canonical page without rel=amphtml",
        "snippet": "<html><head></head><body>Content</body></html>"
      },
      "failing": {
        "description": "Canonical page contains rel=amphtml",
        "snippet": "<html><head><link rel=\"amphtml\" href=\"/amp/page.html\"></head><body>Content</body></html>"
      }
    },
    "test_cases": [
      {
        "name": "canonical_without_amphtml",
        "input_stub": {
          "html": "<html><head></head><body>Content</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "canonical_with_amphtml",
        "input_stub": {
          "html": "<html><head><link rel=\"amphtml\" href=\"/amp/page.html\"></head><body>Content</body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_PAGE_HTTP_REDIRECT",
    "title": "Return HTTP 301 or 302 for removed AMP page",
    "category": "Remove only AMP pages",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "resource",
    "rationale": "A 301 or 302 redirect guides browsers and Google to the canonical non-AMP page after the AMP page is removed.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the removed AMP page request"
      }
    ],
    "preconditions": [
      "Removing only AMP pages while preserving the canonical non-AMP page"
    ],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "status_code",
        "attribute": null,
        "notes": "HTTP status code returned for the AMP URL"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Retrieve the value of the \"status_code\" header.\n# 2. If status_code is 301 or 302, set result = pass.\n# 3. Otherwise, set result = fail.\n"
    },
    "pass_condition": "HTTP status code is 301 or 302.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "AMP page returned status ${observed} instead of 301 or 302."
    ],
    "references": [
      {
        "doc_title": "How To Remove your AMP Pages From Search",
        "url": "https://developers.google.com/search/docs/advanced/amp/remove-amp",
        "section_title": "Remove only AMP pages, while preserving the canonical non-AMP pages",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["AMP", "http_status", "redirect"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "AMP URL returns a 301 redirect to the canonical page",
        "snippet": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/page.html"
      },
      "failing": {
        "description": "AMP URL returns a 200 OK instead of a redirect",
        "snippet": "HTTP/1.1 200 OK\nContent-Type: text/html"
      }
    },
    "test_cases": [
      {
        "name": "amp_redirect_301",
        "input_stub": {
          "html": null,
          "http_headers": {
            "status_code": 301
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/amp/page.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "amp_no_redirect",
        "input_stub": {
          "html": null,
          "http_headers": {
            "status_code": 200
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/amp/page.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_PAGE_HTTP_NOT_FOUND",
    "title": "Return HTTP 404 for removed AMP page when also removing from non-Google platforms",
    "category": "Remove only AMP pages",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "A 404 response ensures that the AMP cache and other platforms do not serve stale content for the removed AMP page.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers for the removed AMP page request"
      }
    ],
    "preconditions": [
      "Removing only AMP pages and also removing from non-Google platforms"
    ],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "status_code",
        "attribute": null,
        "notes": "HTTP status code returned for the AMP URL"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Retrieve the \"status_code\" header value.\n# 2. If status_code equals 404, set result = pass.\n# 3. Otherwise, set result = fail.\n"
    },
    "pass_condition": "HTTP status code is 404.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["AMP page returned status ${observed} instead of 404."],
    "references": [
      {
        "doc_title": "How To Remove your AMP Pages From Search",
        "url": "https://developers.google.com/search/docs/advanced/amp/remove-amp",
        "section_title": "Remove only AMP pages, while preserving the canonical non-AMP pages",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["AMP", "http_status", "not_found"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "AMP URL returns a 404 Not Found",
        "snippet": "HTTP/1.1 404 Not Found\nContent-Type: text/html"
      },
      "failing": {
        "description": "AMP URL returns a 301 redirect instead of 404",
        "snippet": "HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/page.html"
      }
    },
    "test_cases": [
      {
        "name": "amp_not_found",
        "input_stub": {
          "html": null,
          "http_headers": {
            "status_code": 404
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/amp/page.html"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "amp_redirect_instead_of_404",
        "input_stub": {
          "html": null,
          "http_headers": {
            "status_code": 301
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": "https://example.com/amp/page.html"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_CANONICAL_LINK_PRESENT",
    "title": "AMP page includes a canonical link",
    "category": "Create a basic AMP page",
    "requirement": "MUST",
    "severity": "high",
    "scope": "page",
    "rationale": "Google Search requires that an AMP page links to a canonical page for crawling and indexing.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the AMP page."
      }
    ],
    "preconditions": ["HTML contains attribute 'amp' on the <html> tag"],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=canonical]",
        "attribute": "href",
        "notes": "Canonical URL referenced by the AMP page"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Search for a <link> element where rel=\"canonical\".\n# 3. If such an element exists, extract its href attribute.\n# 4. If href is non\u2011empty, result = pass; else result = fail.\n"
    },
    "pass_condition": "A <link rel=\"canonical\"> element with a non\u2011empty href attribute is present.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing or empty canonical link on AMP page."],
    "references": [
      {
        "doc_title": "Enhance AMP content for Google Search",
        "url": "https://developers.google.com/search/docs/amp",
        "section_title": "Create a basic AMP page",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["AMP", "canonical", "SEO"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "AMP page with a proper canonical link.",
        "snippet": "<html amp>\n  <head>\n    <link rel=\"canonical\" href=\"https://example.com/article\">\n  </head>\n</html>\n"
      },
      "failing": {
        "description": "AMP page missing a canonical link.",
        "snippet": "<html amp>\n  <head>\n    <!-- No canonical link -->\n  </head>\n</html>\n"
      }
    },
    "test_cases": [
      {
        "name": "AMP page with canonical link",
        "input_stub": {
          "html": "<html amp><head><link rel=\"canonical\" href=\"https://example.com/article\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "AMP page without canonical link",
        "input_stub": {
          "html": "<html amp><head></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_ROBOTS_TXT_NOT_BLOCKED",
    "title": "Robots.txt does not block AMP page",
    "category": "Apply common content best practices",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "site",
    "rationale": "Blocking AMP pages via robots.txt prevents Google from crawling and indexing them.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file."
      },
      {
        "name": "url",
        "required": true,
        "description": "Full URL of the AMP page to evaluate."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "Disallow:\\s*(.*)",
        "attribute": null,
        "notes": "Extract Disallow paths to compare with AMP page path."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: robots_txt, url\n# 1. Parse the URL to obtain its path component (amp_path).\n# 2. For each line in robots_txt that matches /^Disallow:\\s*(.*)$/:\n#    a. Trim the captured pattern (rule_path).\n#    b. If amp_path starts with rule_path, set blocked = true.\n# 3. If blocked is true, result = fail; else result = pass.\n"
    },
    "pass_condition": "No Disallow rule in robots.txt matches the AMP page path.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "AMP page path ${amp_path} is blocked by robots.txt rule ${rule_path}."
    ],
    "references": [
      {
        "doc_title": "Enhance AMP content for Google Search",
        "url": "https://developers.google.com/search/docs/amp",
        "section_title": "Apply common content best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots.txt", "AMP", "crawling"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt does not contain a Disallow rule for the AMP path.",
        "snippet": "User-agent: *\nAllow: /\n"
      },
      "failing": {
        "description": "robots.txt blocks the AMP page path.",
        "snippet": "User-agent: *\nDisallow: /myarticle/amp\n"
      }
    },
    "test_cases": [
      {
        "name": "AMP page not blocked",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nAllow: /",
          "sitemap_xml": null,
          "url": "https://example.com/myarticle/amp"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "AMP page blocked by robots.txt",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow: /myarticle/amp",
          "sitemap_xml": null,
          "url": "https://example.com/myarticle/amp"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_STRUCTURED_DATA_CONSISTENT",
    "title": "Structured data markup present and consistent on AMP and canonical pages",
    "category": "Optimize for rich results",
    "requirement": "SHOULD",
    "severity": "medium",
    "scope": "page",
    "rationale": "Using identical structured data on both AMP and canonical pages enables rich results.",
    "input_fields": [
      {
        "name": "html_amp",
        "required": true,
        "description": "HTML content of the AMP page."
      },
      {
        "name": "html_canonical",
        "required": true,
        "description": "HTML content of the canonical (non\u2011AMP) page."
      }
    ],
    "preconditions": [
      "AMP page includes a <link rel=\"canonical\"> pointing to the canonical page."
    ],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Extract JSON\u2011LD blocks from each page."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html_amp, html_canonical\n# 1. Parse html_amp and extract all <script type=\"application/ld+json\"> contents into list amp_sd.\n# 2. Parse html_canonical and extract all <script type=\"application/ld+json\"> contents into list can_sd.\n# 3. If either list is empty, result = fail.\n# 4. Normalize each JSON string (remove whitespace, sort keys).\n# 5. Compare the two normalized lists for exact equality.\n# 6. If equal, result = pass; else result = fail.\n"
    },
    "pass_condition": "Both AMP and canonical pages contain identical JSON\u2011LD structured data markup.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Structured data markup differs between AMP and canonical pages."
    ],
    "references": [
      {
        "doc_title": "Enhance AMP content for Google Search",
        "url": "https://developers.google.com/search/docs/amp",
        "section_title": "Optimize for rich results",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured data", "AMP", "rich results"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Identical JSON\u2011LD on both pages.",
        "snippet": "<!-- AMP page -->\n<script type=\"application/ld+json\">\n{ \"@type\": \"Article\", \"headline\": \"Example\" }\n</script>\n<!-- Canonical page -->\n<script type=\"application/ld+json\">\n{ \"@type\": \"Article\", \"headline\": \"Example\" }\n</script>\n"
      },
      "failing": {
        "description": "Different structured data between pages.",
        "snippet": "<!-- AMP page -->\n<script type=\"application/ld+json\">\n{ \"@type\": \"Article\", \"headline\": \"AMP Version\" }\n</script>\n<!-- Canonical page -->\n<script type=\"application/ld+json\">\n{ \"@type\": \"Article\", \"headline\": \"Canonical Version\" }\n</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Consistent structured data",
        "input_stub": {
          "html_amp": "<html amp><head><script type='application/ld+json'>{\"@type\":\"Article\",\"headline\":\"Example\"}</script></head></html>",
          "html_canonical": "<html><head><script type='application/ld+json'>{\"@type\":\"Article\",\"headline\":\"Example\"}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Inconsistent structured data",
        "input_stub": {
          "html_amp": "<html amp><head><script type='application/ld+json'>{\"@type\":\"Article\",\"headline\":\"AMP Version\"}</script></head></html>",
          "html_canonical": "<html><head><script type='application/ld+json'>{\"@type\":\"Article\",\"headline\":\"Canonical Version\"}</script></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_DISCOVERABILITY_REL_AMPHTML_CANONICAL",
    "title": "Presence of rel=\"amphtml\" link on canonical page",
    "category": "Fix common AMP errors",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Ensures Google can discover the AMP version from the canonical page.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the canonical page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"amphtml\"]",
        "attribute": "href",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Search for a <link> element where rel attribute equals \"amphtml\".\n# 3. If such an element exists, set observed = true; else observed = false.\n"
    },
    "pass_condition": "The page contains a <link rel=\"amphtml\"> element.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing rel=\"amphtml\" link on canonical page."],
    "references": [
      {
        "doc_title": "Validate AMP Pages",
        "url": "https://developers.google.com/search/docs/guides/enhance-amp",
        "section_title": "Fix common AMP errors",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["discoverability", "amp"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page includes the required link.",
        "snippet": "<link rel=\"amphtml\" href=\"https://example.com/amp.html\">"
      },
      "failing": {
        "description": "Page lacks the required link.",
        "snippet": "<!-- no amphtml link -->"
      }
    },
    "test_cases": [
      {
        "name": "Canonical page with amphtml link",
        "input_stub": {
          "html": "<html><head><link rel=\"amphtml\" href=\"https://example.com/amp.html\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Canonical page missing amphtml link",
        "input_stub": {
          "html": "<html><head></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_DISCOVERABILITY_REL_AMPHTML_NONAMP",
    "title": "Presence of rel=\"amphtml\" link on non-AMP pages",
    "category": "Fix common AMP errors",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Allows Google to find the AMP version from alternative (e.g., mobile) pages.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of a non-AMP page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"amphtml\"]",
        "attribute": "href",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Look for a <link> element with rel=\"amphtml\".\n# 3. Set observed = true if found, else false.\n"
    },
    "pass_condition": "The non-AMP page contains a <link rel=\"amphtml\"> element.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing rel=\"amphtml\" link on non-AMP page."],
    "references": [
      {
        "doc_title": "Validate AMP Pages",
        "url": "https://developers.google.com/search/docs/guides/enhance-amp",
        "section_title": "Fix common AMP errors",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["discoverability", "amp"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Non-AMP page includes the required link.",
        "snippet": "<link rel=\"amphtml\" href=\"https://example.com/amp.html\">"
      },
      "failing": {
        "description": "Non-AMP page lacks the required link.",
        "snippet": "<!-- no amphtml link -->"
      }
    },
    "test_cases": [
      {
        "name": "Non-AMP page with amphtml link",
        "input_stub": {
          "html": "<html><head><link rel=\"amphtml\" href=\"https://example.com/amp.html\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Non-AMP page missing amphtml link",
        "input_stub": {
          "html": "<html><head></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_DISCOVERABILITY_REL_CANONICAL_ON_AMP",
    "title": "Presence of rel=\"canonical\" link on AMP page",
    "category": "Fix common AMP errors",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Provides the canonical URL for the AMP page, helping Google associate the AMP version with its source.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the AMP page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel=\"canonical\"]",
        "attribute": "href",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Search for a <link> element where rel=\"canonical\".\n# 3. observed = true if found, else false.\n"
    },
    "pass_condition": "The AMP page contains a <link rel=\"canonical\"> element.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing rel=\"canonical\" link on AMP page."],
    "references": [
      {
        "doc_title": "Validate AMP Pages",
        "url": "https://developers.google.com/search/docs/guides/enhance-amp",
        "section_title": "Fix common AMP errors",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["discoverability", "amp"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "AMP page includes a canonical link.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/article.html\">"
      },
      "failing": {
        "description": "AMP page lacks a canonical link.",
        "snippet": "<!-- no canonical link -->"
      }
    },
    "test_cases": [
      {
        "name": "AMP page with canonical link",
        "input_stub": {
          "html": "<html><head><link rel=\"canonical\" href=\"https://example.com/article.html\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "AMP page missing canonical link",
        "input_stub": {
          "html": "<html><head></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_ROBOTS_TXT_ALLOW_GOOGLEBOT",
    "title": "robots.txt allows Googlebot to crawl canonical and AMP pages",
    "category": "Fix common AMP errors",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "site",
    "rationale": "Prevents accidental blocking of Googlebot from accessing AMP resources.",
    "input_fields": [
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "User-agent:\\s*Googlebot[\\s\\S]*?Disallow:\\s*(.+)",
        "attribute": null,
        "notes": "Capture any Disallow paths for Googlebot"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: robots_txt\n# 1. Locate the section for User-agent: Googlebot.\n# 2. Extract all Disallow paths under that section.\n# 3. If any Disallow path matches the canonical or AMP URL patterns, observed = false; else observed = true.\n"
    },
    "pass_condition": "No Disallow rules block the canonical or AMP URLs for Googlebot.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "robots.txt blocks Googlebot from crawling the AMP or canonical pages."
    ],
    "references": [
      {
        "doc_title": "Validate AMP Pages",
        "url": "https://developers.google.com/search/docs/guides/enhance-amp",
        "section_title": "Fix common AMP errors",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "crawlability"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "robots.txt does not disallow Googlebot for the relevant paths.",
        "snippet": "User-agent: *\nDisallow:\nUser-agent: Googlebot\nDisallow:\n"
      },
      "failing": {
        "description": "robots.txt disallows Googlebot from the /amp/ directory.",
        "snippet": "User-agent: Googlebot\nDisallow: /amp/\n"
      }
    },
    "test_cases": [
      {
        "name": "robots.txt allows Googlebot",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: *\nDisallow:\nUser-agent: Googlebot\nDisallow:",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "robots.txt blocks Googlebot",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": "User-agent: Googlebot\nDisallow: /amp/",
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_REMOVE_ROBOTS_META_TAGS",
    "title": "Absence of robots meta tags on canonical and AMP pages",
    "category": "Fix common AMP errors",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Robots meta tags can unintentionally prevent indexing of AMP content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page (canonical or AMP)"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name=\"robots\"]",
        "attribute": "content",
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# 1. Parse the HTML document.\n# 2. Search for any <meta name=\"robots\"> elements.\n# 3. If any are found, observed = false; else observed = true.\n"
    },
    "pass_condition": "No <meta name=\"robots\"> tags are present in the page.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page contains a robots meta tag which may block indexing."
    ],
    "references": [
      {
        "doc_title": "Validate AMP Pages",
        "url": "https://developers.google.com/search/docs/guides/enhance-amp",
        "section_title": "Fix common AMP errors",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "indexing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page without robots meta tag.",
        "snippet": "<head><title>Example</title></head>"
      },
      "failing": {
        "description": "Page includes a robots meta tag.",
        "snippet": "<meta name=\"robots\" content=\"noindex\">"
      }
    },
    "test_cases": [
      {
        "name": "Page without robots meta tag",
        "input_stub": {
          "html": "<html><head><title>Test</title></head><body></body></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Page with robots meta tag",
        "input_stub": {
          "html": "<html><head><meta name=\"robots\" content=\"noindex\"></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AMP_REMOVE_X_ROBOTS_TAG_HEADER",
    "title": "Absence of X-Robots-Tag HTTP header on canonical and AMP pages",
    "category": "Fix common AMP errors",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "resource",
    "rationale": "X-Robots-Tag headers can block Googlebot from indexing the content.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "header",
        "selector": "X-Robots-Tag",
        "attribute": null,
        "notes": null
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: http_headers\n# 1. Check if the \"X-Robots-Tag\" header exists.\n# 2. If it exists, observed = false; else observed = true.\n"
    },
    "pass_condition": "No X-Robots-Tag header is present in the HTTP response.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Response includes X-Robots-Tag header which may block indexing."
    ],
    "references": [
      {
        "doc_title": "Validate AMP Pages",
        "url": "https://developers.google.com/search/docs/guides/enhance-amp",
        "section_title": "Fix common AMP errors",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "indexing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No X-Robots-Tag header returned.",
        "snippet": "Headers: {\"Content-Type\": \"text/html\"}"
      },
      "failing": {
        "description": "X-Robots-Tag header present.",
        "snippet": "Headers: {\"X-Robots-Tag\": \"noindex\"}"
      }
    },
    "test_cases": [
      {
        "name": "No X-Robots-Tag header",
        "input_stub": {
          "html": null,
          "http_headers": {
            "Content-Type": "text/html"
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "X-Robots-Tag header present",
        "input_stub": {
          "html": null,
          "http_headers": {
            "Content-Type": "text/html",
            "X-Robots-Tag": "noindex"
          },
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "ROBOTS_META_TAG_CONSISTENCY",
    "title": "Ensure robots meta tags are identical on mobile and desktop pages",
    "category": "Make sure that Google can access and render your content",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Identical robots meta tags prevent Google from misinterpreting indexing directives on mobile versus desktop versions.",
    "input_fields": [
      {
        "name": "mobile_html",
        "required": true,
        "description": "HTML source of the mobile version of the page"
      },
      {
        "name": "desktop_html",
        "required": true,
        "description": "HTML source of the desktop version of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Extract the content attribute of the robots meta tag"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse mobile_html and desktop_html as DOM trees.\n# 2. Extract mobile_robots = content attribute of meta[name='robots'] in mobile DOM; if not present, set to null.\n# 3. Extract desktop_robots = content attribute of meta[name='robots'] in desktop DOM; if not present, set to null.\n# 4. If both mobile_robots and desktop_robots are null, pass (no robots meta tag on either).\n# 5. Compare mobile_robots and desktop_robots for string equality.\n# 6. If equal, pass; else fail.\n"
    },
    "pass_condition": "Robots meta tag content is identical (or both absent) on mobile and desktop pages.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Robots meta tag differs between mobile (${mobile_robots}) and desktop (${desktop_robots})"
    ],
    "references": [
      {
        "doc_title": "Mobile site and mobile-first indexing best practices",
        "url": "https://developers.google.com/search/docs/crawling-indexing/mobile-first-indexing",
        "section_title": "Make sure that Google can access and render your content",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["robots", "meta", "indexing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both versions contain `<meta name=\"robots\" content=\"index,follow\">`",
        "snippet": "<!-- Mobile -->\n<meta name=\"robots\" content=\"index,follow\">\n<!-- Desktop -->\n<meta name=\"robots\" content=\"index,follow\">\n"
      },
      "failing": {
        "description": "Mobile version blocks indexing while desktop allows it",
        "snippet": "<!-- Mobile -->\n<meta name=\"robots\" content=\"noindex\">\n<!-- Desktop -->\n<meta name=\"robots\" content=\"index,follow\">\n"
      }
    },
    "test_cases": [
      {
        "name": "identical_robots_meta",
        "input_stub": {
          "mobile_html": "<html><head><meta name='robots' content='index,follow'></head></html>",
          "desktop_html": "<html><head><meta name='robots' content='index,follow'></head></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "different_robots_meta",
        "input_stub": {
          "mobile_html": "<html><head><meta name='robots' content='noindex'></head></html>",
          "desktop_html": "<html><head><meta name='robots' content='index,follow'></head></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CONTENT_EQUIVALENCE",
    "title": "Verify primary content is equivalent between mobile and desktop pages",
    "category": "Make sure that content is the same on desktop and mobile",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Equivalent primary content ensures both versions can rank for the same keywords.",
    "input_fields": [
      {
        "name": "mobile_html",
        "required": true,
        "description": "HTML source of the mobile version of the page"
      },
      {
        "name": "desktop_html",
        "required": true,
        "description": "HTML source of the desktop version of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "body",
        "attribute": null,
        "notes": "Extract all visible text within the body element"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse both HTML inputs into DOM trees.\n# 2. Extract mobile_text = concatenated visible text inside <body> of mobile DOM.\n# 3. Extract desktop_text = concatenated visible text inside <body> of desktop DOM.\n# 4. Normalize both strings: trim whitespace, collapse multiple spaces, convert to lowercase.\n# 5. If mobile_text == desktop_text, pass; else fail.\n"
    },
    "pass_condition": "Normalized body text is identical between mobile and desktop pages.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Primary content differs between mobile and desktop pages."
    ],
    "references": [
      {
        "doc_title": "Mobile site and mobile-first indexing best practices",
        "url": "https://developers.google.com/search/docs/crawling-indexing/mobile-first-indexing",
        "section_title": "Make sure that content is the same on desktop and mobile",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["content", "equivalence"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both versions contain the same article text.",
        "snippet": "<!-- Mobile -->\n<body><h1>Title</h1><p>Same content here.</p></body>\n<!-- Desktop -->\n<body><h1>Title</h1><p>Same content here.</p></body>\n"
      },
      "failing": {
        "description": "Mobile version omits a paragraph present on desktop.",
        "snippet": "<!-- Mobile -->\n<body><h1>Title</h1><p>Content here.</p></body>\n<!-- Desktop -->\n<body><h1>Title</h1><p>Content here.</p><p>Additional paragraph.</p></body>\n"
      }
    },
    "test_cases": [
      {
        "name": "identical_content",
        "input_stub": {
          "mobile_html": "<html><body><h1>Welcome</h1><p>Hello world.</p></body></html>",
          "desktop_html": "<html><body><h1>Welcome</h1><p>Hello world.</p></body></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "different_content",
        "input_stub": {
          "mobile_html": "<html><body><h1>Welcome</h1><p>Hello world.</p></body></html>",
          "desktop_html": "<html><body><h1>Welcome</h1><p>Hello world.</p><p>Extra.</p></body></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "STRUCTURED_DATA_EQUIVALENCE",
    "title": "Ensure structured data is present and identical on mobile and desktop pages",
    "category": "Check your structured data",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Consistent structured data enables Google to extract the same entities from both versions.",
    "input_fields": [
      {
        "name": "mobile_html",
        "required": true,
        "description": "HTML source of the mobile version of the page"
      },
      {
        "name": "desktop_html",
        "required": true,
        "description": "HTML source of the desktop version of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Collect the JSON-LD content of each script tag"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse both HTML inputs.\n# 2. Extract all JSON-LD strings from <script type=\"application/ld+json\"> in mobile and desktop DOMs.\n# 3. Parse each JSON string into an object; collect a set of canonical representations (e.g., sorted key/value pairs).\n# 4. Compare the two sets for equality.\n# 5. If sets are equal, pass; else fail.\n"
    },
    "pass_condition": "The set of structured data objects (JSON-LD) is identical between mobile and desktop pages.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Structured data differs between mobile and desktop versions."
    ],
    "references": [
      {
        "doc_title": "Mobile site and mobile-first indexing best practices",
        "url": "https://developers.google.com/search/docs/crawling-indexing/mobile-first-indexing",
        "section_title": "Check your structured data",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "json-ld"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both versions include identical Breadcrumb and Product JSON-LD.",
        "snippet": "<script type=\"application/ld+json\">\n{\"@type\":\"Breadcrumb\",\"itemListElement\":[...]}\n</script>\n"
      },
      "failing": {
        "description": "Mobile version missing Product structured data.",
        "snippet": "<!-- Desktop includes Product JSON-LD, mobile does not -->\n"
      }
    },
    "test_cases": [
      {
        "name": "identical_structured_data",
        "input_stub": {
          "mobile_html": "<script type='application/ld+json'>{\"@type\":\"Breadcrumb\"}</script>",
          "desktop_html": "<script type='application/ld+json'>{\"@type\":\"Breadcrumb\"}</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_structured_data",
        "input_stub": {
          "mobile_html": "<script type='application/ld+json'>{\"@type\":\"Breadcrumb\"}</script>",
          "desktop_html": "<script type='application/ld+json'>{\"@type\":\"Breadcrumb\"}</script><script type='application/ld+json'>{\"@type\":\"Product\"}</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMAGE_ALT_TEXT_EQUIVALENCE",
    "title": "Verify that alt text for images is identical on mobile and desktop pages",
    "category": "Check your images",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Consistent alt text ensures accessibility and proper indexing of images across versions.",
    "input_fields": [
      {
        "name": "mobile_html",
        "required": true,
        "description": "HTML source of the mobile version of the page"
      },
      {
        "name": "desktop_html",
        "required": true,
        "description": "HTML source of the desktop version of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img",
        "attribute": "src",
        "notes": "Collect src attribute for each image"
      },
      {
        "type": "selector",
        "selector": "img",
        "attribute": "alt",
        "notes": "Collect alt attribute for each image"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# 1. Parse both HTML inputs.\n# 2. For each <img> in mobile DOM, map mobile_src -> mobile_alt.\n# 3. For each <img> in desktop DOM, map desktop_src -> desktop_alt.\n# 4. For every src present in both maps, compare alt texts for equality.\n# 5. If any mismatch or missing src in either version, fail; otherwise pass.\n"
    },
    "pass_condition": "All images present in both versions have identical alt attribute values.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Alt text mismatch for image src '${src}': mobile alt '${mobile_alt}' vs desktop alt '${desktop_alt}'.",
      "Image src '${src}' present in one version but missing in the other."
    ],
    "references": [
      {
        "doc_title": "Mobile site and mobile-first indexing best practices",
        "url": "https://developers.google.com/search/docs/crawling-indexing/mobile-first-indexing",
        "section_title": "Check your images",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["images", "alt-text"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Both versions have `<img src=\"logo.png\" alt=\"Company logo\">`.",
        "snippet": "<!-- Mobile -->\n<img src=\"logo.png\" alt=\"Company logo\">\n<!-- Desktop -->\n<img src=\"logo.png\" alt=\"Company logo\">\n"
      },
      "failing": {
        "description": "Mobile alt text differs from desktop.",
        "snippet": "<!-- Mobile -->\n<img src=\"logo.png\" alt=\"Logo\">\n<!-- Desktop -->\n<img src=\"logo.png\" alt=\"Company logo\">\n"
      }
    },
    "test_cases": [
      {
        "name": "matching_alt_text",
        "input_stub": {
          "mobile_html": "<img src='logo.png' alt='Company logo'>",
          "desktop_html": "<img src='logo.png' alt='Company logo'>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "mismatched_alt_text",
        "input_stub": {
          "mobile_html": "<img src='logo.png' alt='Logo'>",
          "desktop_html": "<img src='logo.png' alt='Company logo'>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "TITLE_UNIQUE",
    "title": "Page has a non-empty <title> element",
    "category": "Describe your page with unique titles and snippets",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Unique, descriptive <title> elements help users quickly identify the best result for their goal.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "title",
        "attribute": null,
        "notes": "Extract the text content of the <title> element"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into a DOM.\n# 2. Find the first <title> element.\n# 3. If not found, set observed = null.\n# 4. Else, set observed = trimmed text content of the element.\n"
    },
    "pass_condition": "Title element exists and its text is non\u2011empty.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing or empty <title> element."],
    "references": [
      {
        "doc_title": "Understand JavaScript SEO basics",
        "url": "https://developers.google.com/search/docs/understand-javascript-seo-basics",
        "section_title": "Describe your page with unique titles and snippets",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["title", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a proper title.",
        "snippet": "<html><head><title>Awesome Product \u2013 Example.com</title></head><body>\u2026</body></html>"
      },
      "failing": {
        "description": "Page missing a title element.",
        "snippet": "<html><head></head><body>\u2026</body></html>"
      }
    },
    "test_cases": [
      {
        "name": "Title present and non\u2011empty",
        "input_stub": {
          "html": "<html><head><title>My Page</title></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Title missing",
        "input_stub": {
          "html": "<html><head></head></html>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "META_DESCRIPTION_PRESENT",
    "title": "Page includes a meta description tag",
    "category": "Describe your page with unique titles and snippets",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Meta descriptions help users decide whether a result matches their intent.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "meta[name='description']",
        "attribute": "content",
        "notes": "Retrieve the content attribute of the meta description tag"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into a DOM.\n# 2. Locate <meta name=\"description\"> element.\n# 3. If not found, observed = null.\n# 4. Else, observed = trimmed value of its content attribute.\n"
    },
    "pass_condition": "Meta description tag exists and its content attribute is non\u2011empty.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing or empty meta description."],
    "references": [
      {
        "doc_title": "Understand JavaScript SEO basics",
        "url": "https://developers.google.com/search/docs/understand-javascript-seo-basics",
        "section_title": "Describe your page with unique titles and snippets",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["meta", "description"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains a meta description.",
        "snippet": "<meta name=\"description\" content=\"Buy the best widgets online.\">"
      },
      "failing": {
        "description": "No meta description present.",
        "snippet": "<head></head>"
      }
    },
    "test_cases": [
      {
        "name": "Meta description present",
        "input_stub": {
          "html": "<head><meta name=\"description\" content=\"Great product.\"></head>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Meta description missing",
        "input_stub": {
          "html": "<head></head>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CANONICAL_LINK_PRESENT",
    "title": "Page includes a rel=\"canonical\" link tag",
    "category": "Set the canonical URL",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "The canonical link tag helps Google identify the preferred version of a page.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "link[rel='canonical']",
        "attribute": "href",
        "notes": "Retrieve the href attribute of the canonical link tag"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into a DOM.\n# 2. Find <link rel=\"canonical\"> element.\n# 3. If not found, observed = null.\n# 4. Else, observed = trimmed href attribute.\n"
    },
    "pass_condition": "Canonical link tag exists and its href attribute is non\u2011empty.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Missing canonical link tag or empty href."],
    "references": [
      {
        "doc_title": "Understand JavaScript SEO basics",
        "url": "https://developers.google.com/search/docs/understand-javascript-seo-basics",
        "section_title": "Set the canonical URL",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["canonical", "seo"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Canonical tag present with a URL.",
        "snippet": "<link rel=\"canonical\" href=\"https://example.com/page.html\">"
      },
      "failing": {
        "description": "No canonical tag.",
        "snippet": "<head></head>"
      }
    },
    "test_cases": [
      {
        "name": "Canonical present",
        "input_stub": {
          "html": "<head><link rel=\"canonical\" href=\"https://example.com/\"></head>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Canonical missing",
        "input_stub": {
          "html": "<head></head>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AVOID_FRAGMENT_LINKS",
    "title": "Anchor links do not use URL fragments for navigation",
    "category": "Use the History API instead of fragments",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Google can only discover links that are real URLs; fragment\u2011only links are not crawlable.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href]",
        "attribute": "href",
        "notes": "Collect all href values from anchor elements"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into a DOM.\n# 2. For each <a> element with an href attribute, collect href.\n# 3. If any href starts with \"#\" (fragment only), set observed = true.\n# 4. Else observed = false.\n"
    },
    "pass_condition": "No anchor href attribute starts with a fragment identifier (\u201c#\u201d).",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": false,
      "unit": null,
      "notes": "true indicates a failure"
    },
    "fail_messages": [
      "Found anchor link(s) using fragment URLs (${observed_links})."
    ],
    "references": [
      {
        "doc_title": "Understand JavaScript SEO basics",
        "url": "https://developers.google.com/search/docs/understand-javascript-seo-basics",
        "section_title": "Use the History API instead of fragments",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["links", "history-api"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All links are proper URLs.",
        "snippet": "<a href=\"/products\">Products</a>"
      },
      "failing": {
        "description": "Link uses a fragment.",
        "snippet": "<a href=\"#/products\">Products</a>"
      }
    },
    "test_cases": [
      {
        "name": "No fragment links",
        "input_stub": {
          "html": "<nav><a href=\"/about\">About</a></nav>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Contains fragment link",
        "input_stub": {
          "html": "<nav><a href=\"#/about\">About</a></nav>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "HTTP_STATUS_OK",
    "title": "Page returns HTTP 200 status for rendering",
    "category": "Use meaningful HTTP status codes",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Google queues pages with a 200 status for rendering unless blocked by robots directives.",
    "input_fields": [
      {
        "name": "http_status",
        "required": true,
        "description": "HTTP status code returned for the page request"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": null,
        "attribute": null,
        "notes": "Capture the numeric HTTP status code"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: http_status\n# 1. If http_status == 200, observed = true else observed = false.\n"
    },
    "pass_condition": "HTTP status code is 200.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 200,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Page returned HTTP status ${observed} instead of 200."],
    "references": [
      {
        "doc_title": "Understand JavaScript SEO basics",
        "url": "https://developers.google.com/search/docs/understand-javascript-seo-basics",
        "section_title": "Use meaningful HTTP status codes",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["http", "status"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Server responded with 200.",
        "snippet": "HTTP/1.1 200 OK"
      },
      "failing": {
        "description": "Server responded with 404.",
        "snippet": "HTTP/1.1 404 Not Found"
      }
    },
    "test_cases": [
      {
        "name": "Status 200",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null,
          "http_status": 200
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Status 404",
        "input_stub": {
          "html": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null,
          "http_status": 404
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "LONG_LIVED_CACHING",
    "title": "Static assets use fingerprinted filenames for long-lived caching",
    "category": "Use long-lived caching",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Fingerprinted filenames ensure updated resources are fetched when content changes, avoiding stale caching.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[src], link[rel='stylesheet'][href]",
        "attribute": "src",
        "notes": "Collect src/href URLs of JS and CSS assets"
      },
      {
        "type": "selector",
        "selector": "script[src], link[rel='stylesheet'][href]",
        "attribute": "href",
        "notes": "Collect href URLs of CSS assets"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into a DOM.\n# 2. For each <script src> and <link rel=\"stylesheet\" href>, extract the URL.\n# 3. Check if the filename contains a hash pattern (e.g., .[a-f0-9]{8,}.js or .[a-f0-9]{8,}.css).\n# 4. If any asset lacks such a pattern, observed = false else true.\n"
    },
    "pass_condition": "All JavaScript and CSS asset URLs contain a hash fingerprint in the filename.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": "false indicates missing fingerprint"
    },
    "fail_messages": ["Asset URL without fingerprint detected: ${asset_url}"],
    "references": [
      {
        "doc_title": "Understand JavaScript SEO basics",
        "url": "https://developers.google.com/search/docs/understand-javascript-seo-basics",
        "section_title": "Use long-lived caching",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["caching", "fingerprint"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Script uses fingerprinted filename.",
        "snippet": "<script src=\"/static/main.2bb85551.js\"></script>"
      },
      "failing": {
        "description": "Script without fingerprint.",
        "snippet": "<script src=\"/static/main.js\"></script>"
      }
    },
    "test_cases": [
      {
        "name": "Fingerprinted asset",
        "input_stub": {
          "html": "<script src=\"/static/app.abcdef12.js\"></script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Non\u2011fingerprinted asset",
        "input_stub": {
          "html": "<script src=\"/static/app.js\"></script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "STRUCTURED_DATA_PRESENT",
    "title": "Page includes JSON\u2011LD structured data script",
    "category": "Use structured data",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Structured data helps Google understand page content and enables rich results.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML content of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[type='application/ld+json']",
        "attribute": null,
        "notes": "Detect presence of JSON\u2011LD script blocks"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html into a DOM.\n# 2. Search for <script type=\"application/ld+json\"> elements.\n# 3. If at least one is found, observed = true else false.\n"
    },
    "pass_condition": "At least one JSON\u2011LD script tag is present.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "No JSON\u2011LD structured data script found on the page."
    ],
    "references": [
      {
        "doc_title": "Understand JavaScript SEO basics",
        "url": "https://developers.google.com/search/docs/understand-javascript-seo-basics",
        "section_title": "Use structured data",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["structured-data", "json-ld"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page contains JSON\u2011LD.",
        "snippet": "<script type=\"application/ld+json\">{ \"@type\": \"Article\" }</script>"
      },
      "failing": {
        "description": "No JSON\u2011LD present.",
        "snippet": "<head></head>"
      }
    },
    "test_cases": [
      {
        "name": "Structured data present",
        "input_stub": {
          "html": "<script type=\"application/ld+json\">{ \"@type\": \"Product\" }</script>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Structured data missing",
        "input_stub": {
          "html": "<head></head>",
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "sitemap_xml": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGINATION_UNIQUE_URLS",
    "title": "Each pagination chunk has a unique persistent URL",
    "category": "Infinite Scroll Pagination",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "site",
    "rationale": "Unique URLs allow search engines to index each chunk separately.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML of the page containing pagination links."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href*='?page=']",
        "attribute": "href",
        "notes": "Collect hrefs of pagination links containing ?page= parameter."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and extract all href attributes matching selector.\n# 2. Store each href in list urls.\n# 3. If any href is missing or duplicate, fail.\n# 4. Pass if all hrefs are present and unique.\n"
    },
    "pass_condition": "All pagination links contain a ?page= query parameter and each URL is unique.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Found duplicate or missing pagination URLs: ${observed}"
    ],
    "references": [
      {
        "doc_title": "Fix Lazy-Loaded Website Content",
        "url": "https://developers.google.com/search/docs/advanced/javascript/lazy-loading",
        "section_title": "Support paginated loading for infinite scroll",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["pagination", "infinite_scroll"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Two distinct pagination links with ?page=1 and ?page=2.",
        "snippet": "<a href=\"/articles?page=1\">1</a> <a href=\"/articles?page=2\">2</a>"
      },
      "failing": {
        "description": "Duplicate pagination links or missing ?page=.",
        "snippet": "<a href=\"/articles?page=1\">1</a> <a href=\"/articles?page=1\">1</a>"
      }
    },
    "test_cases": [
      {
        "name": "unique_urls_pass",
        "input_stub": {
          "html": "<a href=\"/list?page=1\"></a><a href=\"/list?page=2\"></a>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "duplicate_url_fail",
        "input_stub": {
          "html": "<a href=\"/list?page=1\"></a><a href=\"/list?page=1\"></a>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "PAGINATION_NO_RELATIVE_DATE_PARAM",
    "title": "Pagination URLs avoid relative date parameters",
    "category": "Infinite Scroll Pagination",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "site",
    "rationale": "Relative date parameters can cause content to change, hindering indexing.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "HTML containing pagination links."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href]",
        "attribute": "href",
        "notes": "Collect all hrefs from pagination area."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Extract all href attributes.\n# 2. For each href, if it contains \"?date=\" then fail.\n# 3. Pass if none contain \"?date=\".\n"
    },
    "pass_condition": "No pagination URL contains the \"?date=\" query parameter.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Pagination URL with relative date parameter found: ${observed}"
    ],
    "references": [
      {
        "doc_title": "Fix Lazy-Loaded Website Content",
        "url": "https://developers.google.com/search/docs/advanced/javascript/lazy-loading",
        "section_title": "Support paginated loading for infinite scroll",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["pagination", "infinite_scroll"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "URL uses ?page= parameter only.",
        "snippet": "<a href=\"/articles?page=3\">3</a>"
      },
      "failing": {
        "description": "URL uses ?date= parameter.",
        "snippet": "<a href=\"/articles?date=yesterday\">Yesterday</a>"
      }
    },
    "test_cases": [
      {
        "name": "no_date_param_pass",
        "input_stub": {
          "html": "<a href=\"/list?page=2\"></a>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "date_param_fail",
        "input_stub": {
          "html": "<a href=\"/list?date=yesterday\"></a>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "RENDERED_HTML_SRC_PRESENT",
    "title": "Image and video src attributes appear in rendered HTML",
    "category": "Testing",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Presence of src attributes in rendered HTML indicates Google can see lazy-loaded media.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Rendered HTML of the page as returned by URL Inspection Tool."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "img[src], video[src]",
        "attribute": "src",
        "notes": "Collect src attributes of img and video elements."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: html\n# 1. Parse html and find all <img> and <video> elements with a src attribute.\n# 2. If at least one src is found, pass.\n# 3. If none found, fail.\n"
    },
    "pass_condition": "At least one <img> or <video> element with a src attribute is present in the rendered HTML.",
    "threshold": {
      "type": "number",
      "operator": ">=",
      "value": 1,
      "unit": "count",
      "notes": null
    },
    "fail_messages": ["No img or video src attributes found in rendered HTML."],
    "references": [
      {
        "doc_title": "Fix Lazy-Loaded Website Content",
        "url": "https://developers.google.com/search/docs/advanced/javascript/lazy-loading",
        "section_title": "Test",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["testing", "lazy_loading"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Rendered HTML contains an img with src.",
        "snippet": "<img src=\"/images/pic.jpg\" />"
      },
      "failing": {
        "description": "Rendered HTML lacks img/video src.",
        "snippet": "<div>Content loaded via JS after render</div>"
      }
    },
    "test_cases": [
      {
        "name": "img_src_present_pass",
        "input_stub": {
          "html": "<img src=\"/a.jpg\"/>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "no_src_fail",
        "input_stub": {
          "html": "<div>No media</div>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SOFT_404_PREVENTION",
    "title": "Prevent soft 404 errors",
    "category": "Soft 404 Prevention",
    "requirement": "UNSPECIFIED",
    "severity": "high",
    "scope": "page",
    "rationale": "Error pages that return a 200 status can be indexed, causing soft 404 issues.",
    "input_fields": [
      {
        "name": "http_headers",
        "required": true,
        "description": "HTTP response headers including status code"
      },
      {
        "name": "html",
        "required": true,
        "description": "Rendered HTML of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "http_status",
        "selector": "status_code",
        "attribute": null,
        "notes": "HTTP response status code"
      },
      {
        "type": "selector",
        "selector": "meta[name='robots']",
        "attribute": "content",
        "notes": "Robots meta tag content"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: http_headers.status_code, html\n# Steps:\n1. Retrieve status_code from http_headers.\n2. Search html for <meta name=\"robots\"> tag and get its content attribute (if present).\n3. If status_code == 404, PASS.\n4. Else if meta_robots_content contains \"noindex\", PASS.\n5. Else FAIL.\n"
    },
    "pass_condition": "Page returns HTTP 404 status or includes a robots meta tag with noindex.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Page returned status ${observed_status} without a noindex meta tag."
    ],
    "references": [
      {
        "doc_title": "Fix Search-related JavaScript problems",
        "url": "https://developers.google.com/search/docs/advanced/javascript/fix-js-problems",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["soft-404", "indexing"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Page returns 404 status.",
        "snippet": "HTTP/1.1 404 Not Found\n"
      },
      "failing": {
        "description": "Page returns 200 and lacks noindex.",
        "snippet": "HTTP/1.1 200 OK\n"
      }
    },
    "test_cases": [
      {
        "name": "Soft404 with 404 status",
        "input_stub": {
          "http_headers": {
            "status_code": 404
          },
          "html": "<!doctype html><html></html>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Soft404 with 200 and noindex",
        "input_stub": {
          "http_headers": {
            "status_code": 200
          },
          "html": "<meta name=\"robots\" content=\"noindex\">"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Soft404 failing case",
        "input_stub": {
          "http_headers": {
            "status_code": 200
          },
          "html": "<!doctype html><html></html>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NO_URL_FRAGMENTS",
    "title": "Do not use URL fragments to load content",
    "category": "URL Fragments",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Googlebot does not process fragment\u2011based navigation, so content loaded via fragments may be invisible to search.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Rendered HTML of the page"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "a[href^='#']",
        "attribute": "href",
        "notes": "Links that point to a fragment"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# Steps:\n1. Find all <a> elements where href attribute starts with '#'.\n2. If any such elements exist, FAIL.\n3. Otherwise, PASS.\n"
    },
    "pass_condition": "No anchor elements link to fragment identifiers.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 0,
      "unit": null,
      "notes": "Count of fragment links must be zero"
    },
    "fail_messages": ["Found ${observed} anchor(s) linking to URL fragments."],
    "references": [
      {
        "doc_title": "Fix Search-related JavaScript problems",
        "url": "https://developers.google.com/search/docs/advanced/javascript/fix-js-problems",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["fragments", "navigation"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No fragment links present.",
        "snippet": "<a href=\"/about\">About</a>\n"
      },
      "failing": {
        "description": "Link uses a fragment.",
        "snippet": "<a href=\"#/products\">Products</a>\n"
      }
    },
    "test_cases": [
      {
        "name": "No fragments",
        "input_stub": {
          "html": "<a href=\"/home\">Home</a>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "With fragment link",
        "input_stub": {
          "html": "<a href=\"#/dashboard\">Dashboard</a>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AVOID_DATA_PERSISTENCE",
    "title": "Avoid reliance on client\u2011side data persistence",
    "category": "Data Persistence",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Googlebot\u2019s rendering service clears localStorage, sessionStorage, and cookies between page loads, so content dependent on them may be missing.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source including inline scripts"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "script",
        "attribute": null,
        "notes": "Search script content for localStorage, sessionStorage, or document.cookie"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# Steps:\n1. Extract all inline and external script contents (if accessible).\n2. Search each script for the strings \"localStorage\", \"sessionStorage\", or \"document.cookie\".\n3. If any match is found, FAIL.\n4. Otherwise, PASS.\n"
    },
    "pass_condition": "No usage of localStorage, sessionStorage, or document.cookie detected in page scripts.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 0,
      "unit": null,
      "notes": "Count of persistence API mentions must be zero"
    },
    "fail_messages": [
      "Detected usage of ${observed} which may be cleared by Googlebot."
    ],
    "references": [
      {
        "doc_title": "Fix Search-related JavaScript problems",
        "url": "https://developers.google.com/search/docs/advanced/javascript/fix-js-problems",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["storage", "persistence"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No persistence APIs used.",
        "snippet": "<script>console.log('hello');</script>\n"
      },
      "failing": {
        "description": "Script accesses localStorage.",
        "snippet": "<script>localStorage.setItem('key','value');</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "No persistence",
        "input_stub": {
          "html": "<script>console.log('test');</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Uses localStorage",
        "input_stub": {
          "html": "<script>localStorage.getItem('a');</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "CONTENT_FINGERPRINTING",
    "title": "Use content fingerprinting for cached assets",
    "category": "Caching",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "resource",
    "rationale": "Fingerprinted filenames ensure Googlebot fetches updated versions of JS/CSS instead of stale cached copies.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Rendered HTML containing script and link tags"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "selector",
        "selector": "script[src]",
        "attribute": "src",
        "notes": "Source URL of script files"
      },
      {
        "type": "selector",
        "selector": "link[rel='stylesheet'][href]",
        "attribute": "href",
        "notes": "Href of stylesheet files"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# Steps:\n1. Collect all src attributes from <script> tags and href attributes from <link rel=\"stylesheet\"> tags.\n2. For each URL, check if the filename matches the pattern: name.<hash>.<ext> where <hash> is at least 8 hexadecimal characters.\n3. If every asset URL matches the pattern, PASS.\n4. If any asset URL lacks a fingerprint, FAIL.\n"
    },
    "pass_condition": "All JavaScript and CSS asset URLs contain a fingerprint hash in the filename.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Asset ${observed} does not contain a fingerprint hash."],
    "references": [
      {
        "doc_title": "Fix Search-related JavaScript problems",
        "url": "https://developers.google.com/search/docs/advanced/javascript/fix-js-problems",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["fingerprinting", "caching"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Script filename includes hash.",
        "snippet": "<script src=\"/static/main.2bb85551.js\"></script>\n"
      },
      "failing": {
        "description": "Script filename without hash.",
        "snippet": "<script src=\"/static/main.js\"></script>\n"
      }
    },
    "test_cases": [
      {
        "name": "Fingerprinted assets",
        "input_stub": {
          "html": "<script src=\"/js/app.abcdef12.js\"></script><link rel=\"stylesheet\" href=\"/css/style.12345678.css\">"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Non\u2011fingerprinted asset",
        "input_stub": {
          "html": "<script src=\"/js/app.js\"></script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "AVOID_NON_HTTP_CONNECTIONS",
    "title": "Avoid non\u2011HTTP connections (WebSocket, WebRTC)",
    "category": "Connection Types",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "page",
    "rationale": "Googlebot only fetches resources over HTTP/HTTPS; WebSocket or WebRTC connections are ignored, causing missing content.",
    "input_fields": [
      {
        "name": "html",
        "required": true,
        "description": "Full HTML source including inline scripts"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "regex",
        "selector": "script",
        "attribute": null,
        "notes": "Search for usage of new WebSocket or RTCPeerConnection"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: html\n# Steps:\n1. Extract all script contents.\n2. Search for the patterns \"new WebSocket\" or \"new RTCPeerConnection\".\n3. If any pattern is found, FAIL.\n4. Otherwise, PASS.\n"
    },
    "pass_condition": "No WebSocket or WebRTC APIs are used in page scripts.",
    "threshold": {
      "type": "number",
      "operator": "==",
      "value": 0,
      "unit": null,
      "notes": "Count of prohibited API usages must be zero"
    },
    "fail_messages": ["Detected prohibited API usage: ${observed}."],
    "references": [
      {
        "doc_title": "Fix Search-related JavaScript problems",
        "url": "https://developers.google.com/search/docs/advanced/javascript/fix-js-problems",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["websocket", "webrtc"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "No prohibited APIs.",
        "snippet": "<script>fetch('/data.json');</script>\n"
      },
      "failing": {
        "description": "Uses WebSocket.",
        "snippet": "<script>const ws = new WebSocket('wss://example.com');</script>\n"
      }
    },
    "test_cases": [
      {
        "name": "No prohibited APIs",
        "input_stub": {
          "html": "<script>console.log('ok');</script>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Uses WebSocket",
        "input_stub": {
          "html": "<script>new WebSocket('wss://example.com');</script>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITEMAP_INDEX_SAME_SITE_HOSTING",
    "title": "Referenced sitemaps must be hosted on the same site as the index file",
    "category": "Sitemap Index Best Practices",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "Google requires that all sitemaps listed in a sitemap index be served from the same domain as the index file, unless cross\u2011site submission is explicitly configured.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the sitemap index file."
      },
      {
        "name": "index_url",
        "required": true,
        "description": "The full URL where the sitemap index file is hosted."
      },
      {
        "name": "cross_site_submission_enabled",
        "required": false,
        "description": "Boolean flag indicating whether cross\u2011site submission has been set up."
      }
    ],
    "preconditions": ["cross_site_submission_enabled != true"],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//sitemap/loc",
        "attribute": null,
        "notes": "Collect all <loc> URLs referenced in the index."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: sitemap_xml, index_url, cross_site_submission_enabled\n# 1. Parse sitemap_xml as XML.\n# 2. Extract domain of index_url (e.g., example.com).\n# 3. For each <loc> URL extracted via XPath \"//sitemap/loc\":\n#    a. Parse its domain.\n#    b. If domain != index domain, record as violation.\n# 4. If any violations recorded, result = fail else pass.\n"
    },
    "pass_condition": "All <loc> URLs share the same domain as the sitemap index file (or cross\u2011site submission is enabled).",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Referenced sitemap URL ${observed_url} is on a different domain than the index (${index_domain})."
    ],
    "references": [
      {
        "doc_title": "Manage Your Sitemaps With Sitemap Index Files",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/sitemap-index",
        "section_title": "Sitemap index best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["sitemap", "index", "same_site"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Index and all referenced sitemaps are on https://example.com.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap><loc>https://example.com/sitemap1.xml</loc></sitemap>\n  <sitemap><loc>https://example.com/blog/sitemap2.xml</loc></sitemap>\n</sitemapindex>\n"
      },
      "failing": {
        "description": "One referenced sitemap is on a different domain.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap><loc>https://example.com/sitemap1.xml</loc></sitemap>\n  <sitemap><loc>https://other.com/sitemap2.xml</loc></sitemap>\n</sitemapindex>\n"
      }
    },
    "test_cases": [
      {
        "name": "Same domain passes",
        "input_stub": {
          "sitemap_xml": "<?xml version='1.0'?><sitemapindex xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'><sitemap><loc>https://example.com/a.xml</loc></sitemap></sitemapindex>",
          "index_url": "https://example.com/sitemap_index.xml",
          "cross_site_submission_enabled": false
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Different domain fails",
        "input_stub": {
          "sitemap_xml": "<?xml version='1.0'?><sitemapindex xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'><sitemap><loc>https://other.com/b.xml</loc></sitemap></sitemapindex>",
          "index_url": "https://example.com/sitemap_index.xml",
          "cross_site_submission_enabled": false
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITEMAP_INDEX_SAME_OR_DEEPER_DIRECTORY",
    "title": "Referenced sitemaps must reside in the same or a deeper directory than the index file",
    "category": "Sitemap Index Best Practices",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "Google only accepts sitemap references that are located in the same directory hierarchy as the index file to prevent cross\u2011directory crawling issues.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the sitemap index file."
      },
      {
        "name": "index_url",
        "required": true,
        "description": "The full URL of the sitemap index file."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//sitemap/loc",
        "attribute": null,
        "notes": "Collect all <loc> URLs referenced in the index."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: sitemap_xml, index_url\n# 1. Parse sitemap_xml as XML.\n# 2. Extract the path component of index_url (e.g., /public/sitemap_index.xml) and remove the filename to get index_dir (e.g., /public/).\n# 3. For each <loc> URL via XPath \"//sitemap/loc\":\n#    a. Parse its path component.\n#    b. If the path does not start with index_dir, record as violation.\n# 4. If any violations recorded, result = fail else pass.\n"
    },
    "pass_condition": "Every <loc> URL path begins with the directory path of the sitemap index file.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Referenced sitemap URL ${observed_url} is outside the index directory hierarchy (${index_dir})."
    ],
    "references": [
      {
        "doc_title": "Manage Your Sitemaps With Sitemap Index Files",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/sitemap-index",
        "section_title": "Sitemap index best practices",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["sitemap", "index", "directory_hierarchy"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Index at /public/ references /public/shared/ and /public/ subpaths.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap><loc>https://example.com/public/sitemap1.xml</loc></sitemap>\n  <sitemap><loc>https://example.com/public/shared/sitemap2.xml</loc></sitemap>\n</sitemapindex>\n"
      },
      "failing": {
        "description": "Index at /public/ references a sitemap in /other/.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap><loc>https://example.com/other/sitemap3.xml</loc></sitemap>\n</sitemapindex>\n"
      }
    },
    "test_cases": [
      {
        "name": "Same or deeper directory passes",
        "input_stub": {
          "sitemap_xml": "<?xml version='1.0'?><sitemapindex xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'><sitemap><loc>https://example.com/public/a.xml</loc></sitemap><sitemap><loc>https://example.com/public/sub/b.xml</loc></sitemap></sitemapindex>",
          "index_url": "https://example.com/public/sitemap_index.xml"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Outside directory fails",
        "input_stub": {
          "sitemap_xml": "<?xml version='1.0'?><sitemapindex xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'><sitemap><loc>https://example.com/other/c.xml</loc></sitemap></sitemapindex>",
          "index_url": "https://example.com/public/sitemap_index.xml"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITEMAP_INDEX_REQUIRED_TAGS_PRESENT",
    "title": "Sitemap index file must contain required tags",
    "category": "Sitemap Index Reference",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Google can only process a sitemap index if it includes the mandatory XML elements defined by the Sitemap Protocol.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the sitemap index file."
      }
    ],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "/*[local-name()='sitemapindex']",
        "attribute": null,
        "notes": "Check for the root <sitemapindex> element."
      },
      {
        "type": "xpath",
        "selector": "//sitemap",
        "attribute": null,
        "notes": "Check for at least one <sitemap> element."
      },
      {
        "type": "xpath",
        "selector": "//sitemap/loc",
        "attribute": null,
        "notes": "Check that each <sitemap> contains a <loc> child."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: sitemap_xml\n# 1. Parse sitemap_xml as XML.\n# 2. Verify existence of a root element named 'sitemapindex'.\n# 3. Verify at least one 'sitemap' element exists.\n# 4. For each 'sitemap' element, verify it has a child element named 'loc'.\n# 5. If any of the above checks fail, result = fail else pass.\n"
    },
    "pass_condition": "The XML includes a <sitemapindex> root, at least one <sitemap>, and each <sitemap> contains a <loc> element.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required tag ${missing_tag} in the sitemap index."
    ],
    "references": [
      {
        "doc_title": "Manage Your Sitemaps With Sitemap Index Files",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/sitemap-index",
        "section_title": "Sitemap index reference",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["sitemap", "index", "required_tags"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Index contains required tags.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap><loc>https://example.com/s1.xml</loc></sitemap>\n</sitemapindex>\n"
      },
      "failing": {
        "description": "Index missing <loc> inside a <sitemap>.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap></sitemap>\n</sitemapindex>\n"
      }
    },
    "test_cases": [
      {
        "name": "All required tags present passes",
        "input_stub": {
          "sitemap_xml": "<?xml version='1.0'?><sitemapindex xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'><sitemap><loc>https://example.com/a.xml</loc></sitemap></sitemapindex>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing <loc> fails",
        "input_stub": {
          "sitemap_xml": "<?xml version='1.0'?><sitemapindex xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'><sitemap></sitemap></sitemapindex>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VIDEO_SITEMAP_REQUIRED_TAGS_PRESENT",
    "title": "Required video sitemap tags must be present",
    "category": "Video sitemap reference",
    "requirement": "MUST",
    "severity": "high",
    "scope": "site",
    "rationale": "Google can only use a video sitemap if each <video:video> entry contains all required tags.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the video sitemap."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url/video:video",
        "attribute": null,
        "notes": "Collect each <video:video> element."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml\nparse sitemap_xml as XML with namespace video=\"http://www.google.com/schemas/sitemap-video/1.1\"\nrequired_tags = [\"video:thumbnail_loc\",\"video:title\",\"video:description\",\"video:content_loc\",\"video:player_loc\"]\nfor each video_node in XML.xpath(\"//url/video:video\"):\n    missing = []\n    for tag in required_tags:\n        if not video_node.xpath(tag):\n            missing.append(tag)\n    if missing:\n        record_failure(video_node, missing)\nif any failures recorded:\n    outcome = fail\nelse:\n    outcome = pass\n"
    },
    "pass_condition": "Every <video:video> element contains all required tags.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required tags ${missing} in video entry at ${location}"
    ],
    "references": [
      {
        "doc_title": "Video sitemap reference",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/video-sitemaps",
        "section_title": "Required tags",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video_sitemap", "required_tags"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Video entry with all required tags.",
        "snippet": "<video:video>\n  <video:thumbnail_loc>...</video:thumbnail_loc>\n  <video:title>...</video:title>\n  <video:description>...</video:description>\n  <video:content_loc>...</video:content_loc>\n  <video:player_loc>...</video:player_loc>\n</video:video>\n"
      },
      "failing": {
        "description": "Video entry missing <video:content_loc>.",
        "snippet": "<video:video>\n  <video:thumbnail_loc>...</video:thumbnail_loc>\n  <video:title>...</video:title>\n  <video:description>...</video:description>\n  <video:player_loc>...</video:player_loc>\n</video:video>\n"
      }
    },
    "test_cases": [
      {
        "name": "all_required_tags_present",
        "input_stub": {
          "sitemap_xml": "<urlset>...</urlset>",
          "robots_txt": null,
          "http_headers": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_required_tag",
        "input_stub": {
          "sitemap_xml": "<urlset>...</urlset>",
          "robots_txt": null,
          "http_headers": null
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VIDEO_SITEMAP_URL_ACCESSIBLE",
    "title": "URLs referenced in video sitemap must be accessible to Googlebot",
    "category": "Video sitemap best practices",
    "requirement": "MUST",
    "severity": "critical",
    "scope": "site",
    "rationale": "Googlebot must be able to crawl video URLs; blocked or unsupported URLs prevent indexing.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the video sitemap."
      },
      {
        "name": "robots_txt",
        "required": true,
        "description": "Content of the site's robots.txt file."
      },
      {
        "name": "http_headers",
        "required": false,
        "description": "Mapping of URL to fetched HTTP response headers (including status code)."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url/loc",
        "attribute": null,
        "notes": "Collect landing page URLs."
      },
      {
        "type": "xpath",
        "selector": "//video:content_loc",
        "attribute": null,
        "notes": "Collect direct video file URLs."
      },
      {
        "type": "xpath",
        "selector": "//video:player_loc",
        "attribute": null,
        "notes": "Collect player page URLs."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml, robots_txt, http_headers\nparse sitemap_xml as XML with namespace video=\"http://www.google.com/schemas/sitemap-video/1.1\"\nurls = []\nurls += XML.xpath(\"//url/loc/text()\")\nurls += XML.xpath(\"//video:content_loc/text()\")\nurls += XML.xpath(\"//video:player_loc/text()\")\ndisallowed = parse_robots_txt(robots_txt)   # returns list of disallowed path patterns\nfor each url in urls:\n    # 1. Check protocol\n    if not url.startswith(\"http://\") and not url.startswith(\"https://\") and not url.startswith(\"ftp://\"):\n        record_failure(url, \"unsupported protocol\")\n        continue\n    # 2. Check robots.txt\n    path = extract_path(url)\n    if any(path matches pattern for pattern in disallowed):\n        record_failure(url, \"disallowed by robots.txt\")\n        continue\n    # 3. Check HTTP status if headers provided\n    if http_headers and url in http_headers:\n        status = http_headers[url].get(\"status\")\n        if status != 200:\n            record_failure(url, f\"HTTP status {status}\")\nif any failures recorded:\n    outcome = fail\nelse:\n    outcome = pass\n"
    },
    "pass_condition": "All extracted URLs use HTTP/HTTPS/FTP, are not blocked by robots.txt, and return HTTP 200 when headers are available.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["URL ${url} failed accessibility check: ${reason}"],
    "references": [
      {
        "doc_title": "Video sitemap best practices",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/video-sitemaps",
        "section_title": "Accessibility requirements",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video_sitemap", "accessibility"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All URLs are HTTP, allowed by robots.txt, and return 200.",
        "snippet": "<loc>https://example.com/page.html</loc>\n<video:content_loc>http://stream.example.com/video.mp4</video:content_loc>\n"
      },
      "failing": {
        "description": "A video URL is blocked by robots.txt.",
        "snippet": "<video:content_loc>http://stream.example.com/secret.mp4</video:content_loc>\n"
      }
    },
    "test_cases": [
      {
        "name": "all_urls_accessible",
        "input_stub": {
          "sitemap_xml": "<urlset>...</urlset>",
          "robots_txt": "User-agent: *\nDisallow:",
          "http_headers": {
            "https://example.com/page.html": {
              "status": 200
            },
            "http://stream.example.com/video.mp4": {
              "status": 200
            }
          }
        },
        "expected_outcome": "pass"
      },
      {
        "name": "url_disallowed_by_robots",
        "input_stub": {
          "sitemap_xml": "<urlset>...</urlset>",
          "robots_txt": "User-agent: *\nDisallow: /secret",
          "http_headers": {
            "http://stream.example.com/secret.mp4": {
              "status": 200
            }
          }
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "VIDEO_SITEMAP_NO_DUPLICATE_TAGS_PER_VIDEO",
    "title": "Each video tag may appear only once per <video:video> entry",
    "category": "Video sitemap reference",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "site",
    "rationale": "Duplicate tags can cause ambiguity and are not allowed by the specification.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the video sitemap."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//video:video",
        "attribute": null,
        "notes": "Iterate over each video entry."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml\nparse sitemap_xml as XML with namespace video=\"http://www.google.com/schemas/sitemap-video/1.1\"\nfor each video_node in XML.xpath(\"//video:video\"):\n    tag_counts = {}\n    for child in video_node.children:\n        tag_name = child.tag\n        tag_counts[tag_name] = tag_counts.get(tag_name,0) + 1\n    duplicates = [tag for tag,count in tag_counts.items() if count > 1]\n    if duplicates:\n        record_failure(video_node, duplicates)\nif any failures recorded:\n    outcome = fail\nelse:\n    outcome = pass\n"
    },
    "pass_condition": "No <video:video> element contains a tag more than once.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Duplicate tags ${duplicates} found in video entry at ${location}"
    ],
    "references": [
      {
        "doc_title": "Video sitemap reference",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/video-sitemaps",
        "section_title": "Tag uniqueness",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video_sitemap", "tag_uniqueness"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Each tag appears once.",
        "snippet": "<video:video>\n  <video:title>Example</video:title>\n  <video:description>Desc</video:description>\n</video:video>\n"
      },
      "failing": {
        "description": "Duplicate <video:title> tags.",
        "snippet": "<video:video>\n  <video:title>First</video:title>\n  <video:title>Second</video:title>\n</video:video>\n"
      }
    },
    "test_cases": [
      {
        "name": "no_duplicate_tags",
        "input_stub": {
          "sitemap_xml": "<urlset>...</urlset>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "duplicate_tags_present",
        "input_stub": {
          "sitemap_xml": "<urlset>...</urlset>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "MRSS_REQUIRED_TAGS_PRESENT",
    "title": "Required mRSS tags must be present",
    "category": "mRSS reference",
    "requirement": "MUST",
    "severity": "high",
    "scope": "site",
    "rationale": "Google can only use an mRSS feed if it contains all required media tags.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the mRSS feed."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//item",
        "attribute": null,
        "notes": "Collect each media item."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml\nparse sitemap_xml as XML with namespaces media=\"http://search.yahoo.com/mrss/\", dcterms=\"http://purl.org/dc/terms/\"\nrequired_tags = [\"media:content\",\"media:player\",\"media:title\",\"media:description\",\"media:thumbnail\"]\nfor each item in XML.xpath(\"//item\"):\n    missing = []\n    for tag in required_tags:\n        if not item.xpath(tag):\n            missing.append(tag)\n    if missing:\n        record_failure(item, missing)\nif any failures recorded:\n    outcome = fail\nelse:\n    outcome = pass\n"
    },
    "pass_condition": "Every <item> element contains all required media tags.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required mRSS tags ${missing} in item at ${location}"
    ],
    "references": [
      {
        "doc_title": "mRSS reference",
        "url": "http://www.rssboard.org/media-rss",
        "section_title": "Required tags",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["mrss", "required_tags"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Item with all required tags.",
        "snippet": "<item>\n  <media:content url=\"...\"/>\n  <media:player url=\"...\"/>\n  <media:title>...</media:title>\n  <media:description>...</media:description>\n  <media:thumbnail url=\"...\"/>\n</item>\n"
      },
      "failing": {
        "description": "Item missing <media:player>.",
        "snippet": "<item>\n  <media:content url=\"...\"/>\n  <media:title>...</media:title>\n  <media:description>...</media:description>\n  <media:thumbnail url=\"...\"/>\n</item>\n"
      }
    },
    "test_cases": [
      {
        "name": "all_mrss_required_tags_present",
        "input_stub": {
          "sitemap_xml": "<rss>...</rss>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "missing_mrss_required_tag",
        "input_stub": {
          "sitemap_xml": "<rss>...</rss>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "DEPRECATED_VIDEO_TAGS_ABSENT",
    "title": "Deprecated video sitemap tags and attributes must not be present",
    "category": "Video sitemap reference",
    "requirement": "MUST",
    "severity": "low",
    "scope": "site",
    "rationale": "Deprecated tags are no longer supported and may cause parsing errors.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the video sitemap."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//video:category | //video:gallery_loc | //video:price | //video:tvshow | //video:player_loc/@autoplay | //video:player_loc/@allow_embed",
        "attribute": null,
        "notes": "Search for any deprecated tags or attributes."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml\nparse sitemap_xml as XML with namespace video=\"http://www.google.com/schemas/sitemap-video/1.1\"\ndeprecated_paths = [\n  \"//video:category\",\n  \"//video:gallery_loc\",\n  \"//video:price\",\n  \"//video:tvshow\",\n  \"//video:player_loc/@autoplay\",\n  \"//video:player_loc/@allow_embed\"\n]\nfound = []\nfor path in deprecated_paths:\n    if XML.xpath(path):\n        found.append(path)\nif found:\n    outcome = fail\nelse:\n    outcome = pass\n"
    },
    "pass_condition": "No deprecated tags or attributes are found in the sitemap.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": ["Deprecated element or attribute found: ${found}"],
    "references": [
      {
        "doc_title": "Deprecated tags and attributes",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/video-sitemaps#deprecated",
        "section_title": "Deprecated tags and attributes",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["video_sitemap", "deprecated"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Sitemap without deprecated tags.",
        "snippet": "<video:video>...</video:video>\n"
      },
      "failing": {
        "description": "Sitemap containing <video:price>.",
        "snippet": "<video:price currency=\"EUR\">1.99</video:price>\n"
      }
    },
    "test_cases": [
      {
        "name": "no_deprecated_tags",
        "input_stub": {
          "sitemap_xml": "<urlset>...</urlset>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "deprecated_tag_present",
        "input_stub": {
          "sitemap_xml": "<urlset><video:price currency=\"EUR\">1.99</video:price></urlset>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NEWS_SITEMAP_REQUIRED_TAGS_PRESENT",
    "title": "Required news sitemap tags must be present",
    "category": "News sitemap reference",
    "requirement": "MUST",
    "severity": "high",
    "scope": "resource",
    "rationale": "Google requires these tags for a news sitemap to be usable by Google News.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "XML content of the news sitemap"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//news:news",
        "attribute": null,
        "notes": "Presence of <news:news> tag"
      },
      {
        "type": "xpath",
        "selector": "//news:publication",
        "attribute": null,
        "notes": "Presence of <news:publication> tag"
      },
      {
        "type": "xpath",
        "selector": "//news:name",
        "attribute": null,
        "notes": "Presence of <news:name> tag"
      },
      {
        "type": "xpath",
        "selector": "//news:language",
        "attribute": null,
        "notes": "Presence of <news:language> tag"
      },
      {
        "type": "xpath",
        "selector": "//news:publication_date",
        "attribute": null,
        "notes": "Presence of <news:publication_date> tag"
      },
      {
        "type": "xpath",
        "selector": "//news:title",
        "attribute": null,
        "notes": "Presence of <news:title> tag"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: sitemap_xml\n# Steps:\n1. Parse sitemap_xml as XML with namespace support.\n2. For each required XPath in evidence_to_collect, check if at least one node exists.\n3. If any required node is missing, set result to fail.\n4. If all required nodes are found, set result to pass.\n"
    },
    "pass_condition": "All required news tags are present at least once in the sitemap.",
    "threshold": {
      "type": "boolean",
      "operator": "==",
      "value": true,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required tag ${missing_tag} in the news sitemap."
    ],
    "references": [
      {
        "doc_title": "News sitemap reference",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/news-sitemap",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["news", "sitemap", "required_tags"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Sitemap contains all required news tags.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\">\n  <url>\n    <loc>http://example.com/article1.html</loc>\n    <news:news>\n      <news:publication>\n        <news:name>Example Times</news:name>\n        <news:language>en</news:language>\n      </news:publication>\n      <news:publication_date>2024-01-17</news:publication_date>\n      <news:title>Article Title</news:title>\n    </news:news>\n  </url>\n</urlset>\n"
      },
      "failing": {
        "description": "Sitemap missing the <news:title> tag.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\">\n  <url>\n    <loc>http://example.com/article1.html</loc>\n    <news:news>\n      <news:publication>\n        <news:name>Example Times</news:name>\n        <news:language>en</news:language>\n      </news:publication>\n      <news:publication_date>2024-01-17</news:publication_date>\n      <!-- Missing news:title -->\n    </news:news>\n  </url>\n</urlset>\n"
      }
    },
    "test_cases": [
      {
        "name": "All required tags present",
        "input_stub": {
          "sitemap_xml": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing <news:title>",
        "input_stub": {
          "sitemap_xml": "<urlset xmlns='http://www.sitemaps.org/schemas/sitemap/0.9' xmlns:news='http://www.google.com/schemas/sitemap-news/0.9'><url><loc>http://example.com/a.html</loc><news:news><news:publication><news:name>Test</news:name><news:language>en</news:language></news:publication><news:publication_date>2024-01-17</news:publication_date></news:news></url></urlset>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "NEWS_SITEMAP_RECENT_URLS_ONLY",
    "title": "URLs must be recent (\u22642 days old)",
    "category": "News sitemap best practices",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Only recent articles should be included in a news sitemap to comply with Google\u2019s best practices.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "XML content of the news sitemap"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url",
        "attribute": null,
        "notes": "Each URL entry"
      },
      {
        "type": "xpath",
        "selector": "./loc",
        "attribute": null,
        "notes": "URL location within each <url>"
      },
      {
        "type": "xpath",
        "selector": "./news:news/news:publication_date",
        "attribute": null,
        "notes": "Publication date for each news article"
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: sitemap_xml, current_date (system date)\n# Steps:\n1. Parse sitemap_xml as XML with namespace support.\n2. For each <url> node:\n   a. Extract the text of ./news:news/news:publication_date.\n   b. Parse the date as YYYY-MM-DD.\n   c. Compute days_difference = current_date - publication_date.\n   d. If days_difference > 2, record failure for this URL.\n3. If any URL fails, overall result is fail; otherwise pass.\n"
    },
    "pass_condition": "All URLs have a publication_date within the last two days.",
    "threshold": {
      "type": "number",
      "operator": "<=",
      "value": 2,
      "unit": "days",
      "notes": "Maximum age of articles allowed in the news sitemap."
    },
    "fail_messages": [
      "URL ${url} has publication date ${observed} which is older than 2 days."
    ],
    "references": [
      {
        "doc_title": "News sitemap best practices",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/news-sitemap",
        "section_title": null,
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["news", "sitemap", "recency"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "All URLs are newer than two days.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\">\n  <url>\n    <loc>http://example.com/recent1.html</loc>\n    <news:news>\n      <news:publication_date>2024-01-17</news:publication_date>\n      <news:title>Recent Article</news:title>\n    </news:news>\n  </url>\n</urlset>\n"
      },
      "failing": {
        "description": "Contains a URL older than two days.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\">\n  <url>\n    <loc>http://example.com/old.html</loc>\n    <news:news>\n      <news:publication_date>2023-12-01</news:publication_date>\n      <news:title>Old Article</news:title>\n    </news:news>\n  </url>\n</urlset>\n"
      }
    },
    "test_cases": [
      {
        "name": "All recent URLs",
        "input_stub": {
          "sitemap_xml": "<urlset xmlns='http://www.sitemaps.org/schemas/sitemap/0.9' xmlns:news='http://www.google.com/schemas/sitemap-news/0.9'><url><loc>http://example.com/recent.html</loc><news:news><news:publication_date>2024-01-17</news:publication_date></news:news></url></urlset>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Contains old URL",
        "input_stub": {
          "sitemap_xml": "<urlset xmlns='http://www.sitemaps.org/schemas/sitemap/0.9' xmlns:news='http://www.google.com/schemas/sitemap-news/0.9'><url><loc>http://example.com/old.html</loc><news:news><news:publication_date>2023-12-01</news:publication_date></news:news></url></urlset>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITEMAP_NAMESPACE_DECLARATION",
    "title": "Verify required namespace declarations for used sitemap extensions",
    "category": "Namespaces",
    "requirement": "UNSPECIFIED",
    "severity": "medium",
    "scope": "site",
    "rationale": "Namespaces must be declared to define extension tags used in the sitemap.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "XML content of the sitemap"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "attribute",
        "selector": "urlset",
        "attribute": "xmlns:*",
        "notes": "Collect all xmlns declarations with prefixes (e.g., xmlns:news, xmlns:video, xmlns:image, xmlns:xhtml)."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml (string)\n# 1. Parse sitemap_xml as XML.\n# 2. From the <urlset> element, collect all attributes whose name starts with \"xmlns:\"; store prefixes.\n# 3. For each <url> element, collect child element tag names that contain a colon (e.g., \"news:news\").\n# 4. Extract the prefix before the colon for each such tag.\n# 5. For each used prefix, verify it exists in the set of declared prefixes.\n# 6. If any used prefix is missing, record it as a failure.\n"
    },
    "pass_condition": "All namespaces used by extension tags in the sitemap are declared on the <urlset> element.",
    "threshold": null,
    "fail_messages": [
      "Missing namespace declaration for prefix ${missing_prefix} used in element ${element}."
    ],
    "references": [
      {
        "doc_title": "How to combine sitemap extensions",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/combined-extensions",
        "section_title": "Namespaces",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["sitemap", "namespace", "extension"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Sitemap includes xmlns:news, xmlns:video, xmlns:xhtml and uses corresponding tags.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\"\n        xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\"\n        xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">\n  <url>\n    <loc>https://example.com/page.html</loc>\n    <news:news>...</news:news>\n    <video:video>...</video:video>\n    <xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"https://example.de/page.html\"/>\n  </url>\n</urlset>\n"
      },
      "failing": {
        "description": "Sitemap uses <video:video> without declaring xmlns:video.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\">\n  <url>\n    <loc>https://example.com/page.html</loc>\n    <video:video>...</video:video>\n  </url>\n</urlset>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid namespaces",
        "input_stub": {
          "sitemap_xml": "<urlset xmlns='http://www.sitemaps.org/schemas/sitemap/0.9' xmlns:news='http://www.google.com/schemas/sitemap-news/0.9'><url><loc>https://example.com</loc><news:news/></url></urlset>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing namespace",
        "input_stub": {
          "sitemap_xml": "<urlset xmlns='http://www.sitemaps.org/schemas/sitemap/0.9'><url><loc>https://example.com</loc><video:video/></url></urlset>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "SITEMAP_EXTENSION_TAG_ORDER",
    "title": "Ensure <loc> appears before any extension tags within each <url>",
    "category": "Combining sitemap extensions",
    "requirement": "UNSPECIFIED",
    "severity": "low",
    "scope": "site",
    "rationale": "The order of extension tags is irrelevant after the <loc> tag; <loc> must be the first element.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "XML content of the sitemap"
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url/*",
        "attribute": null,
        "notes": "Collect the sequence of child elements within each <url>."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Input: sitemap_xml (string)\n# 1. Parse sitemap_xml as XML.\n# 2. For each <url> element:\n#    a. List child elements in document order.\n#    b. Find the position of the <loc> element.\n#    c. Verify that no other element appears before the <loc> element.\n# 3. If any <url> has a non-<loc> element before <loc>, record a failure.\n"
    },
    "pass_condition": "In every <url>, the <loc> element is the first child element.",
    "threshold": null,
    "fail_messages": [
      "Extension tag ${tag} appears before <loc> in a <url> element."
    ],
    "references": [
      {
        "doc_title": "How to combine sitemap extensions",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/combined-extensions",
        "section_title": "Combining sitemap extensions",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["sitemap", "order", "loc"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "<loc> is the first child inside each <url>.",
        "snippet": "<url>\n  <loc>https://example.com/page.html</loc>\n  <news:news>...</news:news>\n  <video:video>...</video:video>\n</url>\n"
      },
      "failing": {
        "description": "An extension tag appears before <loc>.",
        "snippet": "<url>\n  <video:video>...</video:video>\n  <loc>https://example.com/page.html</loc>\n</url>\n"
      }
    },
    "test_cases": [
      {
        "name": "Correct order",
        "input_stub": {
          "sitemap_xml": "<urlset><url><loc>https://example.com</loc><news:news/></url></urlset>"
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Incorrect order",
        "input_stub": {
          "sitemap_xml": "<urlset><url><video:video/><loc>https://example.com</loc></url></urlset>"
        },
        "expected_outcome": "fail"
      }
    ]
  },
  {
    "id": "IMAGE_SITEMAP_REQUIRED_TAGS",
    "title": "Image sitemap must include required tags",
    "category": "Image sitemap reference",
    "requirement": "MUST",
    "severity": "medium",
    "scope": "resource",
    "rationale": "Google requires the <image:image> and <image:loc> tags in an image sitemap for it to be usable.",
    "input_fields": [
      {
        "name": "sitemap_xml",
        "required": true,
        "description": "The XML content of the sitemap file."
      }
    ],
    "preconditions": [],
    "evidence_to_collect": [
      {
        "type": "xpath",
        "selector": "//url/image:image",
        "attribute": null,
        "notes": "Presence of <image:image> element within each <url>."
      },
      {
        "type": "xpath",
        "selector": "//url/image:image/image:loc",
        "attribute": null,
        "notes": "Presence of non\u2011empty <image:loc> child inside each <image:image>."
      }
    ],
    "logic": {
      "language": "pseudocode",
      "code": "# Inputs: sitemap_xml (string)\n# Steps:\n1. Parse sitemap_xml as XML document.\n2. For each <url> element in the document:\n   a. Find all <image:image> children.\n   b. If no <image:image> found, record failure for this <url>.\n   c. For each <image:image>, check for a child <image:loc> with non\u2011empty text.\n   d. If none of the <image:image> elements contain a valid <image:loc>, record failure for this <url>.\n3. If any failures recorded, overall result = fail; else result = pass.\n"
    },
    "pass_condition": "All <url> entries contain at least one <image:image> element with a non\u2011empty <image:loc> child.",
    "threshold": {
      "type": null,
      "operator": null,
      "value": null,
      "unit": null,
      "notes": null
    },
    "fail_messages": [
      "Missing required <image:image> or <image:loc> tag in URL ${url}."
    ],
    "references": [
      {
        "doc_title": "Image sitemaps",
        "url": "https://developers.google.com/search/docs/advanced/sitemaps/image-sitemaps",
        "section_title": "Image sitemap reference",
        "line_range": null,
        "anchor": null
      }
    ],
    "tags": ["image", "sitemap", "required_tags"],
    "insufficient_evidence": false,
    "notes": null,
    "examples": {
      "passing": {
        "description": "Sitemap with required tags present.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\">\n  <url>\n    <loc>https://example.com/page1.html</loc>\n    <image:image>\n      <image:loc>https://example.com/img1.jpg</image:loc>\n    </image:image>\n  </url>\n</urlset>\n"
      },
      "failing": {
        "description": "Sitemap missing <image:loc> inside <image:image>.",
        "snippet": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"\n        xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\">\n  <url>\n    <loc>https://example.com/page2.html</loc>\n    <image:image>\n      <!-- missing image:loc -->\n    </image:image>\n  </url>\n</urlset>\n"
      }
    },
    "test_cases": [
      {
        "name": "Valid image sitemap",
        "input_stub": {
          "sitemap_xml": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "url": null
        },
        "expected_outcome": "pass"
      },
      {
        "name": "Missing required tags",
        "input_stub": {
          "sitemap_xml": null,
          "http_headers": null,
          "lighthouse_metrics": null,
          "robots_txt": null,
          "url": null
        },
        "expected_outcome": "fail"
      }
    ]
  }
]
